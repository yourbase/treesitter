// Code generated by 'ccgo -pkgname=lib -export-defines "" -export-enums "" -export-externs X -export-structs S -export-fields "" -export-typedefs "" -trace-translation-units -o internal/lib/treesitter_darwin_amd64.go -I upstream/tree-sitter/lib/src -I upstream/tree-sitter/lib/include upstream/tree-sitter/lib/src/get_changed_ranges.c upstream/tree-sitter/lib/src/language.c upstream/tree-sitter/lib/src/lexer.c upstream/tree-sitter/lib/src/lib.c upstream/tree-sitter/lib/src/node.c upstream/tree-sitter/lib/src/parser.c upstream/tree-sitter/lib/src/query.c upstream/tree-sitter/lib/src/stack.c upstream/tree-sitter/lib/src/subtree.c upstream/tree-sitter/lib/src/tree.c upstream/tree-sitter/lib/src/tree_cursor.c', DO NOT EDIT.

package lib

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ types.Size_t

const (
	ARG_MAX                                     = 1048576
	BC_BASE_MAX                                 = 99
	BC_DIM_MAX                                  = 2048
	BC_SCALE_MAX                                = 99
	BC_STRING_MAX                               = 1000
	BIG_ENDIAN                                  = 4321
	BUFSIZ                                      = 1024
	BUS_ADRALN                                  = 1
	BUS_ADRERR                                  = 2
	BUS_NOOP                                    = 0
	BUS_OBJERR                                  = 3
	BYTE_ORDER                                  = 1234
	CHARCLASS_NAME_MAX                          = 14
	CHAR_BIT                                    = 8
	CHAR_MAX                                    = 127
	CHAR_MIN                                    = -128
	CHILD_MAX                                   = 266
	CLD_CONTINUED                               = 6
	CLD_DUMPED                                  = 3
	CLD_EXITED                                  = 1
	CLD_KILLED                                  = 2
	CLD_NOOP                                    = 0
	CLD_STOPPED                                 = 5
	CLD_TRAPPED                                 = 4
	CLK_TCK                                     = 100
	COLL_WEIGHTS_MAX                            = 2
	CPUMON_MAKE_FATAL                           = 0x1000
	EOF                                         = -1
	EQUIV_CLASS_MAX                             = 2
	ERROR_COST_PER_MISSING_TREE                 = 110
	ERROR_COST_PER_RECOVERY                     = 500
	ERROR_COST_PER_SKIPPED_CHAR                 = 1
	ERROR_COST_PER_SKIPPED_LINE                 = 30
	ERROR_COST_PER_SKIPPED_TREE                 = 100
	ERROR_STATE                                 = 0
	EXIT_FAILURE                                = 1
	EXIT_SUCCESS                                = 0
	EXPR_NEST_MAX                               = 32
	FILENAME_MAX                                = 1024
	FIXINC_WRAP_STDIO_H_STDIO_STDARG_H          = 1
	FOOTPRINT_INTERVAL_RESET                    = 0x1
	FOPEN_MAX                                   = 20
	FPE_FLTDIV                                  = 1
	FPE_FLTINV                                  = 5
	FPE_FLTOVF                                  = 2
	FPE_FLTRES                                  = 4
	FPE_FLTSUB                                  = 6
	FPE_FLTUND                                  = 3
	FPE_INTDIV                                  = 7
	FPE_INTOVF                                  = 8
	FPE_NOOP                                    = 0
	FP_CHOP                                     = 3
	FP_PREC_24B                                 = 0
	FP_PREC_53B                                 = 2
	FP_PREC_64B                                 = 3
	FP_RND_DOWN                                 = 1
	FP_RND_NEAR                                 = 0
	FP_RND_UP                                   = 2
	FP_STATE_BYTES                              = 512
	GID_MAX                                     = 2147483647
	ILL_BADSTK                                  = 8
	ILL_COPROC                                  = 7
	ILL_ILLADR                                  = 5
	ILL_ILLOPC                                  = 1
	ILL_ILLOPN                                  = 4
	ILL_ILLTRP                                  = 2
	ILL_NOOP                                    = 0
	ILL_PRVOPC                                  = 3
	ILL_PRVREG                                  = 6
	INT16_MAX                                   = 32767
	INT16_MIN                                   = -32768
	INT32_MAX                                   = 2147483647
	INT32_MIN                                   = -2147483648
	INT64_MAX                                   = 9223372036854775807
	INT64_MIN                                   = -9223372036854775808
	INT8_MAX                                    = 127
	INT8_MIN                                    = -128
	INTMAX_MAX                                  = 9223372036854775807
	INTMAX_MIN                                  = -9223372036854775808
	INTPTR_MAX                                  = 9223372036854775807
	INTPTR_MIN                                  = -9223372036854775808
	INT_FAST16_MAX                              = 32767
	INT_FAST16_MIN                              = -32768
	INT_FAST32_MAX                              = 2147483647
	INT_FAST32_MIN                              = -2147483648
	INT_FAST64_MAX                              = 9223372036854775807
	INT_FAST64_MIN                              = -9223372036854775808
	INT_FAST8_MAX                               = 127
	INT_FAST8_MIN                               = -128
	INT_LEAST16_MAX                             = 32767
	INT_LEAST16_MIN                             = -32768
	INT_LEAST32_MAX                             = 2147483647
	INT_LEAST32_MIN                             = -2147483648
	INT_LEAST64_MAX                             = 9223372036854775807
	INT_LEAST64_MIN                             = -9223372036854775808
	INT_LEAST8_MAX                              = 127
	INT_LEAST8_MIN                              = -128
	INT_MAX                                     = 2147483647
	INT_MIN                                     = -2147483648
	IOPOL_APPLICATION                           = 5
	IOPOL_ATIME_UPDATES_DEFAULT                 = 0
	IOPOL_ATIME_UPDATES_OFF                     = 1
	IOPOL_DEFAULT                               = 0
	IOPOL_IMPORTANT                             = 1
	IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT    = 0
	IOPOL_MATERIALIZE_DATALESS_FILES_OFF        = 1
	IOPOL_MATERIALIZE_DATALESS_FILES_ON         = 2
	IOPOL_NORMAL                                = 1
	IOPOL_PASSIVE                               = 2
	IOPOL_SCOPE_DARWIN_BG                       = 2
	IOPOL_SCOPE_PROCESS                         = 0
	IOPOL_SCOPE_THREAD                          = 1
	IOPOL_STANDARD                              = 5
	IOPOL_THROTTLE                              = 3
	IOPOL_TYPE_DISK                             = 0
	IOPOL_TYPE_VFS_ATIME_UPDATES                = 2
	IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION    = 6
	IOPOL_TYPE_VFS_IGNORE_PERMISSIONS           = 7
	IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES   = 3
	IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE            = 8
	IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME        = 4
	IOPOL_TYPE_VFS_TRIGGER_RESOLVE              = 5
	IOPOL_UTILITY                               = 4
	IOPOL_VFS_CONTENT_PROTECTION_DEFAULT        = 0
	IOPOL_VFS_CONTENT_PROTECTION_IGNORE         = 1
	IOPOL_VFS_IGNORE_PERMISSIONS_OFF            = 0
	IOPOL_VFS_IGNORE_PERMISSIONS_ON             = 1
	IOPOL_VFS_SKIP_MTIME_UPDATE_OFF             = 0
	IOPOL_VFS_SKIP_MTIME_UPDATE_ON              = 1
	IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME       = 1
	IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT     = 0
	IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT           = 0
	IOPOL_VFS_TRIGGER_RESOLVE_OFF               = 1
	IOV_MAX                                     = 1024
	LINE_MAX                                    = 2048
	LINK_MAX                                    = 32767
	LITTLE_ENDIAN                               = 1234
	LLONG_MAX                                   = 9223372036854775807
	LLONG_MIN                                   = -9223372036854775808
	LONG_BIT                                    = 64
	LONG_LONG_MAX                               = 9223372036854775807
	LONG_LONG_MIN                               = -9223372036854775808
	LONG_MAX                                    = 9223372036854775807
	LONG_MIN                                    = -9223372036854775808
	L_ctermid                                   = 1024
	L_tmpnam                                    = 1024
	MAC_OS_VERSION_11_0                         = 110000
	MAC_OS_X_VERSION_10_0                       = 1000
	MAC_OS_X_VERSION_10_1                       = 1010
	MAC_OS_X_VERSION_10_10                      = 101000
	MAC_OS_X_VERSION_10_10_2                    = 101002
	MAC_OS_X_VERSION_10_10_3                    = 101003
	MAC_OS_X_VERSION_10_11                      = 101100
	MAC_OS_X_VERSION_10_11_2                    = 101102
	MAC_OS_X_VERSION_10_11_3                    = 101103
	MAC_OS_X_VERSION_10_11_4                    = 101104
	MAC_OS_X_VERSION_10_12                      = 101200
	MAC_OS_X_VERSION_10_12_1                    = 101201
	MAC_OS_X_VERSION_10_12_2                    = 101202
	MAC_OS_X_VERSION_10_12_4                    = 101204
	MAC_OS_X_VERSION_10_13                      = 101300
	MAC_OS_X_VERSION_10_13_1                    = 101301
	MAC_OS_X_VERSION_10_13_2                    = 101302
	MAC_OS_X_VERSION_10_13_4                    = 101304
	MAC_OS_X_VERSION_10_14                      = 101400
	MAC_OS_X_VERSION_10_14_1                    = 101401
	MAC_OS_X_VERSION_10_14_4                    = 101404
	MAC_OS_X_VERSION_10_14_6                    = 101406
	MAC_OS_X_VERSION_10_15                      = 101500
	MAC_OS_X_VERSION_10_15_1                    = 101501
	MAC_OS_X_VERSION_10_16                      = 101600
	MAC_OS_X_VERSION_10_2                       = 1020
	MAC_OS_X_VERSION_10_3                       = 1030
	MAC_OS_X_VERSION_10_4                       = 1040
	MAC_OS_X_VERSION_10_5                       = 1050
	MAC_OS_X_VERSION_10_6                       = 1060
	MAC_OS_X_VERSION_10_7                       = 1070
	MAC_OS_X_VERSION_10_8                       = 1080
	MAC_OS_X_VERSION_10_9                       = 1090
	MAX_CANON                                   = 1024
	MAX_INPUT                                   = 1024
	MB_LEN_MAX                                  = 6
	MINSIGSTKSZ                                 = 32768
	NAME_MAX                                    = 255
	NGROUPS_MAX                                 = 16
	NL_ARGMAX                                   = 9
	NL_LANGMAX                                  = 14
	NL_MSGMAX                                   = 32767
	NL_NMAX                                     = 1
	NL_SETMAX                                   = 255
	NL_TEXTMAX                                  = 2048
	NSIG                                        = 32
	NZERO                                       = 20
	OFF_MAX                                     = 9223372036854775807
	OFF_MIN                                     = -9223372036854775808
	OPEN_MAX                                    = 10240
	PASS_MAX                                    = 128
	PATH_MAX                                    = 1024
	PDP_ENDIAN                                  = 3412
	PIPE_BUF                                    = 512
	POLL_ERR                                    = 4
	POLL_HUP                                    = 6
	POLL_IN                                     = 1
	POLL_MSG                                    = 3
	POLL_OUT                                    = 2
	POLL_PRI                                    = 5
	PRIO_DARWIN_BG                              = 0x1000
	PRIO_DARWIN_NONUI                           = 0x1001
	PRIO_DARWIN_PROCESS                         = 4
	PRIO_DARWIN_THREAD                          = 3
	PRIO_MAX                                    = 20
	PRIO_MIN                                    = -20
	PRIO_PGRP                                   = 1
	PRIO_PROCESS                                = 0
	PRIO_USER                                   = 2
	PTHREAD_DESTRUCTOR_ITERATIONS               = 4
	PTHREAD_KEYS_MAX                            = 512
	PTHREAD_STACK_MIN                           = 8192
	PTRDIFF_MAX                                 = 9223372036854775807
	PTRDIFF_MIN                                 = -9223372036854775808
	P_tmpdir                                    = "/var/tmp/"
	QUAD_MAX                                    = 9223372036854775807
	QUAD_MIN                                    = -9223372036854775808
	RAND_MAX                                    = 0x7fffffff
	RENAME_EXCL                                 = 0x00000004
	RENAME_SECLUDE                              = 0x00000001
	RENAME_SWAP                                 = 0x00000002
	RE_DUP_MAX                                  = 255
	RLIMIT_AS                                   = 5
	RLIMIT_CORE                                 = 4
	RLIMIT_CPU                                  = 0
	RLIMIT_CPU_USAGE_MONITOR                    = 0x2
	RLIMIT_DATA                                 = 2
	RLIMIT_FOOTPRINT_INTERVAL                   = 0x4
	RLIMIT_FSIZE                                = 1
	RLIMIT_MEMLOCK                              = 6
	RLIMIT_NOFILE                               = 8
	RLIMIT_NPROC                                = 7
	RLIMIT_RSS                                  = 5
	RLIMIT_STACK                                = 3
	RLIMIT_THREAD_CPULIMITS                     = 0x3
	RLIMIT_WAKEUPS_MONITOR                      = 0x1
	RLIM_NLIMITS                                = 9
	RSIZE_MAX                                   = 9223372036854775807
	RUSAGE_CHILDREN                             = -1
	RUSAGE_INFO_CURRENT                         = 5
	RUSAGE_INFO_V0                              = 0
	RUSAGE_INFO_V1                              = 1
	RUSAGE_INFO_V2                              = 2
	RUSAGE_INFO_V3                              = 3
	RUSAGE_INFO_V4                              = 4
	RUSAGE_INFO_V5                              = 5
	RUSAGE_SELF                                 = 0
	RU_PROC_RUNS_RESLIDE                        = 0x00000001
	SA_64REGSET                                 = 0x0200
	SA_NOCLDSTOP                                = 0x0008
	SA_NOCLDWAIT                                = 0x0020
	SA_NODEFER                                  = 0x0010
	SA_ONSTACK                                  = 0x0001
	SA_RESETHAND                                = 0x0004
	SA_RESTART                                  = 0x0002
	SA_SIGINFO                                  = 0x0040
	SA_USERSPACE_MASK                           = 127
	SA_USERTRAMP                                = 0x0100
	SCHAR_MAX                                   = 127
	SCHAR_MIN                                   = -128
	SEEK_CUR                                    = 1
	SEEK_END                                    = 2
	SEEK_SET                                    = 0
	SEGV_ACCERR                                 = 2
	SEGV_MAPERR                                 = 1
	SEGV_NOOP                                   = 0
	SHRT_MAX                                    = 32767
	SHRT_MIN                                    = -32768
	SIGABRT                                     = 6
	SIGALRM                                     = 14
	SIGBUS                                      = 10
	SIGCHLD                                     = 20
	SIGCONT                                     = 19
	SIGEMT                                      = 7
	SIGEV_NONE                                  = 0
	SIGEV_SIGNAL                                = 1
	SIGEV_THREAD                                = 3
	SIGFPE                                      = 8
	SIGHUP                                      = 1
	SIGILL                                      = 4
	SIGINFO                                     = 29
	SIGINT                                      = 2
	SIGIO                                       = 23
	SIGIOT                                      = 6
	SIGKILL                                     = 9
	SIGPIPE                                     = 13
	SIGPROF                                     = 27
	SIGQUIT                                     = 3
	SIGSEGV                                     = 11
	SIGSTKSZ                                    = 131072
	SIGSTOP                                     = 17
	SIGSYS                                      = 12
	SIGTERM                                     = 15
	SIGTRAP                                     = 5
	SIGTSTP                                     = 18
	SIGTTIN                                     = 21
	SIGTTOU                                     = 22
	SIGURG                                      = 16
	SIGUSR1                                     = 30
	SIGUSR2                                     = 31
	SIGVTALRM                                   = 26
	SIGWINCH                                    = 28
	SIGXCPU                                     = 24
	SIGXFSZ                                     = 25
	SIG_ATOMIC_MAX                              = 2147483647
	SIG_ATOMIC_MIN                              = -2147483648
	SIG_BLOCK                                   = 1
	SIG_SETMASK                                 = 3
	SIG_UNBLOCK                                 = 2
	SIZE_MAX                                    = 18446744073709551615
	SIZE_T_MAX                                  = 18446744073709551615
	SI_ASYNCIO                                  = 0x10004
	SI_MESGQ                                    = 0x10005
	SI_QUEUE                                    = 0x10002
	SI_TIMER                                    = 0x10003
	SI_USER                                     = 0x10001
	SSIZE_MAX                                   = 9223372036854775807
	SS_DISABLE                                  = 0x0004
	SS_ONSTACK                                  = 0x0001
	SV_INTERRUPT                                = 2
	SV_NOCLDSTOP                                = 8
	SV_NODEFER                                  = 16
	SV_ONSTACK                                  = 1
	SV_RESETHAND                                = 4
	SV_SIGINFO                                  = 64
	TMP_MAX                                     = 308915776
	TRAP_BRKPT                                  = 1
	TRAP_TRACE                                  = 2
	TREE_SITTER_ALLOC_H_                        = 0
	TREE_SITTER_API_H_                          = 0
	TREE_SITTER_ARRAY_H_                        = 0
	TREE_SITTER_ERROR_COSTS_H_                  = 0
	TREE_SITTER_GET_CHANGED_RANGES_H_           = 0
	TREE_SITTER_LANGUAGE_H_                     = 0
	TREE_SITTER_LANGUAGE_VERSION                = 13
	TREE_SITTER_LENGTH_H_                       = 0
	TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION = 13
	TREE_SITTER_PARSER_H_                       = 0
	TREE_SITTER_POINT_H_                        = 0
	TREE_SITTER_SERIALIZATION_BUFFER_SIZE       = 1024
	TREE_SITTER_SUBTREE_H_                      = 0
	TREE_SITTER_TREE_CURSOR_H_                  = 0
	TS_TREE_STATE_NONE                          = 65535
	UCHAR_MAX                                   = 255
	UID_MAX                                     = 2147483647
	UINT16_MAX                                  = 65535
	UINT32_MAX                                  = 4294967295
	UINT64_MAX                                  = 18446744073709551615
	UINT8_MAX                                   = 255
	UINTMAX_MAX                                 = 18446744073709551615
	UINTPTR_MAX                                 = 18446744073709551615
	UINT_FAST16_MAX                             = 65535
	UINT_FAST32_MAX                             = 4294967295
	UINT_FAST64_MAX                             = 18446744073709551615
	UINT_FAST8_MAX                              = 255
	UINT_LEAST16_MAX                            = 65535
	UINT_LEAST32_MAX                            = 4294967295
	UINT_LEAST64_MAX                            = 18446744073709551615
	UINT_LEAST8_MAX                             = 255
	UINT_MAX                                    = 4294967295
	ULLONG_MAX                                  = 18446744073709551615
	ULONG_LONG_MAX                              = 18446744073709551615
	ULONG_MAX                                   = 18446744073709551615
	UQUAD_MAX                                   = 18446744073709551615
	USHRT_MAX                                   = 65535
	WAIT_ANY                                    = -1
	WAIT_MYPGRP                                 = 0
	WAKEMON_DISABLE                             = 0x02
	WAKEMON_ENABLE                              = 0x01
	WAKEMON_GET_PARAMS                          = 0x04
	WAKEMON_MAKE_FATAL                          = 0x10
	WAKEMON_SET_DEFAULTS                        = 0x08
	WCHAR_MAX                                   = 2147483647
	WCHAR_MIN                                   = -2147483648
	WCONTINUED                                  = 0x00000010
	WCOREFLAG                                   = 0200
	WEXITED                                     = 0x00000004
	WINT_MAX                                    = 2147483647
	WINT_MIN                                    = -2147483648
	WNOHANG                                     = 0x00000001
	WNOWAIT                                     = 0x00000020
	WORD_BIT                                    = 32
	WSTOPPED                                    = 0x00000008
	WUNTRACED                                   = 0x00000002
	X_ALLOCA_H_                                 = 0
	X_ASSERT_H_                                 = 0
	X_BSD_I386__TYPES_H_                        = 0
	X_BSD_MACHINE_ENDIAN_H_                     = 0
	X_BSD_MACHINE_SIGNAL_H_                     = 0
	X_BSD_MACHINE_TYPES_H_                      = 0
	X_BSD_MACHINE__TYPES_H_                     = 0
	X_CDEFS_H_                                  = 0
	X_CTERMID_H_                                = 0
	X_CT_RUNE_T                                 = 0
	X_DARWIN_FEATURE_64_BIT_INODE               = 1
	X_DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE      = 1
	X_DARWIN_FEATURE_UNIX_CONFORMANCE           = 3
	X_DEV_T                                     = 0
	X_ERRNO_T                                   = 0
	X_FILE_OFFSET_BITS                          = 64
	X_FORTIFY_SOURCE                            = 2
	X_FSTDIO                                    = 0
	X_GCC_LIMITS_H_                             = 0
	X_GCC_WRAP_STDINT_H                         = 0
	X_I386_LIMITS_H_                            = 0
	X_I386_SIGNAL_H_                            = 1
	X_I386__ENDIAN_H_                           = 0
	X_I386__LIMITS_H_                           = 0
	X_ID_T                                      = 0
	X_INT16_T                                   = 0
	X_INT32_T                                   = 0
	X_INT64_T                                   = 0
	X_INT8_T                                    = 0
	X_INTMAX_T                                  = 0
	X_INTPTR_T                                  = 0
	X_IOFBF                                     = 0
	X_IOLBF                                     = 1
	X_IONBF                                     = 2
	X_LIMITS_H_                                 = 0
	X_LIMITS_H___                               = 0
	X_LP64                                      = 1
	X_MACHTYPES_H_                              = 0
	X_MACH_I386__STRUCTS_H_                     = 0
	X_MACH_MACHINE__STRUCTS_H_                  = 0
	X_MALLOC_UNDERSCORE_MALLOC_H_               = 0
	X_MCONTEXT_T                                = 0
	X_MODE_T                                    = 0
	X_Nonnull                                   = 0
	X_Null_unspecified                          = 0
	X_Nullable                                  = 0
	X_OFF_T                                     = 0
	X_OS__OSBYTEORDERI386_H                     = 0
	X_OS__OSBYTEORDER_H                         = 0
	X_PID_T                                     = 0
	X_POSIX2_BC_BASE_MAX                        = 99
	X_POSIX2_BC_DIM_MAX                         = 2048
	X_POSIX2_BC_SCALE_MAX                       = 99
	X_POSIX2_BC_STRING_MAX                      = 1000
	X_POSIX2_CHARCLASS_NAME_MAX                 = 14
	X_POSIX2_COLL_WEIGHTS_MAX                   = 2
	X_POSIX2_EQUIV_CLASS_MAX                    = 2
	X_POSIX2_EXPR_NEST_MAX                      = 32
	X_POSIX2_LINE_MAX                           = 2048
	X_POSIX2_RE_DUP_MAX                         = 255
	X_POSIX_AIO_LISTIO_MAX                      = 2
	X_POSIX_AIO_MAX                             = 1
	X_POSIX_ARG_MAX                             = 4096
	X_POSIX_CHILD_MAX                           = 25
	X_POSIX_CLOCKRES_MIN                        = 20000000
	X_POSIX_DELAYTIMER_MAX                      = 32
	X_POSIX_HOST_NAME_MAX                       = 255
	X_POSIX_LINK_MAX                            = 8
	X_POSIX_LOGIN_NAME_MAX                      = 9
	X_POSIX_MAX_CANON                           = 255
	X_POSIX_MAX_INPUT                           = 255
	X_POSIX_MQ_OPEN_MAX                         = 8
	X_POSIX_MQ_PRIO_MAX                         = 32
	X_POSIX_NAME_MAX                            = 14
	X_POSIX_NGROUPS_MAX                         = 8
	X_POSIX_OPEN_MAX                            = 20
	X_POSIX_PATH_MAX                            = 256
	X_POSIX_PIPE_BUF                            = 512
	X_POSIX_RE_DUP_MAX                          = 255
	X_POSIX_RTSIG_MAX                           = 8
	X_POSIX_SEM_NSEMS_MAX                       = 256
	X_POSIX_SEM_VALUE_MAX                       = 32767
	X_POSIX_SIGQUEUE_MAX                        = 32
	X_POSIX_SSIZE_MAX                           = 32767
	X_POSIX_SS_REPL_MAX                         = 4
	X_POSIX_STREAM_MAX                          = 8
	X_POSIX_SYMLINK_MAX                         = 255
	X_POSIX_SYMLOOP_MAX                         = 8
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS        = 4
	X_POSIX_THREAD_KEYS_MAX                     = 128
	X_POSIX_THREAD_THREADS_MAX                  = 64
	X_POSIX_TIMER_MAX                           = 32
	X_POSIX_TRACE_EVENT_NAME_MAX                = 30
	X_POSIX_TRACE_NAME_MAX                      = 8
	X_POSIX_TRACE_SYS_MAX                       = 8
	X_POSIX_TRACE_USER_EVENT_MAX                = 32
	X_POSIX_TTY_NAME_MAX                        = 9
	X_POSIX_TZNAME_MAX                          = 6
	X_PTHREAD_ATTR_T                            = 0
	X_QUAD_HIGHWORD                             = 1
	X_QUAD_LOWWORD                              = 0
	X_RLIMIT_POSIX_FLAG                         = 0x1000
	X_RSIZE_T                                   = 0
	X_RUNE_T                                    = 0
	X_SECURE__COMMON_H_                         = 0
	X_SECURE__STDIO_H_                          = 0
	X_SECURE__STRINGS_H_                        = 0
	X_SECURE__STRING_H_                         = 0
	X_SIGSET_T                                  = 0
	X_SIZE_T                                    = 0
	X_SSIZE_T                                   = 0
	X_STDBOOL_H                                 = 0
	X_STDINT_H_                                 = 0
	X_STDIO_H_                                  = 0
	X_STDLIB_H_                                 = 0
	X_STRINGS_H_                                = 0
	X_STRING_H_                                 = 0
	X_SYS_RESOURCE_H_                           = 0
	X_SYS_SIGNAL_H_                             = 0
	X_SYS_STDIO_H_                              = 0
	X_SYS_SYSLIMITS_H_                          = 0
	X_SYS_WAIT_H_                               = 0
	X_SYS__ENDIAN_H_                            = 0
	X_SYS__PTHREAD_TYPES_H_                     = 0
	X_SYS__TYPES_H_                             = 0
	X_UID_T                                     = 0
	X_UINT16_T                                  = 0
	X_UINT32_T                                  = 0
	X_UINT64_T                                  = 0
	X_UINT8_T                                   = 0
	X_UINTMAX_T                                 = 0
	X_UINTPTR_T                                 = 0
	X_USE_FORTIFY_LEVEL                         = 2
	X_U_INT16_T                                 = 0
	X_U_INT32_T                                 = 0
	X_U_INT64_T                                 = 0
	X_U_INT8_T                                  = 0
	X_VA_LIST_T                                 = 0
	X_WCHAR_T                                   = 0
	X_WSTOPPED                                  = 0177
	X_X86_INSTRUCTION_STATE_CACHELINE_SIZE      = 64
	X_X86_INSTRUCTION_STATE_MAX_INSN_BYTES      = 2380
	X_XOPEN_IOV_MAX                             = 16
	X_XOPEN_NAME_MAX                            = 255
	X_XOPEN_PATH_MAX                            = 1024
	False                                       = 0
	True                                        = 1
	Ts_builtin_sym_end                          = 0
	FALSE                                       = 0
	TREE_SITTER_LEXER_H_                        = 0
	TREE_SITTER_UNICODE_H_                      = 0
	TRUE                                        = 1
	U16_MAX_LENGTH                              = 2
	U16_SURROGATE_OFFSET                        = 56613888
	U8_LEAD3_T1_BITS                            = "\x20\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x10\x30\x30"
	U8_LEAD4_T1_BITS                            = "\x00\x00\x00\x00\x00\x00\x00\x00\x1E\x0F\x0F\x0F\x00\x00\x00\x00"
	U8_MAX_LENGTH                               = 4
	U_ATTRIBUTE_DEPRECATED                      = 0
	U_CDECL_BEGIN                               = 0
	U_CDECL_END                                 = 0
	U_CHAR16_IS_TYPEDEF                         = 0
	U_EXPORT                                    = 0
	U_EXPORT2                                   = 0
	U_SENTINEL                                  = -1
	U_SIZEOF_UCHAR                              = 2
	X_ANSI_STDDEF_H                             = 0
	X_BSD_PTRDIFF_T_                            = 0
	X_GCC_MAX_ALIGN_T                           = 0
	X_GCC_PTRDIFF_T                             = 0
	X_PTRDIFF_T                                 = 0
	X_PTRDIFF_T_                                = 0
	X_PTRDIFF_T_DECLARED                        = 0
	X_STDDEF_H                                  = 0
	X_STDDEF_H_                                 = 0
	X_T_PTRDIFF                                 = 0
	X_T_PTRDIFF_                                = 0
	CLOCKS_PER_SEC                              = 1000000
	MAX_ANALYSIS_STATE_DEPTH                    = 12
	MAX_ITERATOR_COUNT                          = 64
	MAX_LINK_COUNT                              = 8
	MAX_NEGATED_FIELD_COUNT                     = 8
	MAX_NODE_POOL_SIZE                          = 50
	MAX_STATE_PREDECESSOR_COUNT                 = 100
	MAX_STEP_CAPTURE_COUNT                      = 3
	SIGPOLL                                     = 7
	TIME_UTC                                    = 1
	TREE_SITTER_ATOMIC_H_                       = 0
	TREE_SITTER_CLOCK_H_                        = 0
	TREE_SITTER_PARSE_STACK_H_                  = 0
	TREE_SITTER_REDUCE_ACTION_H_                = 0
	TREE_SITTER_TREE_H_                         = 0
	TS_MAX_INLINE_TREE_LENGTH                   = 255
	TS_MAX_TREE_POOL_SIZE                       = 32
	X_CACHED_RUNES                              = 256
	X_CLOCK_T                                   = 0
	X_CRMASK                                    = -256
	X_CTYPE_A                                   = 0x00000100
	X_CTYPE_B                                   = 0x00020000
	X_CTYPE_C                                   = 0x00000200
	X_CTYPE_D                                   = 0x00000400
	X_CTYPE_G                                   = 0x00000800
	X_CTYPE_H_                                  = 0
	X_CTYPE_I                                   = 0x00080000
	X_CTYPE_L                                   = 0x00001000
	X_CTYPE_P                                   = 0x00002000
	X_CTYPE_Q                                   = 0x00200000
	X_CTYPE_R                                   = 0x00040000
	X_CTYPE_S                                   = 0x00004000
	X_CTYPE_SW0                                 = 0x20000000
	X_CTYPE_SW1                                 = 0x40000000
	X_CTYPE_SW2                                 = 0x80000000
	X_CTYPE_SW3                                 = 0xc0000000
	X_CTYPE_SWM                                 = 0xe0000000
	X_CTYPE_SWS                                 = 30
	X_CTYPE_T                                   = 0x00100000
	X_CTYPE_U                                   = 0x00008000
	X_CTYPE_X                                   = 0x00010000
	X_POSIX_C_SOURCE                            = 200112
	X_RUNETYPE_H_                               = 0
	X_RUNE_MAGIC_A                              = "RuneMagA"
	X_TIME_H_                                   = 0
	X_TIME_T                                    = 0
	X_WCTRANS_T                                 = 0
	X_WCTYPE_H_                                 = 0
	X_WCTYPE_T                                  = 0
	X_WINT_T                                    = 0
)

// Copyright (C) 1992-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//    If we can use it ok unmodified, then we install this text.
//    If fixincludes fixes it, then the fixed version is installed
//    instead of this text.

// Copyright (c) 2000, 2004-2007, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
//	$NetBSD: limits.h,v 1.8 1996/10/21 05:10:50 jtc Exp $

// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.2 (Berkeley) 1/4/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// This is the `system' limits.h, independent of any particular
//  compiler.  GCC provides its own limits.h which can be found in
//  /usr/lib/gcc, although it is not very informative.
//  This file is public domain.
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// The contents of this file constitute Original Code as defined in and
// are subject to the Apple Public Source License Version 1.1 (the
// "License").  You may not use this file except in compliance with the
// License.  Please obtain a copy of the License at
// http://www.apple.com/publicsource and read it before using this file.
//
// This Original Code and all software distributed under the License are
// distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
// License for the specific language governing rights and limitations
// under the License.
//
// @APPLE_LICENSE_HEADER_END@

// According to ANSI (section 2.2.4.2), the values below must be usable by
// #if preprocessing directives.  Additionally, the expression must have the
// same type as would an expression that is an object of the corresponding
// type converted according to the integral promotions.  The subtraction for
// INT_MIN and LONG_MIN is so the value is not unsigned; 2147483648 is an
// unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
// These numbers work for pcc as well.  The UINT_MAX and ULONG_MAX values
// are written as hex so that GCC will be quiet about large integer constants.

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
//	$NetBSD: syslimits.h,v 1.15 1997/06/25 00:48:09 lukem Exp $

// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)syslimits.h	8.1 (Berkeley) 6/2/93

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// max bytes for an exec function

// Note: CHILD_MAX *must* be less than hard_maxproc, which is set at
// compile time; you *cannot* set it higher than the hard limit!!

// = ((PRIO_MAX - PRIO_MIN) / 2) + 1
// range: 0 - 39 [(2 * NZERO) - 1]
// 0 is not actually used

// Actually for XSI Visible

// Removed in Issue 6

// NZERO to be defined here. TBD. See also sys/param.h

// Copyright (C) 1991-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//    (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//    if the system has its own version of limits.h.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Signal that all the definitions are present.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
const ( /* wait.h:79:1: */
	P_ALL  = 0
	P_PID  = 1
	P_PGID = 2
)

const ( /* time.h:153:1: */
	X_CLOCK_REALTIME           = 0
	X_CLOCK_MONOTONIC          = 6
	X_CLOCK_PROCESS_CPUTIME_ID = 12
	X_CLOCK_THREAD_CPUTIME_ID  = 16
)

const ( /* time.h:153:1: */
	X_CLOCK_MONOTONIC_RAW        = 4
	X_CLOCK_MONOTONIC_RAW_APPROX = 5
	X_CLOCK_UPTIME_RAW           = 8
	X_CLOCK_UPTIME_RAW_APPROX    = 9
)

const ( /* api.h:116:1: */
	TSQueryPredicateStepTypeDone    = 0
	TSQueryPredicateStepTypeCapture = 1
	TSQueryPredicateStepTypeString  = 2
)

const ( /* api.h:127:1: */
	TSQueryErrorNone      = 0
	TSQueryErrorSyntax    = 1
	TSQueryErrorNodeType  = 2
	TSQueryErrorField     = 3
	TSQueryErrorCapture   = 4
	TSQueryErrorStructure = 5
)

const ( /* api.h:44:1: */
	TSInputEncodingUTF8  = 0
	TSInputEncodingUTF16 = 1
)

const ( /* api.h:49:1: */
	TSSymbolTypeRegular   = 0
	TSSymbolTypeAnonymous = 1
	TSSymbolTypeAuxiliary = 2
)

const ( /* api.h:73:1: */
	TSLogTypeParse = 0
	TSLogTypeLex   = 1
)

const ( /* parser.h:53:1: */
	TSParseActionTypeShift   = 0
	TSParseActionTypeReduce  = 1
	TSParseActionTypeAccept  = 2
	TSParseActionTypeRecover = 3
)

const ( /* get_changed_ranges.c:286:1: */
	IteratorDiffers   = 0
	IteratorMayDiffer = 1
	IteratorMatches   = 2
)

const ( /* parser.c:117:1: */
	ErrorComparisonTakeLeft    = 0
	ErrorComparisonPreferLeft  = 1
	ErrorComparisonNone        = 2
	ErrorComparisonPreferRight = 3
	ErrorComparisonTakeRight   = 4
)

const ( /* stack.c:53:1: */
	StackStatusActive = 0
	StackStatusPaused = 1
	StackStatusHalted = 2
)
const ( /* stack.c:78:1: */
	StackActionNone = 0
	StackActionStop = 1
	StackActionPop  = 2
)

type Ptrdiff_t = int64 /* <builtin>:3:26 */

type Size_t = uint64 /* <builtin>:9:23 */

type Wchar_t = int32 /* <builtin>:15:24 */

type X__int128_t = struct {
	Lo int64
	Hi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type X__uint128_t = struct {
	Lo uint64
	Hi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type X__builtin_va_list = uintptr /* <builtin>:46:14 */
type X__float128 = float64        /* <builtin>:47:21 */

// Copyright (C) 1992-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//    If we can use it ok unmodified, then we install this text.
//    If fixincludes fixes it, then the fixed version is installed
//    instead of this text.

// Copyright (c) 2000, 2004-2007, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
//	$NetBSD: limits.h,v 1.8 1996/10/21 05:10:50 jtc Exp $

// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.2 (Berkeley) 1/4/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// This SDK is designed to work with clang and specific versions of
// gcc >= 4.0 with Apple's patch sets

// Compatibility with compilers and environments that don't support compiler
// feature checking function-like macros.

// The __CONCAT macro is used to concatenate parts of symbol names, e.g.
// with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
// The __CONCAT macro is a bit tricky -- make sure you don't put spaces
// in between its arguments.  __CONCAT can also concatenate double-quoted
// strings produced by the __STRING macro, but this only works with ANSI C.

// __unused denotes variables and functions that may not be used, preventing
// the compiler from warning about it if not used.

// __used forces variables and functions to be included even if it appears
// to the compiler that they are not used (and would thust be discarded).

// __cold marks code used for debugging or that is rarely taken
// and tells the compiler to optimize for size and outline code.

// __exported denotes symbols that should be exported even when symbols
// are hidden by default.
// __exported_push/_exported_pop are pragmas used to delimit a range of
//  symbols that should be exported even when symbols are hidden by default.

// __deprecated causes the compiler to produce a warning when encountering
// code using the deprecated functionality.
// __deprecated_msg() does the same, and compilers that support it will print
// a message along with the deprecation warning.
// This may require turning on such warning with the -Wdeprecated flag.
// __deprecated_enum_msg() should be used on enums, and compilers that support
// it will print the deprecation warning.
// __kpi_deprecated() specifically indicates deprecation of kernel programming
// interfaces in Kernel.framework used by KEXTs.

// __unavailable causes the compiler to error out when encountering
// code using the tagged function

// Delete pseudo-keywords wherever they are not available or needed.

// We use `__restrict' as a way to define the `restrict' type qualifier
// without disturbing older software that is unaware of C99 keywords.

// Compatibility with compilers and environments that don't support the
// nullability feature.

// __disable_tail_calls causes the compiler to not perform tail call
// optimization inside the marked function.

// __not_tail_called causes the compiler to prevent tail call optimization
// on statically bound calls to the function.  It has no effect on indirect
// calls.  Virtual functions, objective-c methods, and functions marked as
// "always_inline" cannot be marked as __not_tail_called.

// __result_use_check warns callers of a function that not using the function
// return value is a bug, i.e. dismissing malloc() return value results in a
// memory leak.

// __swift_unavailable causes the compiler to mark a symbol as specifically
// unavailable in Swift, regardless of any other availability in C.

// __abortlike is the attribute to put on functions like abort() that are
// typically used to mark assertions. These optimize the codegen
// for outlining while still maintaining debugability.

// Declaring inline functions within headers is error-prone due to differences
// across various versions of the C language and extensions.  __header_inline
// can be used to declare inline functions within system headers.  In cases
// where you want to force inlining instead of letting the compiler make
// the decision, you can use __header_always_inline.
//
// Be aware that using inline for functions which compilers may also provide
// builtins can behave differently under various compilers.  If you intend to
// provide an inline version of such a function, you may want to use a macro
// instead.
//
// The check for !__GNUC__ || __clang__ is because gcc doesn't correctly
// support c99 inline in some cases:
// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55965

// Compiler-dependent macros that bracket portions of code where the
// "-Wunreachable-code" warning should be ignored. Please use sparingly.

// Compiler-dependent macros to declare that functions take printf-like
// or scanf-like arguments.  They are null except for versions of gcc
// that are known to support the features properly.  Functions declared
// with these attributes will cause compilation warnings if there is a
// mismatch between the format string and subsequent function parameter
// types.

// Source compatibility only, ID string not emitted in object file

// __alloc_size can be used to label function arguments that represent the
// size of memory that the function allocates and returns. The one-argument
// form labels a single argument that gives the allocation size (where the
// arguments are numbered from 1):
//
// void	*malloc(size_t __size) __alloc_size(1);
//
// The two-argument form handles the case where the size is calculated as the
// product of two arguments:
//
// void	*calloc(size_t __count, size_t __size) __alloc_size(1,2);

// COMPILATION ENVIRONMENTS -- see compat(5) for additional detail
//
// DEFAULT	By default newly complied code will get POSIX APIs plus
//		Apple API extensions in scope.
//
//		Most users will use this compilation environment to avoid
//		behavioral differences between 32 and 64 bit code.
//
// LEGACY	Defining _NONSTD_SOURCE will get pre-POSIX APIs plus Apple
//		API extensions in scope.
//
//		This is generally equivalent to the Tiger release compilation
//		environment, except that it cannot be applied to 64 bit code;
//		its use is discouraged.
//
//		We expect this environment to be deprecated in the future.
//
// STRICT	Defining _POSIX_C_SOURCE or _XOPEN_SOURCE restricts the
//		available APIs to exactly the set of APIs defined by the
//		corresponding standard, based on the value defined.
//
//		A correct, portable definition for _POSIX_C_SOURCE is 200112L.
//		A correct, portable definition for _XOPEN_SOURCE is 600L.
//
//		Apple API extensions are not visible in this environment,
//		which can cause Apple specific code to fail to compile,
//		or behave incorrectly if prototypes are not in scope or
//		warnings about missing prototypes are not enabled or ignored.
//
// In any compilation environment, for correct symbol resolution to occur,
// function prototypes must be in scope.  It is recommended that all Apple
// tools users add either the "-Wall" or "-Wimplicit-function-declaration"
// compiler flags to their projects to be warned when a function is being
// used without a prototype in scope.

// These settings are particular to each product.
// Platform: MacOSX

// The __DARWIN_ALIAS macros are used to do symbol renaming; they allow
// legacy code to use the old symbol, thus maintaining binary compatibility
// while new code can use a standards compliant version of the same function.
//
// __DARWIN_ALIAS is used by itself if the function signature has not
// changed, it is used along with a #ifdef check for __DARWIN_UNIX03
// if the signature has changed.  Because the __LP64__ environment
// only supports UNIX03 semantics it causes __DARWIN_UNIX03 to be
// defined, but causes __DARWIN_ALIAS to do no symbol mangling.
//
// As a special case, when XCode is used to target a specific version of the
// OS, the manifest constant __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
// will be defined by the compiler, with the digits representing major version
// time 100 + minor version times 10 (e.g. 10.5 := 1050).  If we are targeting
// pre-10.5, and it is the default compilation environment, revert the
// compilation environment to pre-__DARWIN_UNIX03.

// symbol suffixes used for symbol versioning

// symbol versioning macros

// symbol release macros
// Copyright (c) 2010 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// POSIX.1 requires that the macros we test be defined before any standard
// header file is included.  This permits us to convert values for feature
// testing, as necessary, using only _POSIX_C_SOURCE.
//
// Here's a quick run-down of the versions:
//  defined(_POSIX_SOURCE)		1003.1-1988
//  _POSIX_C_SOURCE == 1L		1003.1-1990
//  _POSIX_C_SOURCE == 2L		1003.2-1992 C Language Binding Option
//  _POSIX_C_SOURCE == 199309L		1003.1b-1993
//  _POSIX_C_SOURCE == 199506L		1003.1c-1995, 1003.1i-1995,
//					and the omnibus ISO/IEC 9945-1: 1996
//  _POSIX_C_SOURCE == 200112L		1003.1-2001
//  _POSIX_C_SOURCE == 200809L		1003.1-2008
//
// In addition, the X/Open Portability Guide, which is now the Single UNIX
// Specification, defines a feature-test macro which indicates the version of
// that specification, and which subsumes _POSIX_C_SOURCE.

// Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1L.

// Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2L.

// Deal with various X/Open Portability Guides and Single UNIX Spec.

// Deal with all versions of POSIX.  The ordering relative to the tests above is
// important.

// POSIX C deprecation macros
// Copyright (c) 2010 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Set a single macro which will always be defined and can be used to determine
// the appropriate namespace.  For POSIX, these values will correspond to
// _POSIX_C_SOURCE value.  Currently there are two additional levels corresponding
// to ANSI (_ANSI_SOURCE) and Darwin extensions (_DARWIN_C_SOURCE)

// If the developer has neither requested a strict language mode nor a version
// of POSIX, turn on functionality provided by __STDC_WANT_LIB_EXT1__ as part
// of __DARWIN_C_FULL.

// long long is not supported in c89 (__STRICT_ANSI__), but g++ -ansi and
// c99 still want long longs.  While not perfect, we allow long longs for
// g++.

// ****************************************
//
//  Public darwin-specific feature macros
//

// _DARWIN_FEATURE_64_BIT_INODE indicates that the ino_t type is 64-bit, and
// structures modified for 64-bit inodes (like struct stat) will be used.

// _DARWIN_FEATURE_64_ONLY_BIT_INODE indicates that the ino_t type may only
// be 64-bit; there is no support for 32-bit ino_t when this macro is defined
// (and non-zero).  There is no struct stat64 either, as the regular
// struct stat will already be the 64-bit version.

// _DARWIN_FEATURE_ONLY_VERS_1050 indicates that only those APIs updated
// in 10.5 exists; no pre-10.5 variants are available.

// _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE indicates only UNIX conforming API
// are available (the legacy BSD APIs are not available)

// _DARWIN_FEATURE_UNIX_CONFORMANCE indicates whether UNIX conformance is on,
// and specifies the conformance level (3 is SUSv3)

// This macro casts away the qualifier from the variable
//
// Note: use at your own risk, removing qualifiers can result in
// catastrophic run-time failures.

// __XNU_PRIVATE_EXTERN is a linkage decoration indicating that a symbol can be
// used from other compilation units, but not other libraries or executables.

// Architecture validation for current SDK

// Similar to OS_ENUM/OS_CLOSED_ENUM/OS_OPTIONS/OS_CLOSED_OPTIONS
//
// This provides more advanced type checking on compilers supporting
// the proper extensions, even in C.

// This is the `system' limits.h, independent of any particular
//  compiler.  GCC provides its own limits.h which can be found in
//  /usr/lib/gcc, although it is not very informative.
//  This file is public domain.
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// The contents of this file constitute Original Code as defined in and
// are subject to the Apple Public Source License Version 1.1 (the
// "License").  You may not use this file except in compliance with the
// License.  Please obtain a copy of the License at
// http://www.apple.com/publicsource and read it before using this file.
//
// This Original Code and all software distributed under the License are
// distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
// License for the specific language governing rights and limitations
// under the License.
//
// @APPLE_LICENSE_HEADER_END@

// According to ANSI (section 2.2.4.2), the values below must be usable by
// #if preprocessing directives.  Additionally, the expression must have the
// same type as would an expression that is an object of the corresponding
// type converted according to the integral promotions.  The subtraction for
// INT_MIN and LONG_MIN is so the value is not unsigned; 2147483648 is an
// unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
// These numbers work for pcc as well.  The UINT_MAX and ULONG_MAX values
// are written as hex so that GCC will be quiet about large integer constants.

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
//	$NetBSD: syslimits.h,v 1.15 1997/06/25 00:48:09 lukem Exp $

// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)syslimits.h	8.1 (Berkeley) 6/2/93

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// max bytes for an exec function

// Note: CHILD_MAX *must* be less than hard_maxproc, which is set at
// compile time; you *cannot* set it higher than the hard limit!!

// = ((PRIO_MAX - PRIO_MIN) / 2) + 1
// range: 0 - 39 [(2 * NZERO) - 1]
// 0 is not actually used

// Actually for XSI Visible

// Removed in Issue 6

// NZERO to be defined here. TBD. See also sys/param.h

// Copyright (C) 1991-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//    (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//    if the system has its own version of limits.h.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Signal that all the definitions are present.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type X__gnuc_va_list = X__builtin_va_list /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// Copyright (c) 2000, 2005, 2007, 2009, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chris Torek.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdio.h	8.5 (Berkeley) 4/29/95

// Copyright (c) 2000, 2005, 2007, 2009, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chris Torek.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdio.h	8.5 (Berkeley) 4/29/95

// Common header for stdio.h and xlocale/_stdio.h

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     These macros are for use in OS header files. They enable function prototypes
//     and Objective-C methods to be tagged with the OS version in which they
//     were first available; and, if applicable, the OS version in which they
//     became deprecated.
//
//     The desktop Mac OS X and iOS each have different version numbers.
//     The __OSX_AVAILABLE_STARTING() macro allows you to specify both the desktop
//     and iOS version numbers.  For instance:
//         __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_2_0)
//     means the function/method was first available on Mac OS X 10.2 on the desktop
//     and first available in iOS 2.0 on the iPhone.
//
//     If a function is available on one platform, but not the other a _NA (not
//     applicable) parameter is used.  For instance:
//             __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA)
//     means that the function/method was first available on Mac OS X 10.3, and it
//     currently not implemented on the iPhone.
//
//     At some point, a function/method may be deprecated.  That means Apple
//     recommends applications stop using the function, either because there is a
//     better replacement or the functionality is being phased out.  Deprecated
//     functions/methods can be tagged with a __OSX_AVAILABLE_BUT_DEPRECATED()
//     macro which specifies the OS version where the function became available
//     as well as the OS version in which it became deprecated.  For instance:
//         __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA)
//     means that the function/method was introduced in Mac OS X 10.0, then
//     became deprecated beginning in Mac OS X 10.5.  On iOS the function
//     has never been available.
//
//     For these macros to function properly, a program must specify the OS version range
//     it is targeting.  The min OS version is specified as an option to the compiler:
//     -mmacosx-version-min=10.x when building for Mac OS X, and -miphoneos-version-min=y.z
//     when building for the iPhone.  The upper bound for the OS version is rarely needed,
//     but it can be set on the command line via: -D__MAC_OS_X_VERSION_MAX_ALLOWED=10x0 for
//     Mac OS X and __IPHONE_OS_VERSION_MAX_ALLOWED = y0z00 for iOS.
//
//     Examples:
//
//         A function available in Mac OS X 10.5 and later, but not on the phone:
//
//             extern void mymacfunc() __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//
//
//         An Objective-C method in Mac OS X 10.5 and later, but not on the phone:
//
//             @interface MyClass : NSObject
//             -(void) mymacmethod __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//             @end
//
//
//         An enum available on the phone, but not available on Mac OS X:
//
//             #if __IPHONE_OS_VERSION_MIN_REQUIRED
//                 enum { myEnum = 1 };
//             #endif
//            Note: this works when targeting the Mac OS X platform because
//            __IPHONE_OS_VERSION_MIN_REQUIRED is undefined which evaluates to zero.
//
//
//         An enum with values added in different iPhoneOS versions:
//
// 			enum {
// 			    myX  = 1,	// Usable on iPhoneOS 2.1 and later
// 			    myY  = 2,	// Usable on iPhoneOS 3.0 and later
// 			    myZ  = 3,	// Usable on iPhoneOS 3.0 and later
// 				...
// 		      Note: you do not want to use #if with enumeration values
// 			  when a client needs to see all values at compile time
// 			  and use runtime logic to only use the viable values.
//
//
//     It is also possible to use the *_VERSION_MIN_REQUIRED in source code to make one
//     source base that can be compiled to target a range of OS versions.  It is best
//     to not use the _MAC_* and __IPHONE_* macros for comparisons, but rather their values.
//     That is because you might get compiled on an old OS that does not define a later
//     OS version macro, and in the C preprocessor undefined values evaluate to zero
//     in expresssions, which could cause the #if expression to evaluate in an unexpected
//     way.
//
//         #ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
//             // code only compiled when targeting Mac OS X and not iPhone
//             // note use of 1050 instead of __MAC_10_5
//             #if __MAC_OS_X_VERSION_MIN_REQUIRED < 1050
//                 // code in here might run on pre-Leopard OS
//             #else
//                 // code here can assume Leopard or later
//             #endif
//         #endif
//
//

// __API_TO_BE_DEPRECATED is used as a version number in API that will be deprecated
// in an upcoming release. This soft deprecation is an intermediate step before formal
// deprecation to notify developers about the API before compiler warnings are generated.
// You can find all places in your code that use soft deprecated API by redefining the
// value of this macro to your current minimum deployment target, for example:
// (macOS)
//   clang -D__API_TO_BE_DEPRECATED=10.12 <other compiler flags>
// (iOS)
//   clang -D__API_TO_BE_DEPRECATED=11.0 <other compiler flags>

// Copyright (c) 2019 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// __MAC_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// __IPHONE_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// Set up standard Mac OS X versions

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     File:       AvailabilityInternal.h
//
//     Contains:   implementation details of __OSX_AVAILABLE_* macros from <Availability.h>
//

// compiler for Mac OS X sets __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__

// make sure a default max version is set

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//

// Evaluate to nothing for compilers that don't support availability.

// Swift compiler version
// Allows for project-agnostic "epochs" for frameworks imported into Swift via the Clang importer, like #if _compiler_version for Swift
// Example:
//
//  #if __swift_compiler_version_at_least(800, 2, 20)
//  - (nonnull NSString *)description;
//  #else
//  - (NSString *)description;
//  #endif

// If __SPI_AVAILABLE has not been defined elsewhere, disable it.

// for use to document app extension usage

// for use marking APIs available info for Mac OSX

// for use marking APIs available info for iOS

// for use marking APIs available info for tvOS

// for use marking APIs available info for Watch OS

// for use marking APIs unavailable for swift

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//
//  * Note that these macros are only compatible with clang compilers that
//  * support the following target selection options:
//  *
//  * -mmacosx-version-min
//  * -miphoneos-version-min
//  * -mwatchos-version-min
//  * -mtvos-version-min
//

// Evaluate to nothing for compilers that don't support availability.

// If SPI decorations have not been defined elsewhere, disable them.

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This header file contains integer types.  It's intended to also contain
// flotaing point and other arithmetic types, as needed, later.

type X__int8_t = int8     /* _types.h:37:33 */
type X__uint8_t = uint8   /* _types.h:41:33 */
type X__int16_t = int16   /* _types.h:42:33 */
type X__uint16_t = uint16 /* _types.h:43:33 */
type X__int32_t = int32   /* _types.h:44:33 */
type X__uint32_t = uint32 /* _types.h:45:33 */
type X__int64_t = int64   /* _types.h:46:33 */
type X__uint64_t = uint64 /* _types.h:47:33 */

type X__darwin_intptr_t = int64   /* _types.h:49:33 */
type X__darwin_natural_t = uint32 /* _types.h:50:33 */

// The rune type below is declared to be an ``int'' instead of the more natural
// ``unsigned long'' or ``long''.  Two things are happening here.  It is not
// unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
// it looks like 10646 will be a 31 bit standard.  This means that if your
// ints cannot hold 32 bits, you will be in trouble.  The reason an int was
// chosen over a long is that the is*() and to*() routines take ints (says
// ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
// here, you lose a bit of ANSI conformance, but your programs will still
// work.
//
// NOTE: rune_t is not covered by ANSI nor other standards, and should not
// be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
// rune_t must be the same type.  Also wint_t must be no narrower than
// wchar_t, and should also be able to hold all members of the largest
// character set plus one extra value (WEOF). wint_t must be at least 16 bits.

type X__darwin_ct_rune_t = int32 /* _types.h:70:33 */ // ct_rune_t

// mbstate_t is an opaque object to keep conversion state, during multibyte
// stream conversions.  The content must not be referenced by user programs.
type X__mbstate_t = struct {
	_           [0]uint64
	X__mbstate8 [128]int8
} /* _types.h:79:3 */

type X__darwin_mbstate_t = X__mbstate_t /* _types.h:81:33 */ // mbstate_t

type X__darwin_ptrdiff_t = int64 /* _types.h:84:33 */ // ptr1 - ptr2

type X__darwin_size_t = uint64 /* _types.h:92:33 */ // sizeof()

type X__darwin_va_list = X__builtin_va_list /* _types.h:98:33 */ // va_list

type X__darwin_wchar_t = int32 /* _types.h:104:33 */ // wchar_t

type X__darwin_rune_t = X__darwin_wchar_t /* _types.h:109:33 */ // rune_t

type X__darwin_wint_t = int32 /* _types.h:112:33 */ // wint_t

type X__darwin_clock_t = uint64        /* _types.h:117:33 */ // clock()
type X__darwin_socklen_t = X__uint32_t /* _types.h:118:33 */ // socklen_t (duh)
type X__darwin_ssize_t = int64         /* _types.h:119:33 */ // byte count or error
type X__darwin_time_t = int64          /* _types.h:120:33 */ // time()

// Type definitions; takes common type definitions that must be used
// in multiple header files due to [XSI], removes them from the system
// space, and puts them in the implementation space.

type X__darwin_blkcnt_t = X__int64_t                    /* _types.h:55:25 */ // total blocks
type X__darwin_blksize_t = X__int32_t                   /* _types.h:56:25 */ // preferred block size
type X__darwin_dev_t = X__int32_t                       /* _types.h:57:25 */ // dev_t
type X__darwin_fsblkcnt_t = uint32                      /* _types.h:58:25 */ // Used by statvfs and fstatvfs
type X__darwin_fsfilcnt_t = uint32                      /* _types.h:59:25 */ // Used by statvfs and fstatvfs
type X__darwin_gid_t = X__uint32_t                      /* _types.h:60:25 */ // [???] process and group IDs
type X__darwin_id_t = X__uint32_t                       /* _types.h:61:25 */ // [XSI] pid_t, uid_t, or gid_t
type X__darwin_ino64_t = X__uint64_t                    /* _types.h:62:25 */ // [???] Used for 64 bit inodes
type X__darwin_ino_t = X__darwin_ino64_t                /* _types.h:64:26 */ // [???] Used for inodes
type X__darwin_mach_port_name_t = X__darwin_natural_t   /* _types.h:68:28 */ // Used by mach
type X__darwin_mach_port_t = X__darwin_mach_port_name_t /* _types.h:69:35 */ // Used by mach
type X__darwin_mode_t = X__uint16_t                     /* _types.h:70:25 */ // [???] Some file attributes
type X__darwin_off_t = X__int64_t                       /* _types.h:71:25 */ // [???] Used for file sizes
type X__darwin_pid_t = X__int32_t                       /* _types.h:72:25 */ // [???] process and group IDs
type X__darwin_sigset_t = X__uint32_t                   /* _types.h:73:25 */ // [???] signal set
type X__darwin_suseconds_t = X__int32_t                 /* _types.h:74:25 */ // [???] microseconds
type X__darwin_uid_t = X__uint32_t                      /* _types.h:75:25 */ // [???] user IDs
type X__darwin_useconds_t = X__uint32_t                 /* _types.h:76:25 */ // [???] microseconds
type X__darwin_uuid_t = [16]uint8                       /* _types.h:77:25 */
type X__darwin_uuid_string_t = [37]int8                 /* _types.h:78:17 */

// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// pthread opaque structures

type S__darwin_pthread_handler_rec = struct {
	X__routine uintptr
	X__arg     uintptr
	X__next    uintptr
} /* _pthread_types.h:57:1 */

type S_opaque_pthread_attr_t = struct {
	X__sig    int64
	X__opaque [56]int8
} /* _pthread_types.h:63:1 */

type S_opaque_pthread_cond_t = struct {
	X__sig    int64
	X__opaque [40]int8
} /* _pthread_types.h:68:1 */

type S_opaque_pthread_condattr_t = struct {
	X__sig    int64
	X__opaque [8]int8
} /* _pthread_types.h:73:1 */

type S_opaque_pthread_mutex_t = struct {
	X__sig    int64
	X__opaque [56]int8
} /* _pthread_types.h:78:1 */

type S_opaque_pthread_mutexattr_t = struct {
	X__sig    int64
	X__opaque [8]int8
} /* _pthread_types.h:83:1 */

type S_opaque_pthread_once_t = struct {
	X__sig    int64
	X__opaque [8]int8
} /* _pthread_types.h:88:1 */

type S_opaque_pthread_rwlock_t = struct {
	X__sig    int64
	X__opaque [192]int8
} /* _pthread_types.h:93:1 */

type S_opaque_pthread_rwlockattr_t = struct {
	X__sig    int64
	X__opaque [16]int8
} /* _pthread_types.h:98:1 */

type S_opaque_pthread_t = struct {
	X__sig           int64
	X__cleanup_stack uintptr
	X__opaque        [8176]int8
} /* _pthread_types.h:103:1 */

type X__darwin_pthread_attr_t = S_opaque_pthread_attr_t             /* _pthread_types.h:109:39 */
type X__darwin_pthread_cond_t = S_opaque_pthread_cond_t             /* _pthread_types.h:110:39 */
type X__darwin_pthread_condattr_t = S_opaque_pthread_condattr_t     /* _pthread_types.h:111:43 */
type X__darwin_pthread_key_t = uint64                               /* _pthread_types.h:112:23 */
type X__darwin_pthread_mutex_t = S_opaque_pthread_mutex_t           /* _pthread_types.h:113:40 */
type X__darwin_pthread_mutexattr_t = S_opaque_pthread_mutexattr_t   /* _pthread_types.h:114:44 */
type X__darwin_pthread_once_t = S_opaque_pthread_once_t             /* _pthread_types.h:115:39 */
type X__darwin_pthread_rwlock_t = S_opaque_pthread_rwlock_t         /* _pthread_types.h:116:41 */
type X__darwin_pthread_rwlockattr_t = S_opaque_pthread_rwlockattr_t /* _pthread_types.h:117:45 */
type X__darwin_pthread_t = uintptr                                  /* _pthread_types.h:118:34 */

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type X__darwin_nl_item = int32        /* _types.h:40:14 */
type X__darwin_wctrans_t = int32      /* _types.h:41:14 */
type X__darwin_wctype_t = X__uint32_t /* _types.h:43:20 */

// DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
// __gnuc_va_list and include <stdarg.h>
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

// Copyright (c) 2000-2008 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.3 (Berkeley) 1/5/94

// Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Basic integral types.  Omit the typedef if
// not possible for a machine/compiler combination.
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int8_t = int8 /* _int8_t.h:30:31 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int16_t = int16 /* _int16_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int32_t = int32 /* _int32_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int64_t = int64 /* _int64_t.h:30:33 */

// Copyright (c) 2016 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int8_t = uint8 /* _u_int8_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int16_t = uint16 /* _u_int16_t.h:30:41 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int32_t = uint32 /* _u_int32_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int64_t = uint64 /* _u_int64_t.h:30:33 */

type Register_t = Int64_t /* types.h:87:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type Intptr_t = X__darwin_intptr_t /* _intptr_t.h:32:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Uintptr_t = uint64 /* _uintptr_t.h:30:33 */

// These types are used for reserving the largest possible size.
type User_addr_t = U_int64_t  /* types.h:97:33 */
type User_size_t = U_int64_t  /* types.h:98:33 */
type User_ssize_t = Int64_t   /* types.h:99:33 */
type User_long_t = Int64_t    /* types.h:100:33 */
type User_ulong_t = U_int64_t /* types.h:101:33 */
type User_time_t = Int64_t    /* types.h:102:33 */
type User_off_t = Int64_t     /* types.h:103:33 */

// This defines the size of syscall arguments after copying into the kernel:
type Syscall_arg_t = U_int64_t /* types.h:111:33 */

type Va_list = X__darwin_va_list /* _va_list.h:32:26 */

type Fpos_t = X__darwin_off_t /* _stdio.h:81:25 */

// NB: to fit things in six character monocase externals, the stdio
// code uses the prefix `__s' for stdio objects, typically followed
// by a three-character attempt at a mnemonic.

// stdio buffers
type S__sbuf = struct {
	X_base      uintptr
	X_size      int32
	__ccgo_pad1 [4]byte
} /* _stdio.h:92:1 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type S__sFILE = struct {
	X_p         uintptr
	X_r         int32
	X_w         int32
	X_flags     int16
	X_file      int16
	__ccgo_pad1 [4]byte
	X_bf        struct {
		X_base      uintptr
		X_size      int32
		__ccgo_pad1 [4]byte
	}
	X_lbfsize   int32
	__ccgo_pad2 [4]byte
	X_cookie    uintptr
	X_close     uintptr
	X_read      uintptr
	X_seek      uintptr
	X_write     uintptr
	X_ub        struct {
		X_base      uintptr
		X_size      int32
		__ccgo_pad1 [4]byte
	}
	X_extra uintptr
	X_ur    int32
	X_ubuf  [3]uint8
	X_nbuf  [1]uint8
	X_lb    struct {
		X_base      uintptr
		X_size      int32
		__ccgo_pad1 [4]byte
	}
	X_blksize   int32
	__ccgo_pad3 [4]byte
	X_offset    Fpos_t
} /* _stdio.h:126:9 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type FILE = S__sFILE /* _stdio.h:157:3 */

// Additional functionality provided by:
// POSIX.1-2001
// ISO C99

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Off_t = X__darwin_off_t /* _off_t.h:31:33 */

// Additional functionality provided by:
// POSIX.1-2008

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Ssize_t = X__darwin_ssize_t /* _ssize_t.h:31:33 */

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
type Idtype_t = uint32 /* wait.h:83:3 */

// [XSI] The id_t and pid_t types shall be defined as described
// in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pid_t = X__darwin_pid_t /* _pid_t.h:31:31 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Id_t = X__darwin_id_t /* _id_t.h:31:25 */ // can hold pid_t, gid_t, or uid_t

// [XSI] The siginfo_t type shall be defined as described in <signal.h>
// [XSI] The rusage structure shall be defined as described in <sys/resource.h>
// [XSI] Inclusion of the <sys/wait.h> header may also make visible all
// symbols from <signal.h> and <sys/resource.h>
//
// NOTE:	This requirement is currently being satisfied by the direct
//		inclusion of <sys/signal.h> and <sys/resource.h>, below.
//
//		Software should not depend on the exposure of anything other
//		than the types siginfo_t and struct rusage as a result of
//		this inclusion.  If you depend on any types or manifest
//		values othe than siginfo_t and struct rusage from either of
//		those files, you should explicitly include them yourself, as
//		well, or in future releases your stware may not compile
//		without modification.
// Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.2 (Berkeley) 1/21/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1992 NeXT Computer, Inc.
//

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

type Sig_atomic_t = int32 /* signal.h:39:13 */

// Language spec sez we must list exactly one parameter, even though we
// actually supply three.  Ugh!
// SIG_HOLD is chosen to avoid KERN_SIG_* values in <sys/signalvar.h>

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// @OSF_COPYRIGHT@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

// i386 is the structure that is exported to user threads for
// use in status/mutate calls.  This structure should never change.
//

type S__darwin_i386_thread_state = struct {
	X__eax    uint32
	X__ebx    uint32
	X__ecx    uint32
	X__edx    uint32
	X__edi    uint32
	X__esi    uint32
	X__ebp    uint32
	X__esp    uint32
	X__ss     uint32
	X__eflags uint32
	X__eip    uint32
	X__cs     uint32
	X__ds     uint32
	X__es     uint32
	X__fs     uint32
	X__gs     uint32
} /* _structs.h:46:1 */

// This structure should be double-word aligned for performance

type S__darwin_fp_control = struct {
	__ccgo_pad1 [0]uint16
	X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
} /* _structs.h:92:1 */

type X__darwin_fp_control_t = S__darwin_fp_control /* _structs.h:117:28 */

// Status word.

type S__darwin_fp_status = struct {
	__ccgo_pad1 [0]uint16
	X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
} /* _structs.h:150:1 */

type X__darwin_fp_status_t = S__darwin_fp_status /* _structs.h:167:27 */

// defn of 80bit x87 FPU or MMX register

type S__darwin_mmst_reg = struct {
	X__mmst_reg  [10]int8
	X__mmst_rsrv [6]int8
} /* _structs.h:194:1 */

// defn of 128 bit XMM regs

type S__darwin_xmm_reg = struct{ X__xmm_reg [16]int8 } /* _structs.h:213:1 */

// defn of 256 bit YMM regs

type S__darwin_ymm_reg = struct{ X__ymm_reg [32]int8 } /* _structs.h:229:1 */

// defn of 512 bit ZMM regs

type S__darwin_zmm_reg = struct{ X__zmm_reg [64]int8 } /* _structs.h:245:1 */

type S__darwin_opmask_reg = struct{ X__opmask_reg [8]int8 } /* _structs.h:259:1 */

// Floating point state.

type S__darwin_i386_float_state = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [224]int8
	X__fpu_reserved1 int32
} /* _structs.h:281:1 */

type S__darwin_i386_avx_state = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [224]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
} /* _structs.h:318:1 */

type S__darwin_i386_avx512_state = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [224]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	X__fpu_k0        struct{ X__opmask_reg [8]int8 }
	X__fpu_k1        struct{ X__opmask_reg [8]int8 }
	X__fpu_k2        struct{ X__opmask_reg [8]int8 }
	X__fpu_k3        struct{ X__opmask_reg [8]int8 }
	X__fpu_k4        struct{ X__opmask_reg [8]int8 }
	X__fpu_k5        struct{ X__opmask_reg [8]int8 }
	X__fpu_k6        struct{ X__opmask_reg [8]int8 }
	X__fpu_k7        struct{ X__opmask_reg [8]int8 }
	X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
} /* _structs.h:364:1 */

type S__darwin_i386_exception_state = struct {
	X__trapno     X__uint16_t
	X__cpu        X__uint16_t
	X__err        X__uint32_t
	X__faultvaddr X__uint32_t
} /* _structs.h:575:1 */

type S__darwin_x86_debug_state32 = struct {
	X__dr0 uint32
	X__dr1 uint32
	X__dr2 uint32
	X__dr3 uint32
	X__dr4 uint32
	X__dr5 uint32
	X__dr6 uint32
	X__dr7 uint32
} /* _structs.h:595:1 */

type S__x86_instruction_state = struct {
	X__insn_stream_valid_bytes int32
	X__insn_offset             int32
	X__out_of_synch            int32
	X__insn_bytes              [2380]X__uint8_t
	X__insn_cacheline          [64]X__uint8_t
} /* _structs.h:608:1 */

type S__last_branch_record = struct {
	X__from_ip    X__uint64_t
	X__to_ip      X__uint64_t
	X__mispredict uint32 /* __uint32_t __mispredict: 1, __uint32_t __tsx_abort: 1, __uint32_t __in_tsx: 1, __uint32_t __cycle_count: 16, __uint32_t __reserved: 13 */
	__ccgo_pad1   [4]byte
} /* _structs.h:624:1 */

type S__last_branch_state = struct {
	X__lbr_count         int32
	X__lbr_supported_tsx uint32 /* __uint32_t __lbr_supported_tsx: 1, __uint32_t __lbr_supported_cycle_count: 1, __uint32_t __reserved: 30 */
	__ccgo_pad1          [8]byte
	X__lbrs              [32]struct {
		X__from_ip    X__uint64_t
		X__to_ip      X__uint64_t
		X__mispredict uint32 /* __uint32_t __mispredict: 1, __uint32_t __tsx_abort: 1, __uint32_t __in_tsx: 1, __uint32_t __cycle_count: 16, __uint32_t __reserved: 13 */
		__ccgo_pad1   [4]byte
	}
} /* _structs.h:636:1 */

type S__x86_pagein_state = struct{ X__pagein_error int32 } /* _structs.h:702:1 */

// 64 bit versions of the above

type S__darwin_x86_thread_state64 = struct {
	X__rax    X__uint64_t
	X__rbx    X__uint64_t
	X__rcx    X__uint64_t
	X__rdx    X__uint64_t
	X__rdi    X__uint64_t
	X__rsi    X__uint64_t
	X__rbp    X__uint64_t
	X__rsp    X__uint64_t
	X__r8     X__uint64_t
	X__r9     X__uint64_t
	X__r10    X__uint64_t
	X__r11    X__uint64_t
	X__r12    X__uint64_t
	X__r13    X__uint64_t
	X__r14    X__uint64_t
	X__r15    X__uint64_t
	X__rip    X__uint64_t
	X__rflags X__uint64_t
	X__cs     X__uint64_t
	X__fs     X__uint64_t
	X__gs     X__uint64_t
} /* _structs.h:713:1 */

// 64 bit versions of the above (complete)

type S__darwin_x86_thread_full_state64 = struct {
	X__ss64 struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__ds     X__uint64_t
	X__es     X__uint64_t
	X__ss     X__uint64_t
	X__gsbase X__uint64_t
} /* _structs.h:771:1 */

type S__darwin_x86_float_state64 = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [96]int8
	X__fpu_reserved1 int32
} /* _structs.h:794:1 */

type S__darwin_x86_avx_state64 = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [96]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
} /* _structs.h:845:1 */

type S__darwin_x86_avx512_state64 = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [96]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
	X__fpu_k0        struct{ X__opmask_reg [8]int8 }
	X__fpu_k1        struct{ X__opmask_reg [8]int8 }
	X__fpu_k2        struct{ X__opmask_reg [8]int8 }
	X__fpu_k3        struct{ X__opmask_reg [8]int8 }
	X__fpu_k4        struct{ X__opmask_reg [8]int8 }
	X__fpu_k5        struct{ X__opmask_reg [8]int8 }
	X__fpu_k6        struct{ X__opmask_reg [8]int8 }
	X__fpu_k7        struct{ X__opmask_reg [8]int8 }
	X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh8     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh9     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh10    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh11    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh12    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh13    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh14    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh15    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmm16     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm17     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm18     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm19     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm20     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm21     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm22     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm23     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm24     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm25     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm26     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm27     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm28     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm29     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm30     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm31     struct{ X__zmm_reg [64]int8 }
} /* _structs.h:913:1 */

type S__darwin_x86_exception_state64 = struct {
	X__trapno     X__uint16_t
	X__cpu        X__uint16_t
	X__err        X__uint32_t
	X__faultvaddr X__uint64_t
} /* _structs.h:1252:1 */

type S__darwin_x86_debug_state64 = struct {
	X__dr0 X__uint64_t
	X__dr1 X__uint64_t
	X__dr2 X__uint64_t
	X__dr3 X__uint64_t
	X__dr4 X__uint64_t
	X__dr5 X__uint64_t
	X__dr6 X__uint64_t
	X__dr7 X__uint64_t
} /* _structs.h:1272:1 */

type S__darwin_x86_cpmu_state64 = struct{ X__ctrs [16]X__uint64_t } /* _structs.h:1300:1 */

type S__darwin_mcontext32 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint32_t
	}
	X__ss struct {
		X__eax    uint32
		X__ebx    uint32
		X__ecx    uint32
		X__edx    uint32
		X__edi    uint32
		X__esi    uint32
		X__ebp    uint32
		X__esp    uint32
		X__ss     uint32
		X__eflags uint32
		X__eip    uint32
		X__cs     uint32
		X__ds     uint32
		X__es     uint32
		X__fs     uint32
		X__gs     uint32
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [224]int8
		X__fpu_reserved1 int32
	}
} /* _mcontext.h:39:1 */

type S__darwin_mcontext_avx32 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint32_t
	}
	X__ss struct {
		X__eax    uint32
		X__ebx    uint32
		X__ecx    uint32
		X__edx    uint32
		X__edi    uint32
		X__esi    uint32
		X__ebp    uint32
		X__esp    uint32
		X__ss     uint32
		X__eflags uint32
		X__eip    uint32
		X__cs     uint32
		X__ds     uint32
		X__es     uint32
		X__fs     uint32
		X__gs     uint32
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [224]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	}
} /* _mcontext.h:47:1 */

type S__darwin_mcontext_avx512_32 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint32_t
	}
	X__ss struct {
		X__eax    uint32
		X__ebx    uint32
		X__ecx    uint32
		X__edx    uint32
		X__edi    uint32
		X__esi    uint32
		X__ebp    uint32
		X__esp    uint32
		X__ss     uint32
		X__eflags uint32
		X__eip    uint32
		X__cs     uint32
		X__ds     uint32
		X__es     uint32
		X__fs     uint32
		X__gs     uint32
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [224]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_k0        struct{ X__opmask_reg [8]int8 }
		X__fpu_k1        struct{ X__opmask_reg [8]int8 }
		X__fpu_k2        struct{ X__opmask_reg [8]int8 }
		X__fpu_k3        struct{ X__opmask_reg [8]int8 }
		X__fpu_k4        struct{ X__opmask_reg [8]int8 }
		X__fpu_k5        struct{ X__opmask_reg [8]int8 }
		X__fpu_k6        struct{ X__opmask_reg [8]int8 }
		X__fpu_k7        struct{ X__opmask_reg [8]int8 }
		X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
	}
} /* _mcontext.h:56:1 */

type S__darwin_mcontext64 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:97:1 */

type S__darwin_mcontext64_full = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__ss64 struct {
			X__rax    X__uint64_t
			X__rbx    X__uint64_t
			X__rcx    X__uint64_t
			X__rdx    X__uint64_t
			X__rdi    X__uint64_t
			X__rsi    X__uint64_t
			X__rbp    X__uint64_t
			X__rsp    X__uint64_t
			X__r8     X__uint64_t
			X__r9     X__uint64_t
			X__r10    X__uint64_t
			X__r11    X__uint64_t
			X__r12    X__uint64_t
			X__r13    X__uint64_t
			X__r14    X__uint64_t
			X__r15    X__uint64_t
			X__rip    X__uint64_t
			X__rflags X__uint64_t
			X__cs     X__uint64_t
			X__fs     X__uint64_t
			X__gs     X__uint64_t
		}
		X__ds     X__uint64_t
		X__es     X__uint64_t
		X__ss     X__uint64_t
		X__gsbase X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:105:1 */

type S__darwin_mcontext_avx64 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:113:1 */

type S__darwin_mcontext_avx64_full = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__ss64 struct {
			X__rax    X__uint64_t
			X__rbx    X__uint64_t
			X__rcx    X__uint64_t
			X__rdx    X__uint64_t
			X__rdi    X__uint64_t
			X__rsi    X__uint64_t
			X__rbp    X__uint64_t
			X__rsp    X__uint64_t
			X__r8     X__uint64_t
			X__r9     X__uint64_t
			X__r10    X__uint64_t
			X__r11    X__uint64_t
			X__r12    X__uint64_t
			X__r13    X__uint64_t
			X__r14    X__uint64_t
			X__r15    X__uint64_t
			X__rip    X__uint64_t
			X__rflags X__uint64_t
			X__cs     X__uint64_t
			X__fs     X__uint64_t
			X__gs     X__uint64_t
		}
		X__ds     X__uint64_t
		X__es     X__uint64_t
		X__ss     X__uint64_t
		X__gsbase X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:121:1 */

type S__darwin_mcontext_avx512_64 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
		X__fpu_k0        struct{ X__opmask_reg [8]int8 }
		X__fpu_k1        struct{ X__opmask_reg [8]int8 }
		X__fpu_k2        struct{ X__opmask_reg [8]int8 }
		X__fpu_k3        struct{ X__opmask_reg [8]int8 }
		X__fpu_k4        struct{ X__opmask_reg [8]int8 }
		X__fpu_k5        struct{ X__opmask_reg [8]int8 }
		X__fpu_k6        struct{ X__opmask_reg [8]int8 }
		X__fpu_k7        struct{ X__opmask_reg [8]int8 }
		X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh8     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh9     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh10    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh11    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh12    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh13    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh14    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh15    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmm16     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm17     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm18     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm19     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm20     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm21     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm22     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm23     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm24     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm25     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm26     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm27     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm28     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm29     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm30     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm31     struct{ X__zmm_reg [64]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:130:1 */

type S__darwin_mcontext_avx512_64_full = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__ss64 struct {
			X__rax    X__uint64_t
			X__rbx    X__uint64_t
			X__rcx    X__uint64_t
			X__rdx    X__uint64_t
			X__rdi    X__uint64_t
			X__rsi    X__uint64_t
			X__rbp    X__uint64_t
			X__rsp    X__uint64_t
			X__r8     X__uint64_t
			X__r9     X__uint64_t
			X__r10    X__uint64_t
			X__r11    X__uint64_t
			X__r12    X__uint64_t
			X__r13    X__uint64_t
			X__r14    X__uint64_t
			X__r15    X__uint64_t
			X__rip    X__uint64_t
			X__rflags X__uint64_t
			X__cs     X__uint64_t
			X__fs     X__uint64_t
			X__gs     X__uint64_t
		}
		X__ds     X__uint64_t
		X__es     X__uint64_t
		X__ss     X__uint64_t
		X__gsbase X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
		X__fpu_k0        struct{ X__opmask_reg [8]int8 }
		X__fpu_k1        struct{ X__opmask_reg [8]int8 }
		X__fpu_k2        struct{ X__opmask_reg [8]int8 }
		X__fpu_k3        struct{ X__opmask_reg [8]int8 }
		X__fpu_k4        struct{ X__opmask_reg [8]int8 }
		X__fpu_k5        struct{ X__opmask_reg [8]int8 }
		X__fpu_k6        struct{ X__opmask_reg [8]int8 }
		X__fpu_k7        struct{ X__opmask_reg [8]int8 }
		X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh8     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh9     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh10    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh11    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh12    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh13    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh14    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh15    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmm16     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm17     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm18     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm19     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm20     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm21     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm22     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm23     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm24     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm25     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm26     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm27     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm28     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm29     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm30     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm31     struct{ X__zmm_reg [64]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:138:1 */

type Mcontext_t = uintptr /* _mcontext.h:204:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_attr_t = X__darwin_pthread_attr_t /* _pthread_attr_t.h:31:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type S__darwin_sigaltstack = struct {
	Ss_sp       uintptr
	Ss_size     X__darwin_size_t
	Ss_flags    int32
	__ccgo_pad1 [4]byte
} /* _sigaltstack.h:42:1 */

type Stack_t = S__darwin_sigaltstack /* _sigaltstack.h:48:33 */ // [???] signal stack

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

type S__darwin_ucontext = struct {
	Uc_onstack int32
	Uc_sigmask X__darwin_sigset_t
	Uc_stack   struct {
		Ss_sp       uintptr
		Ss_size     X__darwin_size_t
		Ss_flags    int32
		__ccgo_pad1 [4]byte
	}
	Uc_link     uintptr
	Uc_mcsize   X__darwin_size_t
	Uc_mcontext uintptr
} /* _ucontext.h:43:1 */

// user context
type Ucontext_t = S__darwin_ucontext /* _ucontext.h:57:33 */ // [???] user context

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Sigset_t = X__darwin_sigset_t /* _sigset_t.h:31:41 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uid_t = X__darwin_uid_t /* _uid_t.h:31:31 */

type Ssigval = struct {
	_         [0]uint64
	Sival_int int32
	_         [4]byte
} /* signal.h:158:1 */

type Ssigevent = struct {
	Sigev_notify int32
	Sigev_signo  int32
	Sigev_value  struct {
		_         [0]uint64
		Sival_int int32
		_         [4]byte
	}
	Sigev_notify_function   uintptr
	Sigev_notify_attributes uintptr
} /* signal.h:168:1 */

type S__siginfo = struct {
	Si_signo  int32
	Si_errno  int32
	Si_code   int32
	Si_pid    Pid_t
	Si_uid    Uid_t
	Si_status int32
	Si_addr   uintptr
	Si_value  struct {
		_         [0]uint64
		Sival_int int32
		_         [4]byte
	}
	Si_band int64
	X__pad  [7]uint64
} /* signal.h:177:9 */

type Siginfo_t = S__siginfo /* signal.h:188:3 */

// When the signal is SIGILL or SIGFPE, si_addr contains the address of
// the faulting instruction.
// When the signal is SIGSEGV or SIGBUS, si_addr contains the address of
// the faulting memory reference. Although for x86 there are cases of SIGSEGV
// for which si_addr cannot be determined and is NULL.
// If the signal is SIGCHLD, the si_pid field will contain the child process ID,
//  si_status contains the exit value or signal and
//  si_uid contains the real user ID of the process that sent the signal.

// Values for si_code

// Codes for SIGILL

// Codes for SIGFPE

// Codes for SIGSEGV

// Codes for SIGBUS

// Codes for SIGTRAP

// Codes for SIGCHLD

// Codes for SIGPOLL

// union for signal handlers
type S__sigaction_u = struct{ X__sa_handler uintptr } /* signal.h:269:1 */

// Signal vector template for Kernel user boundary
type S__sigaction = struct {
	X__sigaction_u struct{ X__sa_handler uintptr }
	Sa_tramp       uintptr
	Sa_mask        Sigset_t
	Sa_flags       int32
} /* signal.h:276:1 */

// Signal vector "template" used in sigaction call.
type Ssigaction = struct {
	X__sigaction_u struct{ X__sa_handler uintptr }
	Sa_mask        Sigset_t
	Sa_flags       int32
} /* signal.h:286:1 */

// if SA_SIGINFO is set, sa_sigaction is to be used instead of sa_handler.

// This will provide 64bit register set in a 32bit user address space

// the following are the only bits we support from user space, the
// rest are for kernel use only.

// Flags for sigprocmask:

// POSIX 1003.1b required values.

type Sig_t = uintptr /* signal.h:331:14 */ // type of signal function

// Structure used in sigaltstack call.

// 4.3 compatibility:
// Signal vector "template" used in sigvec call.
type Ssigvec = struct {
	Sv_handler uintptr
	Sv_mask    int32
	Sv_flags   int32
} /* signal.h:348:1 */

// Structure used in sigstack call.
type Ssigstack = struct {
	Ss_sp       uintptr
	Ss_onstack  int32
	__ccgo_pad1 [4]byte
} /* signal.h:367:1 */

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)resource.h	8.2 (Berkeley) 1/4/94

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (c) 2000-2010 Apple Inc.
// All rights reserved.

// from ISO/IEC 988:1999 spec

// 7.18.1.1 Exact-width integer types
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint8_t = uint8 /* _uint8_t.h:31:23 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint16_t = uint16 /* _uint16_t.h:31:24 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint32_t = uint32 /* _uint32_t.h:31:22 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uint64_t = uint64 /* _uint64_t.h:31:28 */

// 7.18.1.2 Minimum-width integer types
type Int_least8_t = Int8_t     /* stdint.h:38:26 */
type Int_least16_t = Int16_t   /* stdint.h:39:25 */
type Int_least32_t = Int32_t   /* stdint.h:40:25 */
type Int_least64_t = Int64_t   /* stdint.h:41:25 */
type Uint_least8_t = Uint8_t   /* stdint.h:42:25 */
type Uint_least16_t = Uint16_t /* stdint.h:43:24 */
type Uint_least32_t = Uint32_t /* stdint.h:44:24 */
type Uint_least64_t = Uint64_t /* stdint.h:45:24 */

// 7.18.1.3 Fastest-width integer types
type Int_fast8_t = Int8_t     /* stdint.h:49:27 */
type Int_fast16_t = Int16_t   /* stdint.h:50:26 */
type Int_fast32_t = Int32_t   /* stdint.h:51:26 */
type Int_fast64_t = Int64_t   /* stdint.h:52:26 */
type Uint_fast8_t = Uint8_t   /* stdint.h:53:26 */
type Uint_fast16_t = Uint16_t /* stdint.h:54:25 */
type Uint_fast32_t = Uint32_t /* stdint.h:55:25 */
type Uint_fast64_t = Uint64_t /* stdint.h:56:25 */

// 7.18.1.4 Integer types capable of holding object pointers

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// 7.18.1.5 Greatest-width integer types
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Intmax_t = int64 /* _intmax_t.h:32:25 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uintmax_t = uint64 /* _uintmax_t.h:32:26 */

// 7.18.4 Macros for integer constants

// 7.18.2 Limits of specified-width integer types:
//   These #defines specify the minimum and maximum limits
//   of each of the types declared above.
//
//   They must have "the same type as would an expression that is an
//   object of the corresponding type converted according to the integer
//   promotion".

// 7.18.2.1 Limits of exact-width integer types

//
//       Note:  the literal "most negative int" cannot be written in C --
//       the rules in the standard (section 6.4.4.1 in C99) will give it
//       an unsigned type, so INT32_MIN (and the most negative member of
//       any larger signed type) must be written via a constant expression.
//

// 7.18.2.2 Limits of minimum-width integer types

// 7.18.2.3 Limits of fastest minimum-width integer types

// 7.18.2.4 Limits of integer types capable of holding object pointers

// 7.18.2.5 Limits of greatest-width integer types

// 7.18.3 "Other"

// WCHAR_MIN should be 0 if wchar_t is an unsigned type and
//    (-WCHAR_MAX-1) if wchar_t is a signed type.  Unfortunately,
//    it turns out that -fshort-wchar changes the signedness of
//    the type.

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// [XSI] The timeval structure shall be defined as described in
// <sys/time.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Stimeval = struct {
	Tv_sec      X__darwin_time_t
	Tv_usec     X__darwin_suseconds_t
	__ccgo_pad1 [4]byte
} /* _timeval.h:34:1 */

// The id_t type shall be defined as described in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Resource limit type (low 63 bits, excluding the sign bit)
type Rlim_t = X__uint64_t /* resource.h:89:25 */

// Flavors for proc_pid_rusage().

// Flags for RUSAGE_INFO_V5

type Rusage_info_t = uintptr /* resource.h:199:14 */

type Srusage_info_v0 = struct {
	Ri_uuid               [16]Uint8_t
	Ri_user_time          Uint64_t
	Ri_system_time        Uint64_t
	Ri_pkg_idle_wkups     Uint64_t
	Ri_interrupt_wkups    Uint64_t
	Ri_pageins            Uint64_t
	Ri_wired_size         Uint64_t
	Ri_resident_size      Uint64_t
	Ri_phys_footprint     Uint64_t
	Ri_proc_start_abstime Uint64_t
	Ri_proc_exit_abstime  Uint64_t
} /* resource.h:201:1 */

type Srusage_info_v1 = struct {
	Ri_uuid                  [16]Uint8_t
	Ri_user_time             Uint64_t
	Ri_system_time           Uint64_t
	Ri_pkg_idle_wkups        Uint64_t
	Ri_interrupt_wkups       Uint64_t
	Ri_pageins               Uint64_t
	Ri_wired_size            Uint64_t
	Ri_resident_size         Uint64_t
	Ri_phys_footprint        Uint64_t
	Ri_proc_start_abstime    Uint64_t
	Ri_proc_exit_abstime     Uint64_t
	Ri_child_user_time       Uint64_t
	Ri_child_system_time     Uint64_t
	Ri_child_pkg_idle_wkups  Uint64_t
	Ri_child_interrupt_wkups Uint64_t
	Ri_child_pageins         Uint64_t
	Ri_child_elapsed_abstime Uint64_t
} /* resource.h:215:1 */

type Srusage_info_v2 = struct {
	Ri_uuid                  [16]Uint8_t
	Ri_user_time             Uint64_t
	Ri_system_time           Uint64_t
	Ri_pkg_idle_wkups        Uint64_t
	Ri_interrupt_wkups       Uint64_t
	Ri_pageins               Uint64_t
	Ri_wired_size            Uint64_t
	Ri_resident_size         Uint64_t
	Ri_phys_footprint        Uint64_t
	Ri_proc_start_abstime    Uint64_t
	Ri_proc_exit_abstime     Uint64_t
	Ri_child_user_time       Uint64_t
	Ri_child_system_time     Uint64_t
	Ri_child_pkg_idle_wkups  Uint64_t
	Ri_child_interrupt_wkups Uint64_t
	Ri_child_pageins         Uint64_t
	Ri_child_elapsed_abstime Uint64_t
	Ri_diskio_bytesread      Uint64_t
	Ri_diskio_byteswritten   Uint64_t
} /* resource.h:235:1 */

type Srusage_info_v3 = struct {
	Ri_uuid                          [16]Uint8_t
	Ri_user_time                     Uint64_t
	Ri_system_time                   Uint64_t
	Ri_pkg_idle_wkups                Uint64_t
	Ri_interrupt_wkups               Uint64_t
	Ri_pageins                       Uint64_t
	Ri_wired_size                    Uint64_t
	Ri_resident_size                 Uint64_t
	Ri_phys_footprint                Uint64_t
	Ri_proc_start_abstime            Uint64_t
	Ri_proc_exit_abstime             Uint64_t
	Ri_child_user_time               Uint64_t
	Ri_child_system_time             Uint64_t
	Ri_child_pkg_idle_wkups          Uint64_t
	Ri_child_interrupt_wkups         Uint64_t
	Ri_child_pageins                 Uint64_t
	Ri_child_elapsed_abstime         Uint64_t
	Ri_diskio_bytesread              Uint64_t
	Ri_diskio_byteswritten           Uint64_t
	Ri_cpu_time_qos_default          Uint64_t
	Ri_cpu_time_qos_maintenance      Uint64_t
	Ri_cpu_time_qos_background       Uint64_t
	Ri_cpu_time_qos_utility          Uint64_t
	Ri_cpu_time_qos_legacy           Uint64_t
	Ri_cpu_time_qos_user_initiated   Uint64_t
	Ri_cpu_time_qos_user_interactive Uint64_t
	Ri_billed_system_time            Uint64_t
	Ri_serviced_system_time          Uint64_t
} /* resource.h:257:1 */

type Srusage_info_v4 = struct {
	Ri_uuid                          [16]Uint8_t
	Ri_user_time                     Uint64_t
	Ri_system_time                   Uint64_t
	Ri_pkg_idle_wkups                Uint64_t
	Ri_interrupt_wkups               Uint64_t
	Ri_pageins                       Uint64_t
	Ri_wired_size                    Uint64_t
	Ri_resident_size                 Uint64_t
	Ri_phys_footprint                Uint64_t
	Ri_proc_start_abstime            Uint64_t
	Ri_proc_exit_abstime             Uint64_t
	Ri_child_user_time               Uint64_t
	Ri_child_system_time             Uint64_t
	Ri_child_pkg_idle_wkups          Uint64_t
	Ri_child_interrupt_wkups         Uint64_t
	Ri_child_pageins                 Uint64_t
	Ri_child_elapsed_abstime         Uint64_t
	Ri_diskio_bytesread              Uint64_t
	Ri_diskio_byteswritten           Uint64_t
	Ri_cpu_time_qos_default          Uint64_t
	Ri_cpu_time_qos_maintenance      Uint64_t
	Ri_cpu_time_qos_background       Uint64_t
	Ri_cpu_time_qos_utility          Uint64_t
	Ri_cpu_time_qos_legacy           Uint64_t
	Ri_cpu_time_qos_user_initiated   Uint64_t
	Ri_cpu_time_qos_user_interactive Uint64_t
	Ri_billed_system_time            Uint64_t
	Ri_serviced_system_time          Uint64_t
	Ri_logical_writes                Uint64_t
	Ri_lifetime_max_phys_footprint   Uint64_t
	Ri_instructions                  Uint64_t
	Ri_cycles                        Uint64_t
	Ri_billed_energy                 Uint64_t
	Ri_serviced_energy               Uint64_t
	Ri_interval_max_phys_footprint   Uint64_t
	Ri_runnable_time                 Uint64_t
} /* resource.h:288:1 */

type Srusage_info_v5 = struct {
	Ri_uuid                          [16]Uint8_t
	Ri_user_time                     Uint64_t
	Ri_system_time                   Uint64_t
	Ri_pkg_idle_wkups                Uint64_t
	Ri_interrupt_wkups               Uint64_t
	Ri_pageins                       Uint64_t
	Ri_wired_size                    Uint64_t
	Ri_resident_size                 Uint64_t
	Ri_phys_footprint                Uint64_t
	Ri_proc_start_abstime            Uint64_t
	Ri_proc_exit_abstime             Uint64_t
	Ri_child_user_time               Uint64_t
	Ri_child_system_time             Uint64_t
	Ri_child_pkg_idle_wkups          Uint64_t
	Ri_child_interrupt_wkups         Uint64_t
	Ri_child_pageins                 Uint64_t
	Ri_child_elapsed_abstime         Uint64_t
	Ri_diskio_bytesread              Uint64_t
	Ri_diskio_byteswritten           Uint64_t
	Ri_cpu_time_qos_default          Uint64_t
	Ri_cpu_time_qos_maintenance      Uint64_t
	Ri_cpu_time_qos_background       Uint64_t
	Ri_cpu_time_qos_utility          Uint64_t
	Ri_cpu_time_qos_legacy           Uint64_t
	Ri_cpu_time_qos_user_initiated   Uint64_t
	Ri_cpu_time_qos_user_interactive Uint64_t
	Ri_billed_system_time            Uint64_t
	Ri_serviced_system_time          Uint64_t
	Ri_logical_writes                Uint64_t
	Ri_lifetime_max_phys_footprint   Uint64_t
	Ri_instructions                  Uint64_t
	Ri_cycles                        Uint64_t
	Ri_billed_energy                 Uint64_t
	Ri_serviced_energy               Uint64_t
	Ri_interval_max_phys_footprint   Uint64_t
	Ri_runnable_time                 Uint64_t
	Ri_flags                         Uint64_t
} /* resource.h:327:1 */

type Rusage_info_current = Srusage_info_v5 /* resource.h:367:31 */

// ****
//
// RESOURCE LIMITS

// Symbolic constants for resource limits; since all limits are representable
// as a type rlim_t, we are permitted to define RLIM_SAVED_* in terms of
// RLIM_INFINITY.

// Possible values of the first parameter to getrlimit()/setrlimit(), to
// indicate for which resource the operation is being performed.

// A structure representing a resource limit.  The address of an instance
// of this structure is the second parameter to getrlimit()/setrlimit().
type Srlimit = struct {
	Rlim_cur Rlim_t
	Rlim_max Rlim_t
} /* resource.h:411:1 */

// proc_rlimit_control()
//
// Resource limit flavors

// Flags for wakeups monitor control.

// Flags for CPU usage monitor control.

// Flags for memory footprint interval tracking.

type Sproc_rlimit_control_wakeupmon = struct {
	Wm_flags Uint32_t
	Wm_rate  Int32_t
} /* resource.h:446:1 */

// Deprecated:
// Structure of the information in the status word returned by wait4.
// If w_stopval==_WSTOPPED, then the second structure describes
// the information returned, else the first.
type Swait = struct{ W_status int32 } /* wait.h:194:1 */

// built-in for gcc

// built-in for gcc 3

// DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
// _GCC_SIZE_T
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Ct_rune_t = X__darwin_ct_rune_t /* _ct_rune_t.h:32:28 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Rune_t = X__darwin_rune_t /* _rune_t.h:31:25 */

type Div_t = struct {
	Quot int32
	Rem  int32
} /* stdlib.h:86:3 */

type Ldiv_t = struct {
	Quot int64
	Rem  int64
} /* stdlib.h:91:3 */

type Lldiv_t = struct {
	Quot int64
	Rem  int64
} /* stdlib.h:97:3 */

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Dev_t = X__darwin_dev_t /* _dev_t.h:31:31 */ // device number
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Mode_t = X__darwin_mode_t /* _mode_t.h:31:33 */ // getsubopt(3) external variable
// valloc is now declared in _malloc.h

// Poison the following routines if -fshort-wchar is set

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

//**************************
// Section - ABI Versioning
//**************************

// *
// The latest ABI version that is supported by the current version of the
// library. When Languages are generated by the Tree-sitter CLI, they are
// assigned an ABI version number that corresponds to the current CLI version.
// The Tree-sitter library is generally backwards-compatible with languages
// generated using older CLI versions, but is not forwards-compatible.

// *
// The earliest ABI version that is supported by the current version of the
// library.

//*****************
// Section - Types
//*****************

type TSSymbol = Uint16_t  /* api.h:36:18 */
type TSFieldId = Uint16_t /* api.h:37:18 */
type STSLanguage = struct {
	Version                   Uint32_t
	Symbol_count              Uint32_t
	Alias_count               Uint32_t
	Token_count               Uint32_t
	External_token_count      Uint32_t
	State_count               Uint32_t
	Large_state_count         Uint32_t
	Production_id_count       Uint32_t
	Field_count               Uint32_t
	Max_alias_sequence_length Uint16_t
	__ccgo_pad1               [2]byte
	Parse_table               uintptr
	Small_parse_table         uintptr
	Small_parse_table_map     uintptr
	Parse_actions             uintptr
	Symbol_names              uintptr
	Field_names               uintptr
	Field_map_slices          uintptr
	Field_map_entries         uintptr
	Symbol_metadata           uintptr
	Public_symbol_map         uintptr
	Alias_map                 uintptr
	Alias_sequences           uintptr
	Lex_modes                 uintptr
	Lex_fn                    uintptr
	Keyword_lex_fn            uintptr
	Keyword_capture_token     TSSymbol
	__ccgo_pad2               [6]byte
	External_scanner          struct {
		States      uintptr
		Symbol_map  uintptr
		Create      uintptr
		Destroy     uintptr
		Scan        uintptr
		Serialize   uintptr
		Deserialize uintptr
	}
} /* api.h:38:9 */

type TSLanguage = STSLanguage /* api.h:38:27 */
type STSParser = struct {
	Lexer                           Lexer
	Stack                           uintptr
	Tree_pool                       SubtreePool
	Language                        uintptr
	Reduce_actions                  ReduceActionSet
	Finished_tree                   Subtree
	Trailing_extras                 SubtreeArray
	Trailing_extras2                SubtreeArray
	Scratch_trees                   SubtreeArray
	Token_cache                     TokenCache
	Reusable_node                   ReusableNode
	External_scanner_payload        uintptr
	Dot_graph_file                  uintptr
	End_clock                       TSClock
	Timeout_duration                TSDuration
	Accept_count                    uint32
	Operation_count                 uint32
	Cancellation_flag               uintptr
	Old_tree                        Subtree
	Included_range_differences      TSRangeArray
	Included_range_difference_index uint32
	__ccgo_pad1                     [4]byte
} /* api.h:39:9 */

type STSTree = struct {
	Root                 Subtree
	Language             uintptr
	Included_ranges      uintptr
	Included_range_count uint32
	__ccgo_pad1          [4]byte
} /* api.h:40:9 */

type STSQuery = struct {
	Captures         SymbolTable
	Predicate_values SymbolTable
	Steps            struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Pattern_map struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Predicate_steps struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Patterns struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Step_offsets struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Negated_fields struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	String_buffer struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Language                    uintptr
	Wildcard_root_pattern_count Uint16_t
	__ccgo_pad1                 [6]byte
} /* api.h:41:9 */

type STSQueryCursor = struct {
	Query  uintptr
	Cursor TSTreeCursor
	States struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Finished_states struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Capture_list_pool      CaptureListPool
	Depth                  Uint32_t
	Start_byte             Uint32_t
	End_byte               Uint32_t
	Start_point            TSPoint
	End_point              TSPoint
	Next_state_id          Uint32_t
	Ascending              uint8
	Halted                 uint8
	Did_exceed_match_limit uint8
	__ccgo_pad1            [5]byte
} /* api.h:42:9 */

type TSInputEncoding = uint32 /* api.h:47:3 */

type TSSymbolType = uint32 /* api.h:53:3 */

type TSPoint = struct {
	Row    Uint32_t
	Column Uint32_t
} /* api.h:58:3 */

type TSRange = struct {
	Start_point TSPoint
	End_point   TSPoint
	Start_byte  Uint32_t
	End_byte    Uint32_t
} /* api.h:65:3 */

type TSInput = struct {
	Payload     uintptr
	Read        uintptr
	Encoding    TSInputEncoding
	__ccgo_pad1 [4]byte
} /* api.h:71:3 */

type TSLogType = uint32 /* api.h:76:3 */

type TSLogger = struct {
	Payload uintptr
	Log     uintptr
} /* api.h:81:3 */

type TSInputEdit = struct {
	Start_byte    Uint32_t
	Old_end_byte  Uint32_t
	New_end_byte  Uint32_t
	Start_point   TSPoint
	Old_end_point TSPoint
	New_end_point TSPoint
} /* api.h:90:3 */

type TSNode = struct {
	Context [4]Uint32_t
	Id      uintptr
	Tree    uintptr
} /* api.h:96:3 */

type TSTreeCursor = struct {
	Tree    uintptr
	Id      uintptr
	Context [2]Uint32_t
} /* api.h:102:3 */

type TSQueryCapture = struct {
	Node        TSNode
	Index       Uint32_t
	__ccgo_pad1 [4]byte
} /* api.h:107:3 */

type TSQueryMatch = struct {
	Id            Uint32_t
	Pattern_index Uint16_t
	Capture_count Uint16_t
	Captures      uintptr
} /* api.h:114:3 */

type TSQueryPredicateStepType = uint32 /* api.h:120:3 */

type TSQueryPredicateStep = struct {
	Type     TSQueryPredicateStepType
	Value_id Uint32_t
} /* api.h:125:3 */

type TSQueryError = uint32 /* api.h:134:3 */

func point__new(tls *libc.TLS, row uint32, column uint32) TSPoint { /* point.h:9:23: */
	var result = TSPoint{Row: row, Column: column}
	return result
}

func point_add(tls *libc.TLS, a TSPoint, b TSPoint) TSPoint { /* point.h:14:23: */
	if b.Row > Uint32_t(0) {
		return point__new(tls, (a.Row + b.Row), b.Column)
	} else {
		return point__new(tls, a.Row, (a.Column + b.Column))
	}
	return TSPoint{}
}

func point_sub(tls *libc.TLS, a TSPoint, b TSPoint) TSPoint { /* point.h:21:23: */
	if a.Row > b.Row {
		return point__new(tls, (a.Row - b.Row), a.Column)
	} else {
		return point__new(tls, uint32(0), (a.Column - b.Column))
	}
	return TSPoint{}
}

func point_lte(tls *libc.TLS, a TSPoint, b TSPoint) uint8 { /* point.h:28:20: */
	return (uint8(libc.Bool32((a.Row < b.Row) || ((a.Row == b.Row) && (a.Column <= b.Column)))))
}

func point_lt(tls *libc.TLS, a TSPoint, b TSPoint) uint8 { /* point.h:32:20: */
	return (uint8(libc.Bool32((a.Row < b.Row) || ((a.Row == b.Row) && (a.Column < b.Column)))))
}

func point_gt(tls *libc.TLS, a TSPoint, b TSPoint) uint8 { /* point.h:36:20: */
	return (uint8(libc.Bool32((a.Row > b.Row) || ((a.Row == b.Row) && (a.Column > b.Column)))))
}

type Length = struct {
	Bytes  Uint32_t
	Extent TSPoint
}                                                                                                 /* length.h:12:3 */
var sLENGTH_MAX = Length{Bytes: UINT32_MAX, Extent: TSPoint{Row: UINT32_MAX, Column: UINT32_MAX}} /* length.h:15:21 */

func length_is_undefined(tls *libc.TLS, length Length) uint8 { /* length.h:17:20: */
	return (uint8(libc.Bool32((length.Bytes == Uint32_t(0)) && (length.Extent.Column != Uint32_t(0)))))
}

func length_min(tls *libc.TLS, len1 Length, len2 Length) Length { /* length.h:21:22: */
	if len1.Bytes < len2.Bytes {
		return len1
	}
	return len2
}

func length_add(tls *libc.TLS, len1 Length, len2 Length) Length { /* length.h:25:22: */
	var result Length
	result.Bytes = (len1.Bytes + len2.Bytes)
	result.Extent = point_add(tls, len1.Extent, len2.Extent)
	return result
}

func length_sub(tls *libc.TLS, len1 Length, len2 Length) Length { /* length.h:32:22: */
	var result Length
	result.Bytes = (len1.Bytes - len2.Bytes)
	result.Extent = point_sub(tls, len1.Extent, len2.Extent)
	return result
}

func length_zero(tls *libc.TLS) Length { /* length.h:39:22: */
	var result = Length{}
	return result
}

// C11 Annex K

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Rsize_t = X__darwin_size_t /* _rsize_t.h:31:32 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Errno_t = int32 /* _errno_t.h:30:32 */

// 8462256: modified __assert_rtn() replaces deprecated __eprintf()

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Allow clients to override allocation functions

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

func ts_toggle_allocation_recording(tls *libc.TLS, value uint8) uint8 { /* alloc.h:44:20: */
	_ = value
	return uint8(False)
}

func ts_malloc_default(tls *libc.TLS, size Size_t) uintptr { /* alloc.h:50:20: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var result uintptr = libc.Xmalloc(tls, size)
	if (size > uint64(0)) && !(result != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, ts /* "tree-sitter fail..." */, libc.VaList(bp, size))
		libc.Xexit(tls, 1)
	}
	return result
}

func ts_calloc_default(tls *libc.TLS, count Size_t, size Size_t) uintptr { /* alloc.h:59:20: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var result uintptr = libc.Xcalloc(tls, count, size)
	if (count > uint64(0)) && !(result != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, ts /* "tree-sitter fail..." */, libc.VaList(bp, (count*size)))
		libc.Xexit(tls, 1)
	}
	return result
}

func ts_realloc_default(tls *libc.TLS, buffer uintptr, size Size_t) uintptr { /* alloc.h:68:20: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var result uintptr = libc.Xrealloc(tls, buffer, size)
	if (size > uint64(0)) && !(result != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, ts+41 /* "tree-sitter fail..." */, libc.VaList(bp, size))
		libc.Xexit(tls, 1)
	}
	return result
}

func ts_free_default(tls *libc.TLS, buffer uintptr) { /* alloc.h:77:20: */
	libc.Xfree(tls, buffer)
}

// Free any memory allocated for this array.

// Increase the array's size by a given number of elements, reallocating
// if necessary. New elements are zero-initialized.

// Append `count` elements to the end of the array, reading their values from the
// `contents` pointer.

// Remove `old_count` elements from the array starting at the given `index`. At
// the same index, insert `new_count` new elements, reading their values from the
// `new_contents` pointer.

// Insert one `element` into the array at the given `index`.

// Remove one `element` from the array at the given `index`.

// Search a sorted array for a given `needle` value, using the given `compare`
// callback to determine the order.
//
// If an existing element is found to be equal to `needle`, then the `index`
// out-parameter is set to the existing value's index, and the `exists`
// out-parameter is set to true. Otherwise, `index` is set to an index where
// `needle` should be inserted in order to preserve the sorting, and `exists`
// is set to false.

// Search a sorted array for a given `needle` value, using integer comparisons
// of a given struct field (specified with a leading dot) to determine the order.
//
// See also `array_search_sorted_with`.

// Insert a given `value` into a sorted array, using the given `compare`
// callback to determine the order.

// Insert a given `value` into a sorted array, using integer comparisons of
// a given struct field (specified with a leading dot) to determine the order.
//
// See also `array_search_sorted_by`.

// Private

type VoidArray = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* array.h:130:21 */

func array__delete(tls *libc.TLS, self uintptr) { /* array.h:134:20: */
	ts_free_default(tls, (*VoidArray)(unsafe.Pointer(self)).Contents)
	(*VoidArray)(unsafe.Pointer(self)).Contents = uintptr(0)
	(*VoidArray)(unsafe.Pointer(self)).Size = Uint32_t(0)
	(*VoidArray)(unsafe.Pointer(self)).Capacity = Uint32_t(0)
}

func array__erase(tls *libc.TLS, self uintptr, element_size Size_t, index Uint32_t) { /* array.h:141:20: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(index < (*VoidArray)(unsafe.Pointer(self)).Size)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__114)), ts+84 /* "upstream/tree-si..." */, 143, ts+121 /* "index < self->si..." */)
	} else {
	}
	var contents uintptr = (*VoidArray)(unsafe.Pointer(self)).Contents
	libc.X__builtin___memmove_chk(tls, (contents + uintptr((Size_t(index) * element_size))), (contents + uintptr(((Size_t(index + Uint32_t(1))) * element_size))), ((Size_t(((*VoidArray)(unsafe.Pointer(self)).Size - index) - Uint32_t(1))) * element_size), libc.X__builtin_object_size(tls, (contents+uintptr((Size_t(index)*element_size))), 0))
	(*VoidArray)(unsafe.Pointer(self)).Size--
}

var __func__114 = *(*[13]int8)(unsafe.Pointer(ts + 140 /* "array__erase" */)) /* array.h:142:49 */

func array__reserve(tls *libc.TLS, self uintptr, element_size Size_t, new_capacity Uint32_t) { /* array.h:150:20: */
	if new_capacity > (*VoidArray)(unsafe.Pointer(self)).Capacity {
		if (*VoidArray)(unsafe.Pointer(self)).Contents != 0 {
			(*VoidArray)(unsafe.Pointer(self)).Contents = ts_realloc_default(tls, (*VoidArray)(unsafe.Pointer(self)).Contents, (Size_t(new_capacity) * element_size))
		} else {
			(*VoidArray)(unsafe.Pointer(self)).Contents = ts_malloc_default(tls, (Size_t(new_capacity) * element_size))
		}
		(*VoidArray)(unsafe.Pointer(self)).Capacity = new_capacity
	}
}

func array__assign(tls *libc.TLS, self uintptr, other uintptr, element_size Size_t) { /* array.h:161:20: */
	array__reserve(tls, self, element_size, (*VoidArray)(unsafe.Pointer(other)).Size)
	(*VoidArray)(unsafe.Pointer(self)).Size = (*VoidArray)(unsafe.Pointer(other)).Size
	libc.X__builtin___memcpy_chk(tls, (*VoidArray)(unsafe.Pointer(self)).Contents, (*VoidArray)(unsafe.Pointer(other)).Contents, (Size_t((*VoidArray)(unsafe.Pointer(self)).Size) * element_size), libc.X__builtin_object_size(tls, (*VoidArray)(unsafe.Pointer(self)).Contents, 0))
}

func array__swap(tls *libc.TLS, self uintptr, other uintptr) { /* array.h:167:20: */
	var swap = *(*VoidArray)(unsafe.Pointer(other))
	*(*VoidArray)(unsafe.Pointer(other)) = *(*VoidArray)(unsafe.Pointer(self))
	*(*VoidArray)(unsafe.Pointer(self)) = swap
}

func array__grow(tls *libc.TLS, self uintptr, count Size_t, element_size Size_t) { /* array.h:173:20: */
	var new_size Size_t = (Size_t((*VoidArray)(unsafe.Pointer(self)).Size) + count)
	if new_size > Size_t((*VoidArray)(unsafe.Pointer(self)).Capacity) {
		var new_capacity Size_t = (Size_t((*VoidArray)(unsafe.Pointer(self)).Capacity * Uint32_t(2)))
		if new_capacity < uint64(8) {
			new_capacity = uint64(8)
		}
		if new_capacity < new_size {
			new_capacity = new_size
		}
		array__reserve(tls, self, element_size, uint32(new_capacity))
	}
}

func array__splice(tls *libc.TLS, self uintptr, element_size Size_t, index Uint32_t, old_count Uint32_t, new_count Uint32_t, elements uintptr) { /* array.h:183:20: */
	var new_size Uint32_t = (((*VoidArray)(unsafe.Pointer(self)).Size + new_count) - old_count)
	var old_end Uint32_t = (index + old_count)
	var new_end Uint32_t = (index + new_count)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(old_end <= (*VoidArray)(unsafe.Pointer(self)).Size)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__115)), ts+84 /* "upstream/tree-si..." */, 189, ts+153 /* "old_end <= self-..." */)
	} else {
	}

	array__reserve(tls, self, element_size, new_size)

	var contents uintptr = (*VoidArray)(unsafe.Pointer(self)).Contents
	if (*VoidArray)(unsafe.Pointer(self)).Size > old_end {
		libc.X__builtin___memmove_chk(tls, (contents + uintptr((Size_t(new_end) * element_size))), (contents + uintptr((Size_t(old_end) * element_size))), ((Size_t((*VoidArray)(unsafe.Pointer(self)).Size - old_end)) * element_size), libc.X__builtin_object_size(tls, (contents+uintptr((Size_t(new_end)*element_size))), 0))
	}
	if new_count > Uint32_t(0) {
		if elements != 0 {
			libc.X__builtin___memcpy_chk(tls, (contents + uintptr((Size_t(index) * element_size))), elements, (Size_t(new_count) * element_size), libc.X__builtin_object_size(tls, (contents+uintptr((Size_t(index)*element_size))), 0))
		} else {
			libc.X__builtin___memset_chk(tls, (contents + uintptr((Size_t(index) * element_size))), 0, (Size_t(new_count) * element_size), libc.X__builtin_object_size(tls, (contents+uintptr((Size_t(index)*element_size))), 0))
		}
	}
	*(*Uint32_t)(unsafe.Pointer(self + 8 /* &.size */)) += (new_count - old_count)
}

var __func__115 = *(*[14]int8)(unsafe.Pointer(ts + 175 /* "array__splice" */)) /* array.h:185:76 */

// A binary search routine, based on Rust's `std::slice::binary_search_by`.

// Helper macro for the `_sorted_by` routines below. This takes the left (existing)
// parameter by reference in order to work with the generic sorting function above.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

type TSStateId = Uint16_t /* parser.h:16:18 */

type TSFieldMapEntry = struct {
	Field_id    TSFieldId
	Child_index Uint8_t
	Inherited   uint8
} /* parser.h:28:3 */

type TSFieldMapSlice = struct {
	Index  Uint16_t
	Length Uint16_t
} /* parser.h:33:3 */

type TSSymbolMetadata = struct {
	Visible   uint8
	Named     uint8
	Supertype uint8
} /* parser.h:39:3 */

type STSLexer = struct {
	Lookahead                  Int32_t
	Result_symbol              TSSymbol
	__ccgo_pad1                [2]byte
	Advance                    uintptr
	Mark_end                   uintptr
	Get_column                 uintptr
	Is_at_included_range_start uintptr
	Eof                        uintptr
} /* parser.h:41:9 */

type TSLexer = STSLexer /* parser.h:41:24 */

type TSParseActionType = uint32 /* parser.h:58:3 */

type TSParseAction = struct {
	Shift struct {
		Type        Uint8_t
		__ccgo_pad1 [1]byte
		State       TSStateId
		Extra       uint8
		Repetition  uint8
	}
	_ [2]byte
} /* parser.h:75:3 */

type TSLexMode = struct {
	Lex_state          Uint16_t
	External_lex_state Uint16_t
} /* parser.h:80:3 */

type TSParseActionEntry = struct{ Action TSParseAction } /* parser.h:88:3 */

//  Lexer Macros

//  Parse Table Macros

// The serialized state of an external scanner.
//
// Every time an external token subtree is created after a call to an
// external scanner, the scanner's `serialize` function is called to
// retrieve a serialized copy of its state. The bytes are then copied
// onto the subtree itself so that the scanner's state can later be
// restored using its `deserialize` function.
//
// Small byte arrays are stored inline, and long ones are allocated
// separately on the heap.
type ExternalScannerState = struct {
	X__0 struct {
		Long_data uintptr
		_         [16]byte
	}
	Length      Uint32_t
	__ccgo_pad1 [4]byte
} /* subtree.h:36:3 */

// A compact representation of a subtree.
//
// This representation is used for small leaf nodes that are not
// errors, and were not created by an external scanner.
type SubtreeInlineData = struct {
	Is_inline       uint8 /* _Bool is_inline: 1, _Bool visible: 1, _Bool named: 1, _Bool extra: 1, _Bool has_changes: 1, _Bool is_missing: 1, _Bool is_keyword: 1 */
	__ccgo_pad1     [1]byte
	Symbol          Uint8_t
	Padding_bytes   Uint8_t
	Size_bytes      Uint8_t
	Padding_columns Uint8_t
	Padding_rows    uint8 /* uint8_t padding_rows: 4, uint8_t lookahead_bytes: 4 */
	__ccgo_pad2     [1]byte
	Parse_state     Uint16_t
} /* subtree.h:57:3 */

// A heap-allocated representation of a subtree.
//
// This representation is used for parent nodes, external tokens,
// errors, and other leaf nodes whose data is too large to fit into
// the inlinen representation.
type SubtreeHeapData = struct {
	Ref_count       Uint32_t
	Padding         Length
	Size            Length
	Lookahead_bytes Uint32_t
	Error_cost      Uint32_t
	Child_count     Uint32_t
	Symbol          TSSymbol
	Parse_state     TSStateId
	Visible         uint8 /* _Bool visible: 1, _Bool named: 1, _Bool extra: 1, _Bool fragile_left: 1, _Bool fragile_right: 1, _Bool has_changes: 1, _Bool has_external_tokens: 1, _Bool depends_on_column: 1 */
	Is_missing      uint8 /* _Bool is_missing: 1, _Bool is_keyword: 1 */
	__ccgo_pad1     [2]byte
	X__48           struct {
		_    [0]uint64
		X__0 struct {
			Visible_child_count Uint32_t
			Named_child_count   Uint32_t
			Node_count          Uint32_t
			Repeat_depth        Uint32_t
			Dynamic_precedence  Int32_t
			Production_id       Uint16_t
			First_leaf          struct {
				Symbol      TSSymbol
				Parse_state TSStateId
			}
			__ccgo_pad1 [2]byte
		}
		_ [4]byte
	}
} /* subtree.h:106:3 */

// The fundamental building block of a syntax tree.
type Subtree = struct {
	_    [0]uint64
	Data SubtreeInlineData
	_    [6]byte
} /* subtree.h:112:3 */

// Like Subtree, but mutable.
type MutableSubtree = struct {
	_    [0]uint64
	Data SubtreeInlineData
	_    [6]byte
} /* subtree.h:118:3 */

type SubtreeArray = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* subtree.h:120:24 */
type MutableSubtreeArray = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* subtree.h:121:31 */

type SubtreePool = struct {
	Free_trees MutableSubtreeArray
	Tree_stack MutableSubtreeArray
} /* subtree.h:126:3 */

func ts_subtree_symbol(tls *libc.TLS, self Subtree) TSSymbol { /* subtree.h:167:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint16 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return uint16((*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Symbol)
		}
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol
	}()
}

func ts_subtree_visible(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:168:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint8 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.visible */)) & 0x2 >> 1)))
		}
		return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.visible */)) & 0x1 >> 0)))
	}()
}

func ts_subtree_named(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:169:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint8 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.named */)) & 0x4 >> 2)))
		}
		return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.named */)) & 0x2 >> 1)))
	}()
}

func ts_subtree_extra(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:170:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint8 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.extra */)) & 0x8 >> 3)))
		}
		return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.extra */)) & 0x4 >> 2)))
	}()
}

func ts_subtree_has_changes(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:171:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint8 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.has_changes */)) & 0x10 >> 4)))
		}
		return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.has_changes */)) & 0x20 >> 5)))
	}()
}

func ts_subtree_missing(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:172:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint8 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_missing */)) & 0x20 >> 5)))
		}
		return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 45 /* &.is_missing */)) & 0x1 >> 0)))
	}()
}

func ts_subtree_is_keyword(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:173:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint8 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_keyword */)) & 0x40 >> 6)))
		}
		return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 45 /* &.is_keyword */)) & 0x2 >> 1)))
	}()
}

func ts_subtree_parse_state(tls *libc.TLS, self Subtree) TSStateId { /* subtree.h:174:25: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint16 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Parse_state
		}
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Parse_state
	}()
}

func ts_subtree_lookahead_bytes(tls *libc.TLS, self Subtree) Uint32_t { /* subtree.h:175:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	return func() uint32 {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return (uint32(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ + 6 /* &.lookahead_bytes */)) & 0xf0 >> 4)))
		}
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Lookahead_bytes
	}()
}

// Get the size needed to store a heap-allocated subtree with the given
// number of children.
func ts_subtree_alloc_size(tls *libc.TLS, child_count Uint32_t) Size_t { /* subtree.h:181:22: */
	return ((uint64(child_count) * uint64(unsafe.Sizeof(Subtree{}))) + uint64(unsafe.Sizeof(SubtreeHeapData{})))
}

// Get a subtree's children, which are allocated immediately before the
// tree's own heap data.

func ts_subtree_set_extra(tls *libc.TLS, self uintptr) { /* subtree.h:190:20: */
	if (uint8(int32(*(*uint8)(unsafe.Pointer(self /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		libc.SetBitFieldPtr8Uint8(self /* &.data */ /* &.extra */, uint8(True), 3, 0x8)
	} else {
		libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(self /* .Ptr */))+44 /* &.extra */, uint8(True), 2, 0x4)
	}
}

func ts_subtree_leaf_symbol(tls *libc.TLS, self Subtree) TSSymbol { /* subtree.h:198:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return TSSymbol((*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Symbol)
	}
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count == Uint32_t(0) {
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol
	}
	return *(*TSSymbol)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 70 /* &.first_leaf */ /* &.symbol */))
}

func ts_subtree_leaf_parse_state(tls *libc.TLS, self Subtree) TSStateId { /* subtree.h:204:25: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return (*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Parse_state
	}
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count == Uint32_t(0) {
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Parse_state
	}
	return *(*TSStateId)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 70 /* &.first_leaf */ + 2 /* &.parse_state */))
}

func ts_subtree_padding(tls *libc.TLS, self Subtree) Length { /* subtree.h:210:22: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		var result = Length{Bytes: Uint32_t((*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Padding_bytes), Extent: TSPoint{Row: (Uint32_t(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ + 6 /* &.padding_rows */)) & 0xf >> 0))), Column: Uint32_t((*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Padding_columns)}}
		return result
	} else {
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Padding
	}
	return Length{}
}

func ts_subtree_size(tls *libc.TLS, self Subtree) Length { /* subtree.h:219:22: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		var result = Length{Bytes: Uint32_t((*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Size_bytes), Extent: TSPoint{Column: Uint32_t((*SubtreeInlineData)(unsafe.Pointer(bp /* &self */)).Size_bytes)}}
		return result
	} else {
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size
	}
	return Length{}
}

func ts_subtree_total_size(tls *libc.TLS, self Subtree) Length { /* subtree.h:228:22: */
	return length_add(tls, ts_subtree_padding(tls, self), ts_subtree_size(tls, self))
}

func ts_subtree_total_bytes(tls *libc.TLS, self Subtree) Uint32_t { /* subtree.h:232:24: */
	return ts_subtree_total_size(tls, self).Bytes
}

func ts_subtree_child_count(tls *libc.TLS, self Subtree) Uint32_t { /* subtree.h:236:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return uint32(0)
	}
	return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count
}

func ts_subtree_repeat_depth(tls *libc.TLS, self Subtree) Uint32_t { /* subtree.h:240:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return uint32(0)
	}
	return *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 60))
}

func ts_subtree_node_count(tls *libc.TLS, self Subtree) Uint32_t { /* subtree.h:244:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if ((uint8(int32(*(*uint8)(unsafe.Pointer((bp /* &self */ /* &.data */) /* &.is_inline */)) & 0x1 >> 0))) != 0) || ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count == Uint32_t(0)) {
		return uint32(1)
	}
	return *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 56))
}

func ts_subtree_visible_child_count(tls *libc.TLS, self Subtree) Uint32_t { /* subtree.h:248:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* self */))) > Uint32_t(0) {
		return *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48))
	} else {
		return Uint32_t(0)
	}
	return Uint32_t(0)
}

func ts_subtree_error_cost(tls *libc.TLS, self Subtree) Uint32_t { /* subtree.h:256:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if ts_subtree_missing(tls, *(*Subtree)(unsafe.Pointer(bp /* self */))) != 0 {
		return (Uint32_t(ERROR_COST_PER_MISSING_TREE + ERROR_COST_PER_RECOVERY))
	} else {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return uint32(0)
		}
		return (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Error_cost
	}
	return Uint32_t(0)
}

func ts_subtree_dynamic_precedence(tls *libc.TLS, self Subtree) Int32_t { /* subtree.h:264:23: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if ((uint8(int32(*(*uint8)(unsafe.Pointer((bp /* &self */ /* &.data */) /* &.is_inline */)) & 0x1 >> 0))) != 0) || ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count == Uint32_t(0)) {
		return 0
	}
	return *(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 64))
}

func ts_subtree_production_id(tls *libc.TLS, self Subtree) Uint16_t { /* subtree.h:268:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* self */))) > Uint32_t(0) {
		return *(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 68))
	} else {
		return Uint16_t(0)
	}
	return Uint16_t(0)
}

func ts_subtree_fragile_left(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:276:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return uint8(False)
	}
	return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.fragile_left */)) & 0x8 >> 3)))
}

func ts_subtree_fragile_right(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:280:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return uint8(False)
	}
	return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.fragile_right */)) & 0x10 >> 4)))
}

func ts_subtree_has_external_tokens(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:284:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return uint8(False)
	}
	return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.has_external_tokens */)) & 0x40 >> 6)))
}

func ts_subtree_depends_on_column(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:288:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return uint8(False)
	}
	return (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.depends_on_column */)) & 0x80 >> 7)))
}

func ts_subtree_is_fragile(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:292:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return uint8(False)
	}
	return (uint8(libc.Bool32(((uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.fragile_left */)) & 0x8 >> 3))) != 0) || ((uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.fragile_right */)) & 0x10 >> 4))) != 0))))
}

func ts_subtree_is_error(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:296:20: */
	return (uint8(libc.Bool32(int32(ts_subtree_symbol(tls, self)) == (int32(libc.Uint16FromInt32(-1))))))
}

func ts_subtree_is_eof(tls *libc.TLS, self Subtree) uint8 { /* subtree.h:300:20: */
	return (uint8(libc.Bool32(int32(ts_subtree_symbol(tls, self)) == Ts_builtin_sym_end)))
}

func ts_subtree_from_mut(tls *libc.TLS, self MutableSubtree) Subtree { /* subtree.h:304:23: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*MutableSubtree)(unsafe.Pointer(bp + 16)) = self

	// var result Subtree at bp, 16

	*(*SubtreeInlineData)(unsafe.Pointer(bp /* &result */)) = *(*SubtreeInlineData)(unsafe.Pointer(bp + 16 /* &self */))
	return *(*Subtree)(unsafe.Pointer(bp /* result */))
}

func ts_subtree_to_mut_unsafe(tls *libc.TLS, self Subtree) MutableSubtree { /* subtree.h:310:30: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*Subtree)(unsafe.Pointer(bp + 16)) = self

	// var result MutableSubtree at bp, 16

	*(*SubtreeInlineData)(unsafe.Pointer(bp /* &result */)) = *(*SubtreeInlineData)(unsafe.Pointer(bp + 16 /* &self */))
	return *(*MutableSubtree)(unsafe.Pointer(bp /* result */))
}

type TreeCursorEntry = struct {
	Subtree                uintptr
	Position               Length
	Child_index            Uint32_t
	Structural_child_index Uint32_t
	__ccgo_pad1            [4]byte
} /* tree_cursor.h:11:3 */

type TreeCursor = struct {
	Tree  uintptr
	Stack struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
} /* tree_cursor.h:16:3 */

type TSRangeArray = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* get_changed_ranges.h:11:24 */

type TableEntry = struct {
	Actions      uintptr
	Action_count Uint32_t
	Is_reusable  uint8
	__ccgo_pad1  [3]byte
} /* language.h:17:3 */

type LookaheadIterator = struct {
	Language       uintptr
	Data           uintptr
	Group_end      uintptr
	State          TSStateId
	Table_value    Uint16_t
	Section_index  Uint16_t
	Group_count    Uint16_t
	Is_small_state uint8
	__ccgo_pad1    [7]byte
	Actions        uintptr
	Symbol         TSSymbol
	Next_state     TSStateId
	Action_count   Uint16_t
	__ccgo_pad2    [2]byte
} /* language.h:33:3 */

func ts_language_actions(tls *libc.TLS, self uintptr, state TSStateId, symbol TSSymbol, count uintptr) uintptr { /* language.h:45:35: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var entry TableEntry at bp, 16

	Xts_language_table_entry(tls, self, state, symbol, bp /* &entry */)
	*(*Uint32_t)(unsafe.Pointer(count)) = (*TableEntry)(unsafe.Pointer(bp /* &entry */)).Action_count
	return (*TableEntry)(unsafe.Pointer(bp /* &entry */)).Actions
}

func ts_language_has_reduce_action(tls *libc.TLS, self uintptr, state TSStateId, symbol TSSymbol) uint8 { /* language.h:57:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var entry TableEntry at bp, 16

	Xts_language_table_entry(tls, self, state, symbol, bp /* &entry */)
	return (uint8(libc.Bool32(((*TableEntry)(unsafe.Pointer(bp /* &entry */)).Action_count > Uint32_t(0)) && (int32(*(*Uint8_t)(unsafe.Pointer((*TableEntry)(unsafe.Pointer(bp /* &entry */)).Actions))) == TSParseActionTypeReduce))))
}

// Lookup the table value for a given symbol and state.
//
// For non-terminal symbols, the table value represents a successor state.
// For terminal symbols, it represents an index in the actions table.
// For 'large' parse states, this is a direct lookup. For 'small' parse
// states, this requires searching through the symbol groups to find
// the given symbol.
func ts_language_lookup(tls *libc.TLS, self uintptr, state TSStateId, symbol TSSymbol) Uint16_t { /* language.h:74:24: */
	if Uint32_t(state) >= (*TSLanguage)(unsafe.Pointer(self)).Large_state_count {
		var index Uint32_t = *(*Uint32_t)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Small_parse_table_map + uintptr((Uint32_t(state)-(*TSLanguage)(unsafe.Pointer(self)).Large_state_count))*4))
		var data uintptr = ((*TSLanguage)(unsafe.Pointer(self)).Small_parse_table + uintptr(index)*2)
		var group_count Uint16_t = *(*Uint16_t)(unsafe.Pointer(libc.PostIncUintptr(&data, 2)))
		{
			var i uint32 = uint32(0)
		__1:
			if !(i < uint32(group_count)) {
				goto __3
			}
			{
				var section_value Uint16_t = *(*Uint16_t)(unsafe.Pointer(libc.PostIncUintptr(&data, 2)))
				var symbol_count Uint16_t = *(*Uint16_t)(unsafe.Pointer(libc.PostIncUintptr(&data, 2)))
				{
					var i uint32 = uint32(0)
				__4:
					if !(i < uint32(symbol_count)) {
						goto __6
					}
					{
						if int32(*(*Uint16_t)(unsafe.Pointer(libc.PostIncUintptr(&data, 2)))) == int32(symbol) {
							return section_value
						}

					}
					goto __5
				__5:
					i++
					goto __4
					goto __6
				__6:
					;
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
		return Uint16_t(0)
	} else {
		return *(*Uint16_t)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Parse_table + uintptr(((Uint32_t(state)*(*TSLanguage)(unsafe.Pointer(self)).Symbol_count)+Uint32_t(symbol)))*2))
	}
	return Uint16_t(0)
}

func ts_language_has_actions(tls *libc.TLS, self uintptr, state TSStateId, symbol TSSymbol) uint8 { /* language.h:96:20: */
	return (uint8(libc.Bool32(int32(ts_language_lookup(tls, self, state, symbol)) != 0)))
}

// Iterate over all of the symbols that are valid in the given state.
//
// For 'large' parse states, this just requires iterating through
// all possible symbols and checking the parse table for each one.
// For 'small' parse states, this exploits the structure of the
// table to only visit the valid symbols.
func ts_language_lookaheads(tls *libc.TLS, self uintptr, state TSStateId) LookaheadIterator { /* language.h:110:33: */
	var is_small_state uint8 = (uint8(libc.Bool32(Uint32_t(state) >= (*TSLanguage)(unsafe.Pointer(self)).Large_state_count)))
	var data uintptr
	var group_end uintptr = uintptr(0)
	var group_count Uint16_t = Uint16_t(0)
	if is_small_state != 0 {
		var index Uint32_t = *(*Uint32_t)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Small_parse_table_map + uintptr((Uint32_t(state)-(*TSLanguage)(unsafe.Pointer(self)).Large_state_count))*4))
		data = ((*TSLanguage)(unsafe.Pointer(self)).Small_parse_table + uintptr(index)*2)
		group_end = (data + uintptr(1)*2)
		group_count = *(*Uint16_t)(unsafe.Pointer(data))
	} else {
		data = (((*TSLanguage)(unsafe.Pointer(self)).Parse_table + uintptr((Uint32_t(state)*(*TSLanguage)(unsafe.Pointer(self)).Symbol_count))*2) - uintptr(1)*2)
	}
	return LookaheadIterator{Language: self, Data: data, Group_end: group_end, Group_count: group_count, Is_small_state: is_small_state, Symbol: TSSymbol(UINT16_MAX)}
}

func ts_lookahead_iterator_next(tls *libc.TLS, self uintptr) uint8 { /* language.h:137:20: */
	// For small parse states, valid symbols are listed explicitly,
	// grouped by their value. There's no need to look up the actions
	// again until moving to the next group.
	if (*LookaheadIterator)(unsafe.Pointer(self)).Is_small_state != 0 {
		(*LookaheadIterator)(unsafe.Pointer(self)).Data += 2
		if (*LookaheadIterator)(unsafe.Pointer(self)).Data == (*LookaheadIterator)(unsafe.Pointer(self)).Group_end {
			if int32((*LookaheadIterator)(unsafe.Pointer(self)).Group_count) == 0 {
				return uint8(False)
			}
			(*LookaheadIterator)(unsafe.Pointer(self)).Group_count--
			(*LookaheadIterator)(unsafe.Pointer(self)).Table_value = *(*Uint16_t)(unsafe.Pointer(libc.PostIncUintptr(&(*LookaheadIterator)(unsafe.Pointer(self)).Data, 2)))
			var symbol_count uint32 = uint32(*(*Uint16_t)(unsafe.Pointer(libc.PostIncUintptr(&(*LookaheadIterator)(unsafe.Pointer(self)).Data, 2))))
			(*LookaheadIterator)(unsafe.Pointer(self)).Group_end = ((*LookaheadIterator)(unsafe.Pointer(self)).Data + uintptr(symbol_count)*2)
			(*LookaheadIterator)(unsafe.Pointer(self)).Symbol = *(*Uint16_t)(unsafe.Pointer((*LookaheadIterator)(unsafe.Pointer(self)).Data))
		} else {
			(*LookaheadIterator)(unsafe.Pointer(self)).Symbol = *(*Uint16_t)(unsafe.Pointer((*LookaheadIterator)(unsafe.Pointer(self)).Data))
			return uint8(True)
		}
	} else {
		for ok := true; ok; ok = !(int32((*LookaheadIterator)(unsafe.Pointer(self)).Table_value) != 0) {
			(*LookaheadIterator)(unsafe.Pointer(self)).Data += 2
			(*LookaheadIterator)(unsafe.Pointer(self)).Symbol++
			if Uint32_t((*LookaheadIterator)(unsafe.Pointer(self)).Symbol) >= (*TSLanguage)(unsafe.Pointer((*LookaheadIterator)(unsafe.Pointer(self)).Language)).Symbol_count {
				return uint8(False)
			}
			(*LookaheadIterator)(unsafe.Pointer(self)).Table_value = *(*Uint16_t)(unsafe.Pointer((*LookaheadIterator)(unsafe.Pointer(self)).Data))
		}
	}

	// Depending on if the symbols is terminal or non-terminal, the table value either
	// represents a list of actions or a successor state.
	if Uint32_t((*LookaheadIterator)(unsafe.Pointer(self)).Symbol) < (*TSLanguage)(unsafe.Pointer((*LookaheadIterator)(unsafe.Pointer(self)).Language)).Token_count {
		var entry uintptr = ((*TSLanguage)(unsafe.Pointer((*LookaheadIterator)(unsafe.Pointer(self)).Language)).Parse_actions + uintptr((*LookaheadIterator)(unsafe.Pointer(self)).Table_value)*8)
		(*LookaheadIterator)(unsafe.Pointer(self)).Action_count = Uint16_t(*(*Uint8_t)(unsafe.Pointer(entry /* &.entry */ /* &.count */)))
		(*LookaheadIterator)(unsafe.Pointer(self)).Actions = (entry + uintptr(1)*8)
		(*LookaheadIterator)(unsafe.Pointer(self)).Next_state = TSStateId(0)
	} else {
		(*LookaheadIterator)(unsafe.Pointer(self)).Action_count = Uint16_t(0)
		(*LookaheadIterator)(unsafe.Pointer(self)).Next_state = (*LookaheadIterator)(unsafe.Pointer(self)).Table_value
	}
	return uint8(True)
}

func ts_language_next_state(tls *libc.TLS, self uintptr, state TSStateId, symbol TSSymbol) TSStateId { /* language.h:181:25: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	if (int32(symbol) == (int32(libc.Uint16FromInt32(-1)))) || (int32(symbol) == ((int32(libc.Uint16FromInt32(-1))) - 1)) {
		return TSStateId(0)
	} else if Uint32_t(symbol) < (*TSLanguage)(unsafe.Pointer(self)).Token_count {
		// var count Uint32_t at bp, 4

		var actions uintptr = ts_language_actions(tls, self, state, symbol, bp /* &count */)
		if *(*Uint32_t)(unsafe.Pointer(bp /* count */)) > Uint32_t(0) {
			*(*TSParseAction)(unsafe.Pointer(bp + 4 /* action */)) = *(*TSParseAction)(unsafe.Pointer(actions + uintptr((*(*Uint32_t)(unsafe.Pointer(bp /* count */))-Uint32_t(1)))*8))
			if int32(*(*Uint8_t)(unsafe.Pointer(bp + 4 /* &action */))) == TSParseActionTypeShift {
				if *(*uint8)(unsafe.Pointer(bp + 4 /* &action */ /* &.shift */ + 4 /* &.extra */)) != 0 {
					return state
				}
				return *(*TSStateId)(unsafe.Pointer(bp + 4 /* &action */ /* &.shift */ + 2 /* &.state */))
			}
		}
		return TSStateId(0)
	} else {
		return ts_language_lookup(tls, self, state, symbol)
	}
	return TSStateId(0)
}

func ts_language_enabled_external_tokens(tls *libc.TLS, self uintptr, external_scanner_state uint32) uintptr { /* language.h:203:26: */
	if external_scanner_state == uint32(0) {
		return uintptr(0)
	} else {
		return ((*TSLanguage)(unsafe.Pointer(self)).External_scanner.States + uintptr(((*TSLanguage)(unsafe.Pointer(self)).External_token_count * external_scanner_state)))
	}
	return uintptr(0)
}

func ts_language_alias_sequence(tls *libc.TLS, self uintptr, production_id Uint32_t) uintptr { /* language.h:214:30: */
	if production_id != 0 {
		return ((*TSLanguage)(unsafe.Pointer(self)).Alias_sequences + uintptr((production_id*Uint32_t((*TSLanguage)(unsafe.Pointer(self)).Max_alias_sequence_length)))*2)
	}
	return uintptr(0)
}

func ts_language_alias_at(tls *libc.TLS, self uintptr, production_id Uint32_t, child_index Uint32_t) TSSymbol { /* language.h:223:24: */
	if production_id != 0 {
		return *(*TSSymbol)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Alias_sequences + uintptr(((production_id*Uint32_t((*TSLanguage)(unsafe.Pointer(self)).Max_alias_sequence_length))+child_index))*2))
	}
	return uint16(0)
}

func ts_language_field_map(tls *libc.TLS, self uintptr, production_id Uint32_t, start uintptr, end uintptr) { /* language.h:233:20: */
	if (*TSLanguage)(unsafe.Pointer(self)).Field_count == Uint32_t(0) {
		*(*uintptr)(unsafe.Pointer(start)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(end)) = uintptr(0)
		return
	}

	var slice = *(*TSFieldMapSlice)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Field_map_slices + uintptr(production_id)*4))
	*(*uintptr)(unsafe.Pointer(start)) = ((*TSLanguage)(unsafe.Pointer(self)).Field_map_entries + uintptr(slice.Index)*4)
	*(*uintptr)(unsafe.Pointer(end)) = (((*TSLanguage)(unsafe.Pointer(self)).Field_map_entries + uintptr(slice.Index)*4) + uintptr(slice.Length)*4)
}

func ts_language_aliases_for_symbol(tls *libc.TLS, self uintptr, original_symbol TSSymbol, start uintptr, end uintptr) { /* language.h:250:20: */
	*(*uintptr)(unsafe.Pointer(start)) = ((*TSLanguage)(unsafe.Pointer(self)).Public_symbol_map + uintptr(original_symbol)*2)
	*(*uintptr)(unsafe.Pointer(end)) = (*(*uintptr)(unsafe.Pointer(start)) + uintptr(1)*2)

	var i uint32 = uint32(0)
	for {
		var symbol TSSymbol = *(*Uint16_t)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Alias_map + uintptr(libc.PostIncUint32(&i, 1))*2))
		if (int32(symbol) == 0) || (int32(symbol) > int32(original_symbol)) {
			break
		}
		var count Uint16_t = *(*Uint16_t)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Alias_map + uintptr(libc.PostIncUint32(&i, 1))*2))
		if int32(symbol) == int32(original_symbol) {
			*(*uintptr)(unsafe.Pointer(start)) = ((*TSLanguage)(unsafe.Pointer(self)).Alias_map + uintptr(i)*2)
			*(*uintptr)(unsafe.Pointer(end)) = ((*TSLanguage)(unsafe.Pointer(self)).Alias_map + uintptr((i+uint32(count)))*2)
			break
		}
		i = i + (uint32(count))
	}
}

// 8462256: modified __assert_rtn() replaces deprecated __eprintf()

// #define DEBUG_GET_CHANGED_RANGES

func ts_range_array_add(tls *libc.TLS, self uintptr, start Length, end Length) { /* get_changed_ranges.c:10:13: */
	if (*TSRangeArray)(unsafe.Pointer(self)).Size > Uint32_t(0) {
		var last_range uintptr = func() uintptr {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*TSRangeArray)(unsafe.Pointer((self))).Size-Uint32_t(1)) < (*TSRangeArray)(unsafe.Pointer((self))).Size)), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__16)), ts+189 /* "upstream/tree-si..." */, 12, ts+239 /* "(uint32_t)(self)..." */)
			} else {
			}
			return ((*TSRangeArray)(unsafe.Pointer((self))).Contents + uintptr(((*TSRangeArray)(unsafe.Pointer((self))).Size-Uint32_t(1)))*24)
		}()
		if start.Bytes <= (*TSRange)(unsafe.Pointer(last_range)).End_byte {
			(*TSRange)(unsafe.Pointer(last_range)).End_byte = end.Bytes
			(*TSRange)(unsafe.Pointer(last_range)).End_point = end.Extent
			return
		}
	}

	if start.Bytes < end.Bytes {
		var range1 = TSRange{Start_point: start.Extent, End_point: end.Extent, Start_byte: start.Bytes, End_byte: end.Bytes}
		array__grow(tls, self, uint64(1), uint64(unsafe.Sizeof(TSRange{})))
		*(*TSRange)(unsafe.Pointer((*TSRangeArray)(unsafe.Pointer((self))).Contents + uintptr(libc.PostIncUint32(&(*TSRangeArray)(unsafe.Pointer(self)).Size, 1))*24)) = range1
	}
}

var __func__16 = *(*[19]int8)(unsafe.Pointer(ts + 281 /* "ts_range_array_a..." */)) /* get_changed_ranges.c:10:78 */

func Xts_range_array_intersects(tls *libc.TLS, self uintptr, start_index uint32, start_byte Uint32_t, end_byte Uint32_t) uint8 { /* get_changed_ranges.c:26:6: */
	{
		var i uint32 = start_index
	__1:
		if !(i < (*TSRangeArray)(unsafe.Pointer(self)).Size) {
			goto __3
		}
		{
			var range1 uintptr = ((*TSRangeArray)(unsafe.Pointer(self)).Contents + uintptr(i)*24)
			if (*TSRange)(unsafe.Pointer(range1)).End_byte > start_byte {
				if (*TSRange)(unsafe.Pointer(range1)).Start_byte >= end_byte {
					goto __3
				}
				return uint8(True)
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return uint8(False)
}

func Xts_range_array_get_changed_ranges(tls *libc.TLS, old_ranges uintptr, old_range_count uint32, new_ranges uintptr, new_range_count uint32, differences uintptr) { /* get_changed_ranges.c:38:6: */
	var new_index uint32 = uint32(0)
	var old_index uint32 = uint32(0)
	var current_position = length_zero(tls)
	var in_old_range uint8 = uint8(False)
	var in_new_range uint8 = uint8(False)

	for (old_index < old_range_count) || (new_index < new_range_count) {
		var old_range uintptr = (old_ranges + uintptr(old_index)*24)
		var new_range uintptr = (new_ranges + uintptr(new_index)*24)
		var next_old_position Length
		if in_old_range != 0 {
			next_old_position = Length{Bytes: (*TSRange)(unsafe.Pointer(old_range)).End_byte, Extent: (*TSRange)(unsafe.Pointer(old_range)).End_point}
		} else if old_index < old_range_count {
			next_old_position = Length{Bytes: (*TSRange)(unsafe.Pointer(old_range)).Start_byte, Extent: (*TSRange)(unsafe.Pointer(old_range)).Start_point}
		} else {
			next_old_position = sLENGTH_MAX
		}
		var next_new_position Length
		if in_new_range != 0 {
			next_new_position = Length{Bytes: (*TSRange)(unsafe.Pointer(new_range)).End_byte, Extent: (*TSRange)(unsafe.Pointer(new_range)).End_point}
		} else if new_index < new_range_count {
			next_new_position = Length{Bytes: (*TSRange)(unsafe.Pointer(new_range)).Start_byte, Extent: (*TSRange)(unsafe.Pointer(new_range)).Start_point}
		} else {
			next_new_position = sLENGTH_MAX
		}

		if next_old_position.Bytes < next_new_position.Bytes {
			if in_old_range != in_new_range {
				ts_range_array_add(tls, differences, current_position, next_old_position)
			}
			if in_old_range != 0 {
				old_index++
			}
			current_position = next_old_position
			in_old_range = libc.BoolUint8(!(in_old_range != 0))
		} else if next_new_position.Bytes < next_old_position.Bytes {
			if in_old_range != in_new_range {
				ts_range_array_add(tls, differences, current_position, next_new_position)
			}
			if in_new_range != 0 {
				new_index++
			}
			current_position = next_new_position
			in_new_range = libc.BoolUint8(!(in_new_range != 0))
		} else {
			if in_old_range != in_new_range {
				ts_range_array_add(tls, differences, current_position, next_new_position)
			}
			if in_old_range != 0 {
				old_index++
			}
			if in_new_range != 0 {
				new_index++
			}
			in_old_range = libc.BoolUint8(!(in_old_range != 0))
			in_new_range = libc.BoolUint8(!(in_new_range != 0))
			current_position = next_new_position
		}
	}
}

type Iterator = struct {
	Cursor        TreeCursor
	Language      uintptr
	Visible_depth uint32
	In_padding    uint8
	__ccgo_pad1   [3]byte
} /* get_changed_ranges.c:103:3 */

func iterator_new(tls *libc.TLS, cursor uintptr, tree uintptr, language uintptr) Iterator { /* get_changed_ranges.c:105:17: */
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((cursor + 8 /* &.stack */))).Size = Uint32_t(0)
	array__grow(tls, (cursor + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
	*(*TreeCursorEntry)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((cursor + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((cursor+8 /* &.stack */))).Size, 1))*32)) = TreeCursorEntry{Subtree: tree, Position: length_zero(tls)}
	return Iterator{Cursor: *(*TreeCursor)(unsafe.Pointer(cursor)), Language: language, Visible_depth: uint32(1)}
}

func iterator_done(tls *libc.TLS, self uintptr) uint8 { /* get_changed_ranges.c:121:13: */
	return (uint8(libc.Bool32((*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Size == Uint32_t(0))))
}

func iterator_start_position(tls *libc.TLS, self uintptr) Length { /* get_changed_ranges.c:125:15: */
	var entry = *(*TreeCursorEntry)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__17)), ts+189 /* "upstream/tree-si..." */, 126, ts+300 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)))*32)
	}()))
	if (*Iterator)(unsafe.Pointer(self)).In_padding != 0 {
		return entry.Position
	} else {
		return length_add(tls, entry.Position, ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree))))
	}
	return Length{}
}

var __func__17 = *(*[24]int8)(unsafe.Pointer(ts + 372 /* "iterator_start_p..." */)) /* get_changed_ranges.c:125:55 */

func iterator_end_position(tls *libc.TLS, self uintptr) Length { /* get_changed_ranges.c:134:15: */
	var entry = *(*TreeCursorEntry)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__18)), ts+189 /* "upstream/tree-si..." */, 135, ts+300 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)))*32)
	}()))
	var result = length_add(tls, entry.Position, ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree))))
	if (*Iterator)(unsafe.Pointer(self)).In_padding != 0 {
		return result
	} else {
		return length_add(tls, result, ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree))))
	}
	return Length{}
}

var __func__18 = *(*[22]int8)(unsafe.Pointer(ts + 396 /* "iterator_end_pos..." */)) /* get_changed_ranges.c:134:53 */

func iterator_tree_is_visible(tls *libc.TLS, self uintptr) uint8 { /* get_changed_ranges.c:144:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var entry = *(*TreeCursorEntry)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__19)), ts+189 /* "upstream/tree-si..." */, 145, ts+300 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)))*32)
	}()))
	if ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree))) != 0 {
		return uint8(True)
	}
	if (*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Size > Uint32_t(1) {
		*(*Subtree)(unsafe.Pointer(bp /* parent */)) = *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer((*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Contents + uintptr(((*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Size-Uint32_t(2)))*32)).Subtree))
		return (uint8(libc.Bool32(int32(ts_language_alias_at(tls,
			(*Iterator)(unsafe.Pointer(self)).Language,
			uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &parent */)) + 68))),
			entry.Structural_child_index)) != 0)))
	}
	return uint8(False)
}

var __func__19 = *(*[25]int8)(unsafe.Pointer(ts + 418 /* "iterator_tree_is..." */)) /* get_changed_ranges.c:144:60 */

func iterator_get_visible_state(tls *libc.TLS, self uintptr, tree uintptr, alias_symbol uintptr, start_byte uintptr) { /* get_changed_ranges.c:158:13: */
	var i Uint32_t = ((*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Size - Uint32_t(1))

	if (*Iterator)(unsafe.Pointer(self)).In_padding != 0 {
		if i == Uint32_t(0) {
			return
		}
		i--
	}

	for ; (i + Uint32_t(1)) > Uint32_t(0); i-- {
		var entry = *(*TreeCursorEntry)(unsafe.Pointer((*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Contents + uintptr(i)*32))

		if i > Uint32_t(0) {
			var parent uintptr = (*TreeCursorEntry)(unsafe.Pointer((*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Contents + uintptr((i-Uint32_t(1)))*32)).Subtree
			*(*TSSymbol)(unsafe.Pointer(alias_symbol)) = ts_language_alias_at(tls,
				(*Iterator)(unsafe.Pointer(self)).Language,
				uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(parent /* .Ptr */)) + 68))),
				entry.Structural_child_index)
		}

		if (ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree))) != 0) || (*(*TSSymbol)(unsafe.Pointer(alias_symbol)) != 0) {
			*(*Subtree)(unsafe.Pointer(tree)) = *(*Subtree)(unsafe.Pointer(entry.Subtree))
			*(*Uint32_t)(unsafe.Pointer(start_byte)) = entry.Position.Bytes
			break
		}
	}
}

func iterator_ascend(tls *libc.TLS, self uintptr) { /* get_changed_ranges.c:191:13: */
	if iterator_done(tls, self) != 0 {
		return
	}
	if (iterator_tree_is_visible(tls, self) != 0) && !(int32((*Iterator)(unsafe.Pointer(self)).In_padding) != 0) {
		(*Iterator)(unsafe.Pointer(self)).Visible_depth--
	}
	if (*TreeCursorEntry)(unsafe.Pointer((func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__20)), ts+189 /* "upstream/tree-si..." */, 194, ts+300 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)))*32)
	}()))).Child_index > Uint32_t(0) {
		(*Iterator)(unsafe.Pointer(self)).In_padding = uint8(False)
	}
	(*Iterator)(unsafe.Pointer(self)).Cursor.Stack.Size--
}

var __func__20 = *(*[16]int8)(unsafe.Pointer(ts + 443 /* "iterator_ascend" */)) /* get_changed_ranges.c:191:45 */

func iterator_descend(tls *libc.TLS, self uintptr, goal_position Uint32_t) uint8 { /* get_changed_ranges.c:198:13: */
	if (*Iterator)(unsafe.Pointer(self)).In_padding != 0 {
		return uint8(False)
	}
	var did_descend uint8
	for ok := true; ok; ok = did_descend != 0 {
		did_descend = uint8(False)
		var entry = *(*TreeCursorEntry)(unsafe.Pointer(func() uintptr {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size)), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__21)), ts+189 /* "upstream/tree-si..." */, 204, ts+300 /* "(uint32_t)(&self..." */)
			} else {
			}
			return ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)))*32)
		}()))
		var position = entry.Position
		var structural_child_index Uint32_t = Uint32_t(0)
		{
			var i Uint32_t = Uint32_t(0)
			var n Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree)))
		__1:
			if !(i < n) {
				goto __3
			}
			{
				var child uintptr = ((func() uintptr {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(entry.Subtree /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						return uintptr(0)
					}
					return ((*(*uintptr)(unsafe.Pointer(entry.Subtree))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(entry.Subtree)))).Child_count)*16)
				}()) + uintptr(i)*16)
				var child_left = length_add(tls, position, ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(child))))
				var child_right = length_add(tls, child_left, ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(child))))

				if child_right.Bytes > goal_position {
					array__grow(tls, (self /* &.cursor */ + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
					*(*TreeCursorEntry)(unsafe.Pointer((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size, 1))*32)) = TreeCursorEntry{Subtree: child, Position: position, Child_index: i, Structural_child_index: structural_child_index}

					if iterator_tree_is_visible(tls, self) != 0 {
						if child_left.Bytes > goal_position {
							(*Iterator)(unsafe.Pointer(self)).In_padding = uint8(True)
						} else {
							(*Iterator)(unsafe.Pointer(self)).Visible_depth++
						}
						return uint8(True)
					}

					did_descend = uint8(True)
					goto __3
				}

				position = child_right
				if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(child))) != 0) {
					structural_child_index++
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	return uint8(False)
}

var __func__21 = *(*[17]int8)(unsafe.Pointer(ts + 459 /* "iterator_descend" */)) /* get_changed_ranges.c:198:70 */

func iterator_advance(tls *libc.TLS, self uintptr) { /* get_changed_ranges.c:241:13: */
	if (*Iterator)(unsafe.Pointer(self)).In_padding != 0 {
		(*Iterator)(unsafe.Pointer(self)).In_padding = uint8(False)
		if iterator_tree_is_visible(tls, self) != 0 {
			(*Iterator)(unsafe.Pointer(self)).Visible_depth++
		} else {
			iterator_descend(tls, self, uint32(0))
		}
		return
	}

	for {
		if iterator_tree_is_visible(tls, self) != 0 {
			(*Iterator)(unsafe.Pointer(self)).Visible_depth--
		}
		var entry = *(*TreeCursorEntry)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(libc.PreDecUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size, 1))*32))
		if iterator_done(tls, self) != 0 {
			return
		}

		var parent uintptr = (*TreeCursorEntry)(unsafe.Pointer(func() uintptr {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size)), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__22)), ts+189 /* "upstream/tree-si..." */, 257, ts+300 /* "(uint32_t)(&self..." */)
			} else {
			}
			return ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size-Uint32_t(1)))*32)
		}())).Subtree
		var child_index Uint32_t = (entry.Child_index + Uint32_t(1))
		if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(parent))) > child_index {
			var position = length_add(tls, entry.Position, ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree))))
			var structural_child_index Uint32_t = entry.Structural_child_index
			if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(entry.Subtree))) != 0) {
				structural_child_index++
			}
			var next_child uintptr = ((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(parent /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(parent))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(parent)))).Child_count)*16)
			}()) + uintptr(child_index)*16)

			array__grow(tls, (self /* &.cursor */ + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
			*(*TreeCursorEntry)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.cursor */ +8 /* &.stack */))).Size, 1))*32)) = TreeCursorEntry{Subtree: next_child, Position: position, Child_index: child_index, Structural_child_index: structural_child_index}

			if iterator_tree_is_visible(tls, self) != 0 {
				if ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(next_child))).Bytes > Uint32_t(0) {
					(*Iterator)(unsafe.Pointer(self)).In_padding = uint8(True)
				} else {
					(*Iterator)(unsafe.Pointer(self)).Visible_depth++
				}
			} else {
				iterator_descend(tls, self, uint32(0))
			}
			break
		}
	}
}

var __func__22 = *(*[17]int8)(unsafe.Pointer(ts + 476 /* "iterator_advance" */)) /* get_changed_ranges.c:241:46 */

type IteratorComparison = uint32 /* get_changed_ranges.c:290:3 */

func iterator_compare(tls *libc.TLS, old_iter uintptr, new_iter uintptr) IteratorComparison { /* get_changed_ranges.c:292:27: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*Subtree)(unsafe.Pointer(bp /* old_tree */)) = Subtree{}
	*(*Subtree)(unsafe.Pointer(bp + 24 /* new_tree */)) = Subtree{}
	*(*Uint32_t)(unsafe.Pointer(bp + 20 /* old_start */)) = Uint32_t(0)
	*(*Uint32_t)(unsafe.Pointer(bp + 44 /* new_start */)) = Uint32_t(0)
	*(*TSSymbol)(unsafe.Pointer(bp + 16 /* old_alias_symbol */)) = TSSymbol(0)
	*(*TSSymbol)(unsafe.Pointer(bp + 40 /* new_alias_symbol */)) = TSSymbol(0)
	iterator_get_visible_state(tls, old_iter, bp /* &old_tree */, bp+16 /* &old_alias_symbol */, bp+20 /* &old_start */)
	iterator_get_visible_state(tls, new_iter, bp+24 /* &new_tree */, bp+40 /* &new_alias_symbol */, bp+44 /* &new_start */)

	if !(int32(*(*uintptr)(unsafe.Pointer(bp /* &old_tree */))) != 0) && !(int32(*(*uintptr)(unsafe.Pointer(bp + 24 /* &new_tree */))) != 0) {
		return IteratorMatches
	}
	if !(int32(*(*uintptr)(unsafe.Pointer(bp /* &old_tree */))) != 0) || !(int32(*(*uintptr)(unsafe.Pointer(bp + 24 /* &new_tree */))) != 0) {
		return IteratorDiffers
	}

	if (int32(*(*TSSymbol)(unsafe.Pointer(bp + 16 /* old_alias_symbol */))) == int32(*(*TSSymbol)(unsafe.Pointer(bp + 40 /* new_alias_symbol */)))) && (int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp /* old_tree */)))) == int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 24 /* new_tree */))))) {
		if ((((((*(*Uint32_t)(unsafe.Pointer(bp + 20 /* old_start */)) == *(*Uint32_t)(unsafe.Pointer(bp + 44 /* new_start */))) && !(ts_subtree_has_changes(tls, *(*Subtree)(unsafe.Pointer(bp /* old_tree */))) != 0)) && (int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp /* old_tree */)))) != (int32(libc.Uint16FromInt32(-1))))) && (ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(bp /* old_tree */))).Bytes == ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(bp + 24 /* new_tree */))).Bytes)) && (int32(ts_subtree_parse_state(tls, *(*Subtree)(unsafe.Pointer(bp /* old_tree */)))) != ((0x7fff * 2) + 1))) && (int32(ts_subtree_parse_state(tls, *(*Subtree)(unsafe.Pointer(bp + 24 /* new_tree */)))) != ((0x7fff * 2) + 1))) && ((libc.Bool32(int32(ts_subtree_parse_state(tls, *(*Subtree)(unsafe.Pointer(bp /* old_tree */)))) == ERROR_STATE)) == (libc.Bool32(int32(ts_subtree_parse_state(tls, *(*Subtree)(unsafe.Pointer(bp + 24 /* new_tree */)))) == ERROR_STATE))) {
			return IteratorMatches
		} else {
			return IteratorMayDiffer
		}
	}

	return IteratorDiffers
}

func Xts_subtree_get_changed_ranges(tls *libc.TLS, old_tree uintptr, new_tree uintptr, cursor1 uintptr, cursor2 uintptr, language uintptr, included_range_differences uintptr, ranges uintptr) uint32 { /* get_changed_ranges.c:342:10: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	*(*TSRangeArray)(unsafe.Pointer(bp + 80 /* results */)) = TSRangeArray{}

	*(*Iterator)(unsafe.Pointer(bp /* old_iter */)) = iterator_new(tls, cursor1, old_tree, language)
	*(*Iterator)(unsafe.Pointer(bp + 40 /* new_iter */)) = iterator_new(tls, cursor2, new_tree, language)

	var included_range_difference_index uint32 = uint32(0)

	var position = iterator_start_position(tls, bp /* &old_iter */)
	var next_position = iterator_start_position(tls, bp+40 /* &new_iter */)
	if position.Bytes < next_position.Bytes {
		ts_range_array_add(tls, bp+80 /* &results */, position, next_position)
		position = next_position
	} else if position.Bytes > next_position.Bytes {
		ts_range_array_add(tls, bp+80 /* &results */, next_position, position)
		next_position = position
	}

	for ok := true; ok; ok = (!(iterator_done(tls, bp /* &old_iter */) != 0) && !(iterator_done(tls, bp+40 /* &new_iter */) != 0)) {

		// Compare the old and new subtrees.
		var comparison IteratorComparison = iterator_compare(tls, bp /* &old_iter */, bp+40 /* &new_iter */)

		// Even if the two subtrees appear to be identical, they could differ
		// internally if they contain a range of text that was previously
		// excluded from the parse, and is now included, or vice-versa.
		if (comparison == IteratorMatches) && (Xts_range_array_intersects(tls,
			included_range_differences,
			included_range_difference_index,
			position.Bytes,
			iterator_end_position(tls, bp /* &old_iter */).Bytes) != 0) {
			comparison = IteratorMayDiffer
		}

		var is_changed uint8 = uint8(False)
		switch comparison {
		// If the subtrees are definitely identical, move to the end
		// of both subtrees.
		case IteratorMatches:
			next_position = iterator_end_position(tls, bp /* &old_iter */)
			break

		// If the subtrees might differ internally, descend into both
		// subtrees, finding the first child that spans the current position.
		case IteratorMayDiffer:
			if iterator_descend(tls, bp /* &old_iter */, position.Bytes) != 0 {
				if !(iterator_descend(tls, bp+40 /* &new_iter */, position.Bytes) != 0) {
					is_changed = uint8(True)
					next_position = iterator_end_position(tls, bp /* &old_iter */)
				}
			} else if iterator_descend(tls, bp+40 /* &new_iter */, position.Bytes) != 0 {
				is_changed = uint8(True)
				next_position = iterator_end_position(tls, bp+40 /* &new_iter */)
			} else {
				next_position = length_min(tls,
					iterator_end_position(tls, bp /* &old_iter */),
					iterator_end_position(tls, bp+40 /* &new_iter */))
			}
			break

		// If the subtrees are different, record a change and then move
		// to the end of both subtrees.
		case IteratorDiffers:
			is_changed = uint8(True)
			next_position = length_min(tls,
				iterator_end_position(tls, bp /* &old_iter */),
				iterator_end_position(tls, bp+40 /* &new_iter */))
			break
		}

		// Ensure that both iterators are caught up to the current position.
		for !(iterator_done(tls, bp /* &old_iter */) != 0) && (iterator_end_position(tls, bp /* &old_iter */).Bytes <= next_position.Bytes) {
			iterator_advance(tls, bp /* &old_iter */)
		}
		for !(iterator_done(tls, bp+40 /* &new_iter */) != 0) && (iterator_end_position(tls, bp+40 /* &new_iter */).Bytes <= next_position.Bytes) {
			iterator_advance(tls, bp+40 /* &new_iter */)
		}

		// Ensure that both iterators are at the same depth in the tree.
		for (*Iterator)(unsafe.Pointer(bp /* &old_iter */)).Visible_depth > (*Iterator)(unsafe.Pointer(bp+40 /* &new_iter */)).Visible_depth {
			iterator_ascend(tls, bp /* &old_iter */)
		}
		for (*Iterator)(unsafe.Pointer(bp+40 /* &new_iter */)).Visible_depth > (*Iterator)(unsafe.Pointer(bp /* &old_iter */)).Visible_depth {
			iterator_ascend(tls, bp+40 /* &new_iter */)
		}

		if is_changed != 0 {

			ts_range_array_add(tls, bp+80 /* &results */, position, next_position)
		}

		position = next_position

		// Keep track of the current position in the included range differences
		// array in order to avoid scanning the entire array on each iteration.
		for included_range_difference_index < (*TSRangeArray)(unsafe.Pointer(included_range_differences)).Size {
			var range1 uintptr = ((*TSRangeArray)(unsafe.Pointer(included_range_differences)).Contents + uintptr(included_range_difference_index)*24)
			if (*TSRange)(unsafe.Pointer(range1)).End_byte <= position.Bytes {
				included_range_difference_index++
			} else {
				break
			}
		}
	}

	var old_size = ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(old_tree)))
	var new_size = ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(new_tree)))
	if old_size.Bytes < new_size.Bytes {
		ts_range_array_add(tls, bp+80 /* &results */, old_size, new_size)
	} else if new_size.Bytes < old_size.Bytes {
		ts_range_array_add(tls, bp+80 /* &results */, new_size, old_size)
	}

	*(*TreeCursor)(unsafe.Pointer(cursor1)) = (*Iterator)(unsafe.Pointer(bp /* &old_iter */)).Cursor
	*(*TreeCursor)(unsafe.Pointer(cursor2)) = (*Iterator)(unsafe.Pointer(bp + 40 /* &new_iter */)).Cursor
	*(*uintptr)(unsafe.Pointer(ranges)) = (*TSRangeArray)(unsafe.Pointer(bp + 80 /* &results */)).Contents
	return (*TSRangeArray)(unsafe.Pointer(bp + 80 /* &results */)).Size
}

// Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93

func Xts_language_symbol_count(tls *libc.TLS, self uintptr) Uint32_t { /* language.c:6:10: */
	return ((*TSLanguage)(unsafe.Pointer(self)).Symbol_count + (*TSLanguage)(unsafe.Pointer(self)).Alias_count)
}

func Xts_language_version(tls *libc.TLS, self uintptr) Uint32_t { /* language.c:10:10: */
	return (*TSLanguage)(unsafe.Pointer(self)).Version
}

func Xts_language_field_count(tls *libc.TLS, self uintptr) Uint32_t { /* language.c:14:10: */
	return (*TSLanguage)(unsafe.Pointer(self)).Field_count
}

func Xts_language_table_entry(tls *libc.TLS, self uintptr, state TSStateId, symbol TSSymbol, result uintptr) { /* language.c:18:6: */
	if (int32(symbol) == (int32(libc.Uint16FromInt32(-1)))) || (int32(symbol) == ((int32(libc.Uint16FromInt32(-1))) - 1)) {
		(*TableEntry)(unsafe.Pointer(result)).Action_count = Uint32_t(0)
		(*TableEntry)(unsafe.Pointer(result)).Is_reusable = uint8(False)
		(*TableEntry)(unsafe.Pointer(result)).Actions = uintptr(0)
	} else {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(Uint32_t(symbol) < (*TSLanguage)(unsafe.Pointer(self)).Token_count)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__23)), ts+493 /* "upstream/tree-si..." */, 29, ts+533 /* "symbol < self->t..." */)
		} else {
		}
		var action_index Uint32_t = Uint32_t(ts_language_lookup(tls, self, state, symbol))
		var entry uintptr = ((*TSLanguage)(unsafe.Pointer(self)).Parse_actions + uintptr(action_index)*8)
		(*TableEntry)(unsafe.Pointer(result)).Action_count = Uint32_t(*(*Uint8_t)(unsafe.Pointer(entry /* &.entry */ /* &.count */)))
		(*TableEntry)(unsafe.Pointer(result)).Is_reusable = *(*uint8)(unsafe.Pointer(entry /* &.entry */ + 1 /* &.reusable */))
		(*TableEntry)(unsafe.Pointer(result)).Actions = (entry + uintptr(1)*8)
	}
}

var __func__23 = *(*[24]int8)(unsafe.Pointer(ts + 560 /* "ts_language_tabl..." */)) /* language.c:23:3 */

func Xts_language_symbol_metadata(tls *libc.TLS, self uintptr, symbol TSSymbol) TSSymbolMetadata { /* language.c:38:18: */
	if int32(symbol) == (int32(libc.Uint16FromInt32(-1))) {
		return TSSymbolMetadata{Visible: uint8(True), Named: uint8(True)}
	} else if int32(symbol) == ((int32(libc.Uint16FromInt32(-1))) - 1) {
		return TSSymbolMetadata{}
	} else {
		return *(*TSSymbolMetadata)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Symbol_metadata + uintptr(symbol)*3))
	}
	return TSSymbolMetadata{}
}

func Xts_language_public_symbol(tls *libc.TLS, self uintptr, symbol TSSymbol) TSSymbol { /* language.c:51:10: */
	if int32(symbol) == (int32(libc.Uint16FromInt32(-1))) {
		return symbol
	}
	return *(*TSSymbol)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Public_symbol_map + uintptr(symbol)*2))
}

func Xts_language_symbol_name(tls *libc.TLS, self uintptr, symbol TSSymbol) uintptr { /* language.c:59:12: */
	if int32(symbol) == (int32(libc.Uint16FromInt32(-1))) {
		return ts + 584 /* "ERROR" */
	} else if int32(symbol) == ((int32(libc.Uint16FromInt32(-1))) - 1) {
		return ts + 590 /* "_ERROR" */
	} else if Uint32_t(symbol) < Xts_language_symbol_count(tls, self) {
		return *(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Symbol_names + uintptr(symbol)*8))
	} else {
		return uintptr(0)
	}
	return uintptr(0)
}

func Xts_language_symbol_for_name(tls *libc.TLS, self uintptr, string uintptr, length Uint32_t, is_named uint8) TSSymbol { /* language.c:74:10: */
	if !(libc.Xstrncmp(tls, string, ts+584 /* "ERROR" */, uint64(length)) != 0) {
		return libc.Uint16(libc.Uint16FromInt32(-1))
	}
	var count Uint32_t = Xts_language_symbol_count(tls, self)
	{
		var i TSSymbol = TSSymbol(0)
	__1:
		if !(Uint32_t(i) < count) {
			goto __3
		}
		{
			var metadata = Xts_language_symbol_metadata(tls, self, i)
			if (!(int32(metadata.Visible) != 0) && !(int32(metadata.Supertype) != 0)) || (metadata.Named != is_named) {
				goto __2
			}
			var symbol_name uintptr = *(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Symbol_names + uintptr(i)*8))
			if !(libc.Xstrncmp(tls, symbol_name, string, uint64(length)) != 0) && !(int32(*(*int8)(unsafe.Pointer(symbol_name + uintptr(length)))) != 0) {
				return *(*TSSymbol)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Public_symbol_map + uintptr(i)*2))
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return TSSymbol(0)
}

func Xts_language_symbol_type(tls *libc.TLS, self uintptr, symbol TSSymbol) TSSymbolType { /* language.c:93:14: */
	var metadata = Xts_language_symbol_metadata(tls, self, symbol)
	if (metadata.Named != 0) && (metadata.Visible != 0) {
		return TSSymbolTypeRegular
	} else if metadata.Visible != 0 {
		return TSSymbolTypeAnonymous
	} else {
		return TSSymbolTypeAuxiliary
	}
	return TSSymbolType(0)
}

func Xts_language_field_name_for_id(tls *libc.TLS, self uintptr, id TSFieldId) uintptr { /* language.c:107:12: */
	var count Uint32_t = Xts_language_field_count(tls, self)
	if (count != 0) && (Uint32_t(id) <= count) {
		return *(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Field_names + uintptr(id)*8))
	} else {
		return uintptr(0)
	}
	return uintptr(0)
}

func Xts_language_field_id_for_name(tls *libc.TLS, self uintptr, name uintptr, name_length Uint32_t) TSFieldId { /* language.c:119:11: */
	var count Uint32_t = Xts_language_field_count(tls, self)
	{
		var i TSSymbol = TSSymbol(1)
	__1:
		if !(Uint32_t(i) < (count + Uint32_t(1))) {
			goto __3
		}
		{
			switch libc.Xstrncmp(tls, name, *(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Field_names + uintptr(i)*8)), uint64(name_length)) {
			case 0:
				if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(self)).Field_names + uintptr(i)*8)) + uintptr(name_length)))) == 0 {
					return i
				}
				break
			case -1:
				return TSFieldId(0)
			default:
				break
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return TSFieldId(0)
}

var sLENGTH_UNDEFINED2 = Length{Extent: TSPoint{Column: Uint32_t(1)}} /* length.h:14:21 */

type Lexer = struct {
	Data                         TSLexer
	Current_position             Length
	Token_start_position         Length
	Token_end_position           Length
	__ccgo_pad1                  [4]byte
	Included_ranges              uintptr
	Chunk                        uintptr
	Input                        TSInput
	Logger                       TSLogger
	Included_range_count         Uint32_t
	Current_included_range_index Uint32_t
	Chunk_start                  Uint32_t
	Chunk_size                   Uint32_t
	Lookahead_size               Uint32_t
	Did_get_column               uint8
	Debug_buffer                 [1024]int8
	__ccgo_pad2                  [3]byte
} /* lexer.h:32:3 */

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//    as great as that of any standard type not using alignment
//    specifiers.
type Max_align_t = struct {
	X__max_align_ll int64
	X__max_align_ld float64
} /* stddef.h:426:3 */

//==========================================================================
// For C wrappers, we use the symbol U_STABLE.
// This works properly if the includer is C or C++.
// Functions are declared   U_STABLE return-type U_EXPORT2 function-name()...
//==========================================================================

// *
// \def U_CFUNC
// This is used in a declaration of a library private ICU C function.
// @stable ICU 2.4

// *
// \def U_CDECL_BEGIN
// This is used to begin a declaration of a library private ICU C API.
// @stable ICU 2.4

// *
// \def U_CDECL_END
// This is used to end a declaration of a library private ICU C API
// @stable ICU 2.4

// *
// \def U_ATTRIBUTE_DEPRECATED
//  This is used for GCC specific attributes
// @internal

//* This is used to declare a function as a public ICU C API @stable ICU 2.0
//* This is used to declare a function as a stable public ICU C API
//* This is used to declare a function as a draft public ICU C API
//* This is used to declare a function as a deprecated public ICU C API
//* This is used to declare a function as an obsolete public ICU C API
//* This is used to declare a function as an internal ICU C API

// *
// \def U_OVERRIDE
// Defined to the C++11 "override" keyword if available.
// Denotes a class or member which is an override of the base class.
// May result in an error if it applied to something not an override.
// @internal

// *
// \def U_FINAL
// Defined to the C++11 "final" keyword if available.
// Denotes a class or member which may not be overridden in subclasses.
// May result in an error if subclasses attempt to override.
// @internal

// Before ICU 65, function-like, multi-statement ICU macros were just defined as
// series of statements wrapped in { } blocks and the caller could choose to
// either treat them as if they were actual functions and end the invocation
// with a trailing ; creating an empty statement after the block or else omit
// this trailing ; using the knowledge that the macro would expand to { }.
//
// But doing so doesn't work well with macros that look like functions and
// compiler warnings about empty statements (ICU-20601) and ICU 65 therefore
// switches to the standard solution of wrapping such macros in do { } while.
//
// This will however break existing code that depends on being able to invoke
// these macros without a trailing ; so to be able to remain compatible with
// such code the wrapper is itself defined as macros so that it's possible to
// build ICU 65 and later with the old macro behaviour, like this:
//
// CPPFLAGS='-DUPRV_BLOCK_MACRO_BEGIN="" -DUPRV_BLOCK_MACRO_END=""'
// runConfigureICU ...

// *
// \def UPRV_BLOCK_MACRO_BEGIN
// Defined as the "do" keyword by default.
// @internal

// *
// \def UPRV_BLOCK_MACRO_END
// Defined as "while (FALSE)" by default.
// @internal

//==========================================================================
// limits for int32_t etc., like in POSIX inttypes.h
//==========================================================================

//* The smallest value a 64 bit signed integer can hold @stable ICU 2.8
//* The largest value a 64 bit signed integer can hold @stable ICU 2.8
//* The largest value a 64 bit unsigned integer can hold @stable ICU 2.8

//==========================================================================
// Boolean data type
//==========================================================================

//* The ICU boolean type @stable ICU 2.0
type UBool = Int8_t /* umachine.h:260:16 */

//* The TRUE value of a UBool @stable ICU 2.0
//* The FALSE value of a UBool @stable ICU 2.0

//==========================================================================
// Unicode data types
//==========================================================================

// wchar_t-related definitions --------------------------------------------

// \def U_WCHAR_IS_UTF16
// Defined if wchar_t uses UTF-16.
//
// @stable ICU 2.0
// \def U_WCHAR_IS_UTF32
// Defined if wchar_t uses UTF-32.
//
// @stable ICU 2.0

// UChar and UChar32 definitions --------------------------------------------

//* Number of bytes in a UChar. @stable ICU 2.0

// *
// \def U_CHAR16_IS_TYPEDEF
// If 1, then char16_t is a typedef and not a real type (yet)
// @internal

// *
// \var UChar
//
// The base type for UTF-16 code units and pointers.
// Unsigned 16-bit integer.
// Starting with ICU 59, C++ API uses char16_t directly, while C API continues to use UChar.
//
// UChar is configurable by defining the macro UCHAR_TYPE
// on the preprocessor or compiler command line:
// -DUCHAR_TYPE=uint16_t or -DUCHAR_TYPE=wchar_t (if U_SIZEOF_WCHAR_T==2) etc.
// (The UCHAR_TYPE can also be \#defined earlier in this file, for outside the ICU library code.)
// This is for transitional use from application code that uses uint16_t or wchar_t for UTF-16.
//
// The default is UChar=char16_t.
//
// C++11 defines char16_t as bit-compatible with uint16_t, but as a distinct type.
//
// In C, char16_t is a simple typedef of uint_least16_t.
// ICU requires uint_least16_t=uint16_t for data memory mapping.
// On macOS, char16_t is not available because the uchar.h standard header is missing.
//
// @stable ICU 4.4

// #if 1 is normal. UChar defaults to char16_t in C++.
// For configuration testing of UChar=uint16_t temporarily change this to #if 0.
// The intltest Makefile #defines UCHAR_TYPE=char16_t,
// so we only #define it to uint16_t if it is undefined so far.

type UChar = Uint16_t /* umachine.h:377:22 */

// *
// \var OldUChar
// Default ICU 58 definition of UChar.
// A base type for UTF-16 code units and pointers.
// Unsigned 16-bit integer.
//
// Define OldUChar to be wchar_t if that is 16 bits wide.
// If wchar_t is not 16 bits wide, then define UChar to be uint16_t.
//
// This makes the definition of OldUChar platform-dependent
// but allows direct string type compatibility with platforms with
// 16-bit wchar_t types.
//
// This is how UChar was defined in ICU 58, for transition convenience.
// Exception: ICU 58 UChar was defined to UCHAR_TYPE if that macro was defined.
// The current UChar responds to UCHAR_TYPE but OldUChar does not.
//
// @stable ICU 59
type OldUChar = uint16 /* umachine.h:402:29 */

// *
// Define UChar32 as a type for single Unicode code points.
// UChar32 is a signed 32-bit integer (same as int32_t).
//
// The Unicode code point range is 0..0x10ffff.
// All other values (negative or >=0x110000) are illegal as Unicode code points.
// They may be used as sentinel values to indicate "done", "error"
// or similar non-code point conditions.
//
// Before ICU 2.4 (Jitterbug 2146), UChar32 was defined
// to be wchar_t if that is 32 bits wide (wchar_t may be signed or unsigned)
// or else to be uint32_t.
// That is, the definition of UChar32 was platform-dependent.
//
// @see U_SENTINEL
// @stable ICU 2.4
type UChar32 = Int32_t /* umachine.h:424:17 */

// single-code point definitions --------------------------------------------

// *
// Does this code unit (byte) encode a code point by itself (US-ASCII 0..0x7f)?
// @param c 8-bit code unit (byte)
// @return TRUE or FALSE
// @stable ICU 2.4

// *
// Is this code unit (byte) a UTF-8 lead byte? (0xC2..0xF4)
// @param c 8-bit code unit (byte)
// @return TRUE or FALSE
// @stable ICU 2.4
// 0x32=0xf4-0xc2

// *
// Is this code unit (byte) a UTF-8 trail byte? (0x80..0xBF)
// @param c 8-bit code unit (byte)
// @return TRUE or FALSE
// @stable ICU 2.4

// *
// How many code units (bytes) are used for the UTF-8 encoding
// of this Unicode code point?
// @param c 32-bit code point
// @return 1..4, or 0 if c is a surrogate or not a Unicode code point
// @stable ICU 2.4

// *
// The maximum number of UTF-8 code units (bytes) per Unicode code point (U+0000..U+10ffff).
// @return 4
// @stable ICU 2.4

// *
// Get a code point from a string at a random-access offset,
// without changing the offset.
// The offset may point to either the lead byte or one of the trail bytes
// for a code point, in which case the macro will read all of the bytes
// for the code point.
// The result is undefined if the offset points to an illegal UTF-8
// byte sequence.
// Iteration through a string is more efficient with U8_NEXT_UNSAFE or U8_NEXT.
//
// @param s const uint8_t * string
// @param i string offset
// @param c output UChar32 variable
// @see U8_GET
// @stable ICU 2.4

// *
// Get a code point from a string at a random-access offset,
// without changing the offset.
// The offset may point to either the lead byte or one of the trail bytes
// for a code point, in which case the macro will read all of the bytes
// for the code point.
//
// The length can be negative for a NUL-terminated string.
//
// If the offset points to an illegal UTF-8 byte sequence, then
// c is set to a negative value.
// Iteration through a string is more efficient with U8_NEXT_UNSAFE or U8_NEXT.
//
// @param s const uint8_t * string
// @param start int32_t starting string offset
// @param i int32_t string offset, must be start<=i<length
// @param length int32_t string length
// @param c output UChar32 variable, set to <0 in case of an error
// @see U8_GET_UNSAFE
// @stable ICU 2.4

// *
// Get a code point from a string at a random-access offset,
// without changing the offset.
// The offset may point to either the lead byte or one of the trail bytes
// for a code point, in which case the macro will read all of the bytes
// for the code point.
//
// The length can be negative for a NUL-terminated string.
//
// If the offset points to an illegal UTF-8 byte sequence, then
// c is set to U+FFFD.
// Iteration through a string is more efficient with U8_NEXT_UNSAFE or U8_NEXT_OR_FFFD.
//
// This macro does not distinguish between a real U+FFFD in the text
// and U+FFFD returned for an ill-formed sequence.
// Use U8_GET() if that distinction is important.
//
// @param s const uint8_t * string
// @param start int32_t starting string offset
// @param i int32_t string offset, must be start<=i<length
// @param length int32_t string length
// @param c output UChar32 variable, set to U+FFFD in case of an error
// @see U8_GET
// @stable ICU 51

// definitions with forward iteration ---------------------------------------

// *
// Get a code point from a string at a code point boundary offset,
// and advance the offset to the next code point boundary.
// (Post-incrementing forward iteration.)
// "Unsafe" macro, assumes well-formed UTF-8.
//
// The offset may point to the lead byte of a multi-byte sequence,
// in which case the macro will read the whole sequence.
// The result is undefined if the offset points to a trail byte
// or an illegal UTF-8 sequence.
//
// @param s const uint8_t * string
// @param i string offset
// @param c output UChar32 variable
// @see U8_NEXT
// @stable ICU 2.4

// *
// Get a code point from a string at a code point boundary offset,
// and advance the offset to the next code point boundary.
// (Post-incrementing forward iteration.)
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// The offset may point to the lead byte of a multi-byte sequence,
// in which case the macro will read the whole sequence.
// If the offset points to a trail byte or an illegal UTF-8 sequence, then
// c is set to a negative value.
//
// @param s const uint8_t * string
// @param i int32_t string offset, must be i<length
// @param length int32_t string length
// @param c output UChar32 variable, set to <0 in case of an error
// @see U8_NEXT_UNSAFE
// @stable ICU 2.4

// *
// Get a code point from a string at a code point boundary offset,
// and advance the offset to the next code point boundary.
// (Post-incrementing forward iteration.)
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// The offset may point to the lead byte of a multi-byte sequence,
// in which case the macro will read the whole sequence.
// If the offset points to a trail byte or an illegal UTF-8 sequence, then
// c is set to U+FFFD.
//
// This macro does not distinguish between a real U+FFFD in the text
// and U+FFFD returned for an ill-formed sequence.
// Use U8_NEXT() if that distinction is important.
//
// @param s const uint8_t * string
// @param i int32_t string offset, must be i<length
// @param length int32_t string length
// @param c output UChar32 variable, set to U+FFFD in case of an error
// @see U8_NEXT
// @stable ICU 51

//* @internal

// *
// Append a code point to a string, overwriting 1 to 4 bytes.
// The offset points to the current end of the string contents
// and is advanced (post-increment).
// "Unsafe" macro, assumes a valid code point and sufficient space in the string.
// Otherwise, the result is undefined.
//
// @param s const uint8_t * string buffer
// @param i string offset
// @param c code point to append
// @see U8_APPEND
// @stable ICU 2.4

// *
// Append a code point to a string, overwriting 1 to 4 bytes.
// The offset points to the current end of the string contents
// and is advanced (post-increment).
// "Safe" macro, checks for a valid code point.
// If a non-ASCII code point is written, checks for sufficient space in the string.
// If the code point is not valid or trail bytes do not fit,
// then isError is set to TRUE.
//
// @param s const uint8_t * string buffer
// @param i int32_t string offset, must be i<capacity
// @param capacity int32_t size of the string buffer
// @param c UChar32 code point to append
// @param isError output UBool set to TRUE if an error occurs, otherwise not modified
// @see U8_APPEND_UNSAFE
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the next.
// (Post-incrementing iteration.)
// "Unsafe" macro, assumes well-formed UTF-8.
//
// @param s const uint8_t * string
// @param i string offset
// @see U8_FWD_1
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the next.
// (Post-incrementing iteration.)
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// @param s const uint8_t * string
// @param i int32_t string offset, must be i<length
// @param length int32_t string length
// @see U8_FWD_1_UNSAFE
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the n-th next one,
// i.e., move forward by n code points.
// (Post-incrementing iteration.)
// "Unsafe" macro, assumes well-formed UTF-8.
//
// @param s const uint8_t * string
// @param i string offset
// @param n number of code points to skip
// @see U8_FWD_N
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the n-th next one,
// i.e., move forward by n code points.
// (Post-incrementing iteration.)
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// @param s const uint8_t * string
// @param i int32_t string offset, must be i<length
// @param length int32_t string length
// @param n number of code points to skip
// @see U8_FWD_N_UNSAFE
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary
// at the start of a code point.
// If the offset points to a UTF-8 trail byte,
// then the offset is moved backward to the corresponding lead byte.
// Otherwise, it is not modified.
// "Unsafe" macro, assumes well-formed UTF-8.
//
// @param s const uint8_t * string
// @param i string offset
// @see U8_SET_CP_START
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary
// at the start of a code point.
// If the offset points to a UTF-8 trail byte,
// then the offset is moved backward to the corresponding lead byte.
// Otherwise, it is not modified.
//
// "Safe" macro, checks for illegal sequences and for string boundaries.
// Unlike U8_TRUNCATE_IF_INCOMPLETE(), this macro always reads s[i].
//
// @param s const uint8_t * string
// @param start int32_t starting string offset (usually 0)
// @param i int32_t string offset, must be start<=i
// @see U8_SET_CP_START_UNSAFE
// @see U8_TRUNCATE_IF_INCOMPLETE
// @stable ICU 2.4

// *
// If the string ends with a UTF-8 byte sequence that is valid so far
// but incomplete, then reduce the length of the string to end before
// the lead byte of that incomplete sequence.
// For example, if the string ends with E1 80, the length is reduced by 2.
//
// In all other cases (the string ends with a complete sequence, or it is not
// possible for any further trail byte to extend the trailing sequence)
// the length remains unchanged.
//
// Useful for processing text split across multiple buffers
// (save the incomplete sequence for later)
// and for optimizing iteration
// (check for string length only once per character).
//
// "Safe" macro, checks for illegal sequences and for string boundaries.
// Unlike U8_SET_CP_START(), this macro never reads s[length].
//
// (In UTF-16, simply check for U16_IS_LEAD(last code unit).)
//
// @param s const uint8_t * string
// @param start int32_t starting string offset (usually 0)
// @param length int32_t string length (usually start<=length)
// @see U8_SET_CP_START
// @stable ICU 61

// definitions with backward iteration --------------------------------------

// *
// Move the string offset from one code point boundary to the previous one
// and get the code point between them.
// (Pre-decrementing backward iteration.)
// "Unsafe" macro, assumes well-formed UTF-8.
//
// The input offset may be the same as the string length.
// If the offset is behind a multi-byte sequence, then the macro will read
// the whole sequence.
// If the offset is behind a lead byte, then that itself
// will be returned as the code point.
// The result is undefined if the offset is behind an illegal UTF-8 sequence.
//
// @param s const uint8_t * string
// @param i string offset
// @param c output UChar32 variable
// @see U8_PREV
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the previous one
// and get the code point between them.
// (Pre-decrementing backward iteration.)
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// The input offset may be the same as the string length.
// If the offset is behind a multi-byte sequence, then the macro will read
// the whole sequence.
// If the offset is behind a lead byte, then that itself
// will be returned as the code point.
// If the offset is behind an illegal UTF-8 sequence, then c is set to a negative value.
//
// @param s const uint8_t * string
// @param start int32_t starting string offset (usually 0)
// @param i int32_t string offset, must be start<i
// @param c output UChar32 variable, set to <0 in case of an error
// @see U8_PREV_UNSAFE
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the previous one
// and get the code point between them.
// (Pre-decrementing backward iteration.)
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// The input offset may be the same as the string length.
// If the offset is behind a multi-byte sequence, then the macro will read
// the whole sequence.
// If the offset is behind a lead byte, then that itself
// will be returned as the code point.
// If the offset is behind an illegal UTF-8 sequence, then c is set to U+FFFD.
//
// This macro does not distinguish between a real U+FFFD in the text
// and U+FFFD returned for an ill-formed sequence.
// Use U8_PREV() if that distinction is important.
//
// @param s const uint8_t * string
// @param start int32_t starting string offset (usually 0)
// @param i int32_t string offset, must be start<i
// @param c output UChar32 variable, set to U+FFFD in case of an error
// @see U8_PREV
// @stable ICU 51

// *
// Move the string offset from one code point boundary to the previous one.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Unsafe" macro, assumes well-formed UTF-8.
//
// @param s const uint8_t * string
// @param i string offset
// @see U8_BACK_1
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the previous one.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// @param s const uint8_t * string
// @param start int32_t starting string offset (usually 0)
// @param i int32_t string offset, must be start<i
// @see U8_BACK_1_UNSAFE
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the n-th one before it,
// i.e., move backward by n code points.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Unsafe" macro, assumes well-formed UTF-8.
//
// @param s const uint8_t * string
// @param i string offset
// @param n number of code points to skip
// @see U8_BACK_N
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the n-th one before it,
// i.e., move backward by n code points.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// @param s const uint8_t * string
// @param start int32_t index of the start of the string
// @param i int32_t string offset, must be start<i
// @param n number of code points to skip
// @see U8_BACK_N_UNSAFE
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary after a code point.
// If the offset is behind a partial multi-byte sequence,
// then the offset is incremented to behind the whole sequence.
// Otherwise, it is not modified.
// The input offset may be the same as the string length.
// "Unsafe" macro, assumes well-formed UTF-8.
//
// @param s const uint8_t * string
// @param i string offset
// @see U8_SET_CP_LIMIT
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary after a code point.
// If the offset is behind a partial multi-byte sequence,
// then the offset is incremented to behind the whole sequence.
// Otherwise, it is not modified.
// The input offset may be the same as the string length.
// "Safe" macro, checks for illegal sequences and for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// @param s const uint8_t * string
// @param start int32_t starting string offset (usually 0)
// @param i int32_t string offset, must be start<=i<=length
// @param length int32_t string length
// @see U8_SET_CP_LIMIT_UNSAFE
// @stable ICU 2.4

// © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
//
//
//   Copyright (C) 1999-2012, International Business Machines
//   Corporation and others.  All Rights Reserved.
//
//
//   file name:  utf16.h
//   encoding:   UTF-8
//   tab size:   8 (not used)
//   indentation:4
//
//   created on: 1999sep09
//   created by: Markus W. Scherer

// *
// \file
// \brief C API: 16-bit Unicode handling macros
//
// This file defines macros to deal with 16-bit Unicode (UTF-16) code units and strings.
//
// For more information see utf.h and the ICU User Guide Strings chapter
// (http://userguide.icu-project.org/strings).
//
// <em>Usage:</em>
// ICU coding guidelines for if() statements should be followed when using these macros.
// Compound statements (curly braces {}) must be used  for if-else-while...
// bodies and all macro statements should be terminated with semicolon.

// © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
//
//
//   Copyright (C) 1999-2015, International Business Machines
//   Corporation and others.  All Rights Reserved.
//
//
//   file name:  umachine.h
//   encoding:   UTF-8
//   tab size:   8 (not used)
//   indentation:4
//
//   created on: 1999sep13
//   created by: Markus W. Scherer
//
//   This file defines basic types and constants for ICU to be
//   platform-independent. umachine.h and utf.h are included into
//   utypes.h to provide all the general definitions for ICU.
//   All of these definitions used to be in utypes.h before
//   the UTF-handling macros made this unmaintainable.

// This file must exist in order for `utf8.h` and `utf16.h` to be used.

// single-code point definitions --------------------------------------------

// *
// Does this code unit alone encode a code point (BMP, not a surrogate)?
// @param c 16-bit code unit
// @return TRUE or FALSE
// @stable ICU 2.4

// *
// Is this code unit a lead surrogate (U+d800..U+dbff)?
// @param c 16-bit code unit
// @return TRUE or FALSE
// @stable ICU 2.4

// *
// Is this code unit a trail surrogate (U+dc00..U+dfff)?
// @param c 16-bit code unit
// @return TRUE or FALSE
// @stable ICU 2.4

// *
// Is this code unit a surrogate (U+d800..U+dfff)?
// @param c 16-bit code unit
// @return TRUE or FALSE
// @stable ICU 2.4

// *
// Assuming c is a surrogate code point (U16_IS_SURROGATE(c)),
// is it a lead surrogate?
// @param c 16-bit code unit
// @return TRUE or FALSE
// @stable ICU 2.4

// *
// Assuming c is a surrogate code point (U16_IS_SURROGATE(c)),
// is it a trail surrogate?
// @param c 16-bit code unit
// @return TRUE or FALSE
// @stable ICU 4.2

// *
// Helper constant for U16_GET_SUPPLEMENTARY.
// @internal

// *
// Get a supplementary code point value (U+10000..U+10ffff)
// from its lead and trail surrogates.
// The result is undefined if the input values are not
// lead and trail surrogates.
//
// @param lead lead surrogate (U+d800..U+dbff)
// @param trail trail surrogate (U+dc00..U+dfff)
// @return supplementary code point (U+10000..U+10ffff)
// @stable ICU 2.4

// *
// Get the lead surrogate (0xd800..0xdbff) for a
// supplementary code point (0x10000..0x10ffff).
// @param supplementary 32-bit code point (U+10000..U+10ffff)
// @return lead surrogate (U+d800..U+dbff) for supplementary
// @stable ICU 2.4

// *
// Get the trail surrogate (0xdc00..0xdfff) for a
// supplementary code point (0x10000..0x10ffff).
// @param supplementary 32-bit code point (U+10000..U+10ffff)
// @return trail surrogate (U+dc00..U+dfff) for supplementary
// @stable ICU 2.4

// *
// How many 16-bit code units are used to encode this Unicode code point? (1 or 2)
// The result is not defined if c is not a Unicode code point (U+0000..U+10ffff).
// @param c 32-bit code point
// @return 1 or 2
// @stable ICU 2.4

// *
// The maximum number of 16-bit code units per Unicode code point (U+0000..U+10ffff).
// @return 2
// @stable ICU 2.4

// *
// Get a code point from a string at a random-access offset,
// without changing the offset.
// "Unsafe" macro, assumes well-formed UTF-16.
//
// The offset may point to either the lead or trail surrogate unit
// for a supplementary code point, in which case the macro will read
// the adjacent matching surrogate as well.
// The result is undefined if the offset points to a single, unpaired surrogate.
// Iteration through a string is more efficient with U16_NEXT_UNSAFE or U16_NEXT.
//
// @param s const UChar * string
// @param i string offset
// @param c output UChar32 variable
// @see U16_GET
// @stable ICU 2.4

// *
// Get a code point from a string at a random-access offset,
// without changing the offset.
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The offset may point to either the lead or trail surrogate unit
// for a supplementary code point, in which case the macro will read
// the adjacent matching surrogate as well.
//
// The length can be negative for a NUL-terminated string.
//
// If the offset points to a single, unpaired surrogate, then
// c is set to that unpaired surrogate.
// Iteration through a string is more efficient with U16_NEXT_UNSAFE or U16_NEXT.
//
// @param s const UChar * string
// @param start starting string offset (usually 0)
// @param i string offset, must be start<=i<length
// @param length string length
// @param c output UChar32 variable
// @see U16_GET_UNSAFE
// @stable ICU 2.4

// *
// Get a code point from a string at a random-access offset,
// without changing the offset.
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The offset may point to either the lead or trail surrogate unit
// for a supplementary code point, in which case the macro will read
// the adjacent matching surrogate as well.
//
// The length can be negative for a NUL-terminated string.
//
// If the offset points to a single, unpaired surrogate, then
// c is set to U+FFFD.
// Iteration through a string is more efficient with U16_NEXT_UNSAFE or U16_NEXT_OR_FFFD.
//
// @param s const UChar * string
// @param start starting string offset (usually 0)
// @param i string offset, must be start<=i<length
// @param length string length
// @param c output UChar32 variable
// @see U16_GET_UNSAFE
// @stable ICU 60

// definitions with forward iteration ---------------------------------------

// *
// Get a code point from a string at a code point boundary offset,
// and advance the offset to the next code point boundary.
// (Post-incrementing forward iteration.)
// "Unsafe" macro, assumes well-formed UTF-16.
//
// The offset may point to the lead surrogate unit
// for a supplementary code point, in which case the macro will read
// the following trail surrogate as well.
// If the offset points to a trail surrogate, then that itself
// will be returned as the code point.
// The result is undefined if the offset points to a single, unpaired lead surrogate.
//
// @param s const UChar * string
// @param i string offset
// @param c output UChar32 variable
// @see U16_NEXT
// @stable ICU 2.4

// *
// Get a code point from a string at a code point boundary offset,
// and advance the offset to the next code point boundary.
// (Post-incrementing forward iteration.)
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// The offset may point to the lead surrogate unit
// for a supplementary code point, in which case the macro will read
// the following trail surrogate as well.
// If the offset points to a trail surrogate or
// to a single, unpaired lead surrogate, then c is set to that unpaired surrogate.
//
// @param s const UChar * string
// @param i string offset, must be i<length
// @param length string length
// @param c output UChar32 variable
// @see U16_NEXT_UNSAFE
// @stable ICU 2.4

// *
// Get a code point from a string at a code point boundary offset,
// and advance the offset to the next code point boundary.
// (Post-incrementing forward iteration.)
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// The offset may point to the lead surrogate unit
// for a supplementary code point, in which case the macro will read
// the following trail surrogate as well.
// If the offset points to a trail surrogate or
// to a single, unpaired lead surrogate, then c is set to U+FFFD.
//
// @param s const UChar * string
// @param i string offset, must be i<length
// @param length string length
// @param c output UChar32 variable
// @see U16_NEXT_UNSAFE
// @stable ICU 60

// *
// Append a code point to a string, overwriting 1 or 2 code units.
// The offset points to the current end of the string contents
// and is advanced (post-increment).
// "Unsafe" macro, assumes a valid code point and sufficient space in the string.
// Otherwise, the result is undefined.
//
// @param s const UChar * string buffer
// @param i string offset
// @param c code point to append
// @see U16_APPEND
// @stable ICU 2.4

// *
// Append a code point to a string, overwriting 1 or 2 code units.
// The offset points to the current end of the string contents
// and is advanced (post-increment).
// "Safe" macro, checks for a valid code point.
// If a surrogate pair is written, checks for sufficient space in the string.
// If the code point is not valid or a trail surrogate does not fit,
// then isError is set to TRUE.
//
// @param s const UChar * string buffer
// @param i string offset, must be i<capacity
// @param capacity size of the string buffer
// @param c code point to append
// @param isError output UBool set to TRUE if an error occurs, otherwise not modified
// @see U16_APPEND_UNSAFE
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the next.
// (Post-incrementing iteration.)
// "Unsafe" macro, assumes well-formed UTF-16.
//
// @param s const UChar * string
// @param i string offset
// @see U16_FWD_1
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the next.
// (Post-incrementing iteration.)
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// @param s const UChar * string
// @param i string offset, must be i<length
// @param length string length
// @see U16_FWD_1_UNSAFE
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the n-th next one,
// i.e., move forward by n code points.
// (Post-incrementing iteration.)
// "Unsafe" macro, assumes well-formed UTF-16.
//
// @param s const UChar * string
// @param i string offset
// @param n number of code points to skip
// @see U16_FWD_N
// @stable ICU 2.4

// *
// Advance the string offset from one code point boundary to the n-th next one,
// i.e., move forward by n code points.
// (Post-incrementing iteration.)
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// @param s const UChar * string
// @param i int32_t string offset, must be i<length
// @param length int32_t string length
// @param n number of code points to skip
// @see U16_FWD_N_UNSAFE
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary
// at the start of a code point.
// If the offset points to the trail surrogate of a surrogate pair,
// then the offset is decremented.
// Otherwise, it is not modified.
// "Unsafe" macro, assumes well-formed UTF-16.
//
// @param s const UChar * string
// @param i string offset
// @see U16_SET_CP_START
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary
// at the start of a code point.
// If the offset points to the trail surrogate of a surrogate pair,
// then the offset is decremented.
// Otherwise, it is not modified.
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// @param s const UChar * string
// @param start starting string offset (usually 0)
// @param i string offset, must be start<=i
// @see U16_SET_CP_START_UNSAFE
// @stable ICU 2.4

// definitions with backward iteration --------------------------------------

// *
// Move the string offset from one code point boundary to the previous one
// and get the code point between them.
// (Pre-decrementing backward iteration.)
// "Unsafe" macro, assumes well-formed UTF-16.
//
// The input offset may be the same as the string length.
// If the offset is behind a trail surrogate unit
// for a supplementary code point, then the macro will read
// the preceding lead surrogate as well.
// If the offset is behind a lead surrogate, then that itself
// will be returned as the code point.
// The result is undefined if the offset is behind a single, unpaired trail surrogate.
//
// @param s const UChar * string
// @param i string offset
// @param c output UChar32 variable
// @see U16_PREV
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the previous one
// and get the code point between them.
// (Pre-decrementing backward iteration.)
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The input offset may be the same as the string length.
// If the offset is behind a trail surrogate unit
// for a supplementary code point, then the macro will read
// the preceding lead surrogate as well.
// If the offset is behind a lead surrogate or behind a single, unpaired
// trail surrogate, then c is set to that unpaired surrogate.
//
// @param s const UChar * string
// @param start starting string offset (usually 0)
// @param i string offset, must be start<i
// @param c output UChar32 variable
// @see U16_PREV_UNSAFE
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the previous one
// and get the code point between them.
// (Pre-decrementing backward iteration.)
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The input offset may be the same as the string length.
// If the offset is behind a trail surrogate unit
// for a supplementary code point, then the macro will read
// the preceding lead surrogate as well.
// If the offset is behind a lead surrogate or behind a single, unpaired
// trail surrogate, then c is set to U+FFFD.
//
// @param s const UChar * string
// @param start starting string offset (usually 0)
// @param i string offset, must be start<i
// @param c output UChar32 variable
// @see U16_PREV_UNSAFE
// @stable ICU 60

// *
// Move the string offset from one code point boundary to the previous one.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Unsafe" macro, assumes well-formed UTF-16.
//
// @param s const UChar * string
// @param i string offset
// @see U16_BACK_1
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the previous one.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// @param s const UChar * string
// @param start starting string offset (usually 0)
// @param i string offset, must be start<i
// @see U16_BACK_1_UNSAFE
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the n-th one before it,
// i.e., move backward by n code points.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Unsafe" macro, assumes well-formed UTF-16.
//
// @param s const UChar * string
// @param i string offset
// @param n number of code points to skip
// @see U16_BACK_N
// @stable ICU 2.4

// *
// Move the string offset from one code point boundary to the n-th one before it,
// i.e., move backward by n code points.
// (Pre-decrementing backward iteration.)
// The input offset may be the same as the string length.
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// @param s const UChar * string
// @param start start of string
// @param i string offset, must be start<i
// @param n number of code points to skip
// @see U16_BACK_N_UNSAFE
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary after a code point.
// If the offset is behind the lead surrogate of a surrogate pair,
// then the offset is incremented.
// Otherwise, it is not modified.
// The input offset may be the same as the string length.
// "Unsafe" macro, assumes well-formed UTF-16.
//
// @param s const UChar * string
// @param i string offset
// @see U16_SET_CP_LIMIT
// @stable ICU 2.4

// *
// Adjust a random-access offset to a code point boundary after a code point.
// If the offset is behind the lead surrogate of a surrogate pair,
// then the offset is incremented.
// Otherwise, it is not modified.
// The input offset may be the same as the string length.
// "Safe" macro, handles unpaired surrogates and checks for string boundaries.
//
// The length can be negative for a NUL-terminated string.
//
// @param s const UChar * string
// @param start int32_t starting string offset (usually 0)
// @param i int32_t string offset, start<=i<=length
// @param length int32_t string length
// @see U16_SET_CP_LIMIT_UNSAFE
// @stable ICU 2.4

var sTS_DECODE_ERROR Int32_t = -1 /* unicode.h:16:22 */

// These functions read one unicode code point from the given string,
// returning the number of bytes consumed.
type UnicodeDecodeFunction = uintptr /* unicode.h:20:18 */

func ts_decode_utf8(tls *libc.TLS, string uintptr, length Uint32_t, code_point uintptr) Uint32_t { /* unicode.h:26:24: */
	var i Uint32_t = Uint32_t(0)
	for ok := true; ok; ok = 0 != 0 {
		(*(*Int32_t)(unsafe.Pointer(code_point))) = Int32_t(*(*Uint8_t)(unsafe.Pointer((string) + uintptr(libc.PostIncUint32(&(i), 1)))))
		if !(((*(*Int32_t)(unsafe.Pointer(code_point))) & 0x80) == 0) {
			var __t Uint8_t = Uint8_t(0)
			if ((((i) != (length)) && (func() int32 {
				if (*(*Int32_t)(unsafe.Pointer(code_point))) >= 0xe0 {
					return (libc.Bool32((func() int32 {
						if (*(*Int32_t)(unsafe.Pointer(code_point))) < 0xf0 {
							return (libc.Bool32(((int32(*(*int8)(unsafe.Pointer(ts + 597 /* " 000000000000\x1000" */ + uintptr(libc.AssignAndPtrInt32(code_point, 0xf))))) & (int32(1) << ((int32(libc.AssignUint8(&__t, *(*Uint8_t)(unsafe.Pointer((string) + uintptr(i)))))) >> 5))) != 0) && (func() bool { __t = Uint8_t(int32(__t) & (0x3f)); return 1 != 0 }())))
						}
						return (libc.Bool32(((((libc.AssignSubPtrInt32(code_point, 0xf0)) <= 4) && ((int32(*(*int8)(unsafe.Pointer(ts + 614 /* "\x00\x00\x00\x00\x00\x00\x00\x00\x1e\x0f\x0f\x0f\x00\x00\x00\x00" */ + uintptr(((int32(libc.AssignUint8(&__t, *(*Uint8_t)(unsafe.Pointer((string) + uintptr(i)))))) >> 4))))) & (int32(1) << (*(*Int32_t)(unsafe.Pointer(code_point))))) != 0)) && (func() bool {
							(*(*Int32_t)(unsafe.Pointer(code_point))) = (((*(*Int32_t)(unsafe.Pointer(code_point))) << 6) | (int32(__t) & 0x3f))
							return (libc.PreIncUint32(&(i), 1) != (length))
						}())) && ((int32(libc.AssignUint8(&__t, (Uint8_t(int32(*(*Uint8_t)(unsafe.Pointer((string) + uintptr(i)))) - 0x80))))) <= 0x3f)))
					}() != 0) && (func() bool {
						(*(*Int32_t)(unsafe.Pointer(code_point))) = (((*(*Int32_t)(unsafe.Pointer(code_point))) << 6) | Int32_t(__t))
						return (libc.PreIncUint32(&(i), 1) != (length))
					}())))
				}
				return (libc.Bool32(((*(*Int32_t)(unsafe.Pointer(code_point))) >= 0xc2) && (func() bool { *(*Int32_t)(unsafe.Pointer(code_point)) &= (0x1f); return 1 != 0 }())))
			}() != 0)) && ((int32(libc.AssignUint8(&__t, (Uint8_t(int32(*(*Uint8_t)(unsafe.Pointer((string) + uintptr(i)))) - 0x80))))) <= 0x3f)) && (func() bool {
				(*(*Int32_t)(unsafe.Pointer(code_point))) = (((*(*Int32_t)(unsafe.Pointer(code_point))) << 6) | Int32_t(__t))
				(i)++
				return 1 != 0
			}()) {
			} else {
				(*(*Int32_t)(unsafe.Pointer(code_point))) = -1 /* ill-formed*/
			}
		}
	}
	return i
}

func ts_decode_utf16(tls *libc.TLS, string uintptr, length Uint32_t, code_point uintptr) Uint32_t { /* unicode.h:36:24: */
	var i Uint32_t = Uint32_t(0)
	for ok := true; ok; ok = 0 != 0 {
		(*(*Int32_t)(unsafe.Pointer(code_point))) = Int32_t(*(*Uint16_t)(unsafe.Pointer((string) + uintptr(libc.PostIncUint32(&(i), 1))*2)))
		if ((uint32(*(*Int32_t)(unsafe.Pointer(code_point)))) & 0xfffffc00) == uint32(0xd800) {
			var __c2 Uint16_t
			if ((i) != (length)) && (((uint32(libc.AssignUint16(&__c2, *(*Uint16_t)(unsafe.Pointer((string) + uintptr(i)*2))))) & 0xfffffc00) == uint32(0xdc00)) {
				(i)++
				(*(*Int32_t)(unsafe.Pointer(code_point))) = ((((*(*Int32_t)(unsafe.Pointer(code_point))) << 10) + (UChar32(__c2))) - (((int32(0xd800) << 10) + 0xdc00) - 0x10000))
			}
		}
	}
	return (i * Uint32_t(2))
}

var sBYTE_ORDER_MARK Int32_t = 0xFEFF /* lexer.c:24:22 */

var sDEFAULT_RANGE = TSRange{End_point: TSPoint{Row: UINT32_MAX, Column: UINT32_MAX}, End_byte: UINT32_MAX,
} /* lexer.c:26:22 */

// Check if the lexer has reached EOF. This state is stored
// by setting the lexer's `current_included_range_index` such that
// it has consumed all of its available ranges.
func ts_lexer__eof(tls *libc.TLS, _self uintptr) uint8 { /* lexer.c:42:13: */
	var self uintptr = _self
	return (uint8(libc.Bool32((*Lexer)(unsafe.Pointer(self)).Current_included_range_index == (*Lexer)(unsafe.Pointer(self)).Included_range_count)))
}

// Clear the currently stored chunk of source code, because the lexer's
// position has changed.
func ts_lexer__clear_chunk(tls *libc.TLS, self uintptr) { /* lexer.c:49:13: */
	(*Lexer)(unsafe.Pointer(self)).Chunk = uintptr(0)
	(*Lexer)(unsafe.Pointer(self)).Chunk_size = Uint32_t(0)
	(*Lexer)(unsafe.Pointer(self)).Chunk_start = Uint32_t(0)
}

// Call the lexer's input callback to obtain a new chunk of source code
// for the current position.
func ts_lexer__get_chunk(tls *libc.TLS, self uintptr) { /* lexer.c:57:13: */
	(*Lexer)(unsafe.Pointer(self)).Chunk_start = (*Lexer)(unsafe.Pointer(self)).Current_position.Bytes
	(*Lexer)(unsafe.Pointer(self)).Chunk = (*struct {
		f func(*libc.TLS, uintptr, Uint32_t, TSPoint, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Lexer)(unsafe.Pointer(self)).Input.Read})).f(tls,
		(*Lexer)(unsafe.Pointer(self)).Input.Payload,
		(*Lexer)(unsafe.Pointer(self)).Current_position.Bytes,
		(*Lexer)(unsafe.Pointer(self)).Current_position.Extent,
		(self + 156 /* &.chunk_size */))
	if !(int32((*Lexer)(unsafe.Pointer(self)).Chunk_size) != 0) {
		(*Lexer)(unsafe.Pointer(self)).Current_included_range_index = (*Lexer)(unsafe.Pointer(self)).Included_range_count
		(*Lexer)(unsafe.Pointer(self)).Chunk = uintptr(0)
	}
}

// Decode the next unicode character in the current chunk of source code.
// This assumes that the lexer has already retrieved a chunk of source
// code that spans the current position.
func ts_lexer__get_lookahead(tls *libc.TLS, self uintptr) { /* lexer.c:74:13: */
	var position_in_chunk Uint32_t = ((*Lexer)(unsafe.Pointer(self)).Current_position.Bytes - (*Lexer)(unsafe.Pointer(self)).Chunk_start)
	var size Uint32_t = ((*Lexer)(unsafe.Pointer(self)).Chunk_size - position_in_chunk)

	if size == Uint32_t(0) {
		(*Lexer)(unsafe.Pointer(self)).Lookahead_size = Uint32_t(1)
		(*Lexer)(unsafe.Pointer(self)).Data.Lookahead = 0
		return
	}

	var chunk uintptr = ((*Lexer)(unsafe.Pointer(self)).Chunk + uintptr(position_in_chunk))
	var decode UnicodeDecodeFunction
	if (*Lexer)(unsafe.Pointer(self)).Input.Encoding == TSInputEncodingUTF8 {
		decode = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, Uint32_t, uintptr) Uint32_t
		}{ts_decode_utf8}))
	} else {
		decode = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, Uint32_t, uintptr) Uint32_t
		}{ts_decode_utf16}))
	}

	(*Lexer)(unsafe.Pointer(self)).Lookahead_size = (*struct {
		f func(*libc.TLS, uintptr, Uint32_t, uintptr) Uint32_t
	})(unsafe.Pointer(&struct{ uintptr }{decode})).f(tls, chunk, size, (self /* &.data */ /* &.lookahead */))

	// If this chunk ended in the middle of a multi-byte character,
	// try again with a fresh chunk.
	if ((*Lexer)(unsafe.Pointer(self)).Data.Lookahead == sTS_DECODE_ERROR) && (size < Uint32_t(4)) {
		ts_lexer__get_chunk(tls, self)
		chunk = (*Lexer)(unsafe.Pointer(self)).Chunk
		size = (*Lexer)(unsafe.Pointer(self)).Chunk_size
		(*Lexer)(unsafe.Pointer(self)).Lookahead_size = (*struct {
			f func(*libc.TLS, uintptr, Uint32_t, uintptr) Uint32_t
		})(unsafe.Pointer(&struct{ uintptr }{decode})).f(tls, chunk, size, (self /* &.data */ /* &.lookahead */))
	}

	if (*Lexer)(unsafe.Pointer(self)).Data.Lookahead == sTS_DECODE_ERROR {
		(*Lexer)(unsafe.Pointer(self)).Lookahead_size = Uint32_t(1)
	}
}

func ts_lexer_goto(tls *libc.TLS, self uintptr, position Length) { /* lexer.c:105:13: */
	(*Lexer)(unsafe.Pointer(self)).Current_position = position
	var found_included_range uint8 = uint8(False)

	// Move to the first valid position at or after the given position.
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*Lexer)(unsafe.Pointer(self)).Included_range_count) {
			goto __3
		}
		{
			var included_range uintptr = ((*Lexer)(unsafe.Pointer(self)).Included_ranges + uintptr(i)*24)
			if (*TSRange)(unsafe.Pointer(included_range)).End_byte > position.Bytes {
				if (*TSRange)(unsafe.Pointer(included_range)).Start_byte > position.Bytes {
					(*Lexer)(unsafe.Pointer(self)).Current_position = Length{Bytes: (*TSRange)(unsafe.Pointer(included_range)).Start_byte, Extent: (*TSRange)(unsafe.Pointer(included_range)).Start_point}
				}

				(*Lexer)(unsafe.Pointer(self)).Current_included_range_index = i
				found_included_range = uint8(True)
				goto __3
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	if found_included_range != 0 {
		// If the current position is outside of the current chunk of text,
		// then clear out the current chunk of text.
		if ((*Lexer)(unsafe.Pointer(self)).Chunk != 0) && ((position.Bytes < (*Lexer)(unsafe.Pointer(self)).Chunk_start) || (position.Bytes >= ((*Lexer)(unsafe.Pointer(self)).Chunk_start + (*Lexer)(unsafe.Pointer(self)).Chunk_size))) {
			ts_lexer__clear_chunk(tls, self)
		}

		(*Lexer)(unsafe.Pointer(self)).Lookahead_size = Uint32_t(0)
		(*Lexer)(unsafe.Pointer(self)).Data.Lookahead = 0
	} else {
		(*Lexer)(unsafe.Pointer(self)).Current_included_range_index = (*Lexer)(unsafe.Pointer(self)).Included_range_count
		var last_included_range uintptr = ((*Lexer)(unsafe.Pointer(self)).Included_ranges + uintptr(((*Lexer)(unsafe.Pointer(self)).Included_range_count-Uint32_t(1)))*24)
		(*Lexer)(unsafe.Pointer(self)).Current_position = Length{Bytes: (*TSRange)(unsafe.Pointer(last_included_range)).End_byte, Extent: (*TSRange)(unsafe.Pointer(last_included_range)).End_point}
		ts_lexer__clear_chunk(tls, self)
		(*Lexer)(unsafe.Pointer(self)).Lookahead_size = Uint32_t(1)
		(*Lexer)(unsafe.Pointer(self)).Data.Lookahead = 0
	}
}

// Advance to the next character in the source code, retrieving a new
// chunk of source code if needed.
func ts_lexer__advance(tls *libc.TLS, _self uintptr, skip uint8) { /* lexer.c:157:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var self uintptr = _self
	if !(int32((*Lexer)(unsafe.Pointer(self)).Chunk) != 0) {
		return
	}

	if skip != 0 {
		if (*Lexer)(unsafe.Pointer(self)).Logger.Log != 0 {
			libc.X__builtin___snprintf_chk(tls, self+165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self+165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), func() uintptr {
				if (32 <= (*Lexer)(unsafe.Pointer(self)).Data.Lookahead) && ((*Lexer)(unsafe.Pointer(self)).Data.Lookahead < 127) {
					return ts + 631 /* "skip character:'..." */
				}
				return ts + 651 /* "skip character:%..." */
			}(), libc.VaList(bp, (*Lexer)(unsafe.Pointer(self)).Data.Lookahead))
			(*struct {
				f func(*libc.TLS, uintptr, TSLogType, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Lexer)(unsafe.Pointer(self)).Logger.Log})).f(tls, (*Lexer)(unsafe.Pointer(self)).Logger.Payload, TSLogTypeLex, self+165 /* &.debug_buffer */)
		}

	} else {
		if (*Lexer)(unsafe.Pointer(self)).Logger.Log != 0 {
			libc.X__builtin___snprintf_chk(tls, self+165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self+165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), func() uintptr {
				if (32 <= (*Lexer)(unsafe.Pointer(self)).Data.Lookahead) && ((*Lexer)(unsafe.Pointer(self)).Data.Lookahead < 127) {
					return ts + 669 /* "consume characte..." */
				}
				return ts + 692 /* "consume characte..." */
			}(), libc.VaList(bp+8, (*Lexer)(unsafe.Pointer(self)).Data.Lookahead))
			(*struct {
				f func(*libc.TLS, uintptr, TSLogType, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Lexer)(unsafe.Pointer(self)).Logger.Log})).f(tls, (*Lexer)(unsafe.Pointer(self)).Logger.Payload, TSLogTypeLex, self+165 /* &.debug_buffer */)
		}

	}

	if (*Lexer)(unsafe.Pointer(self)).Lookahead_size != 0 {
		*(*Uint32_t)(unsafe.Pointer(self + 48 /* &.current_position */ /* &.bytes */)) += ((*Lexer)(unsafe.Pointer(self)).Lookahead_size)
		if (*Lexer)(unsafe.Pointer(self)).Data.Lookahead == '\n' {
			(*Lexer)(unsafe.Pointer(self)).Current_position.Extent.Row++
			(*Lexer)(unsafe.Pointer(self)).Current_position.Extent.Column = Uint32_t(0)
		} else {
			*(*Uint32_t)(unsafe.Pointer(self + 48 /* &.current_position */ + 4 /* &.extent */ + 4 /* &.column */)) += ((*Lexer)(unsafe.Pointer(self)).Lookahead_size)
		}
	}

	var current_range uintptr = uintptr(0)
	if (*Lexer)(unsafe.Pointer(self)).Current_included_range_index < (*Lexer)(unsafe.Pointer(self)).Included_range_count {
		current_range = ((*Lexer)(unsafe.Pointer(self)).Included_ranges + uintptr((*Lexer)(unsafe.Pointer(self)).Current_included_range_index)*24)
		if (*Lexer)(unsafe.Pointer(self)).Current_position.Bytes == (*TSRange)(unsafe.Pointer(current_range)).End_byte {
			(*Lexer)(unsafe.Pointer(self)).Current_included_range_index++
			if (*Lexer)(unsafe.Pointer(self)).Current_included_range_index < (*Lexer)(unsafe.Pointer(self)).Included_range_count {
				current_range += 24
				(*Lexer)(unsafe.Pointer(self)).Current_position = Length{
					Bytes:  (*TSRange)(unsafe.Pointer(current_range)).Start_byte,
					Extent: (*TSRange)(unsafe.Pointer(current_range)).Start_point}
			} else {
				current_range = uintptr(0)
			}
		}
	}

	if skip != 0 {
		(*Lexer)(unsafe.Pointer(self)).Token_start_position = (*Lexer)(unsafe.Pointer(self)).Current_position
	}

	if current_range != 0 {
		if (*Lexer)(unsafe.Pointer(self)).Current_position.Bytes >= ((*Lexer)(unsafe.Pointer(self)).Chunk_start + (*Lexer)(unsafe.Pointer(self)).Chunk_size) {
			ts_lexer__get_chunk(tls, self)
		}
		ts_lexer__get_lookahead(tls, self)
	} else {
		ts_lexer__clear_chunk(tls, self)
		(*Lexer)(unsafe.Pointer(self)).Data.Lookahead = 0
		(*Lexer)(unsafe.Pointer(self)).Lookahead_size = Uint32_t(1)
	}
}

// Mark that a token match has completed. This can be called multiple
// times if a longer match is found later.
func ts_lexer__mark_end(tls *libc.TLS, _self uintptr) { /* lexer.c:210:13: */
	var self uintptr = _self
	if !(ts_lexer__eof(tls, (self /* &.data */)) != 0) {
		// If the lexer is right at the beginning of included range,
		// then the token should be considered to end at the *end* of the
		// previous included range, rather than here.
		var current_included_range uintptr = ((*Lexer)(unsafe.Pointer(self)).Included_ranges + uintptr((*Lexer)(unsafe.Pointer(self)).Current_included_range_index)*24)
		if ((*Lexer)(unsafe.Pointer(self)).Current_included_range_index > Uint32_t(0)) && ((*Lexer)(unsafe.Pointer(self)).Current_position.Bytes == (*TSRange)(unsafe.Pointer(current_included_range)).Start_byte) {
			var previous_included_range uintptr = (current_included_range - uintptr(1)*24)
			(*Lexer)(unsafe.Pointer(self)).Token_end_position = Length{
				Bytes:  (*TSRange)(unsafe.Pointer(previous_included_range)).End_byte,
				Extent: (*TSRange)(unsafe.Pointer(previous_included_range)).End_point}
			return
		}
	}
	(*Lexer)(unsafe.Pointer(self)).Token_end_position = (*Lexer)(unsafe.Pointer(self)).Current_position
}

func ts_lexer__get_column(tls *libc.TLS, _self uintptr) Uint32_t { /* lexer.c:234:17: */
	var self uintptr = _self
	(*Lexer)(unsafe.Pointer(self)).Did_get_column = uint8(True)
	return (*Lexer)(unsafe.Pointer(self)).Current_position.Extent.Column
}

// Is the lexer at a boundary between two disjoint included ranges of
// source code? This is exposed as an API because some languages' external
// scanners need to perform custom actions at these boundaries.
func ts_lexer__is_at_included_range_start(tls *libc.TLS, _self uintptr) uint8 { /* lexer.c:243:13: */
	var self uintptr = _self
	if (*Lexer)(unsafe.Pointer(self)).Current_included_range_index < (*Lexer)(unsafe.Pointer(self)).Included_range_count {
		var current_range uintptr = ((*Lexer)(unsafe.Pointer(self)).Included_ranges + uintptr((*Lexer)(unsafe.Pointer(self)).Current_included_range_index)*24)
		return (uint8(libc.Bool32((*Lexer)(unsafe.Pointer(self)).Current_position.Bytes == (*TSRange)(unsafe.Pointer(current_range)).Start_byte)))
	} else {
		return uint8(False)
	}
	return uint8(0)
}

func Xts_lexer_init(tls *libc.TLS, self uintptr) { /* lexer.c:253:6: */
	*(*Lexer)(unsafe.Pointer(self)) = Lexer{Data: TSLexer{Advance: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uint8)
	}{ts_lexer__advance})), Mark_end: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{ts_lexer__mark_end})), Get_column: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) Uint32_t
	}{ts_lexer__get_column})), Is_at_included_range_start: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uint8
	}{ts_lexer__is_at_included_range_start})), Eof: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uint8
	}{ts_lexer__eof}))}}
	Xts_lexer_set_included_ranges(tls, self, uintptr(0), uint32(0))
}

func Xts_lexer_delete(tls *libc.TLS, self uintptr) { /* lexer.c:282:6: */
	ts_free_default(tls, (*Lexer)(unsafe.Pointer(self)).Included_ranges)
}

func Xts_lexer_set_input(tls *libc.TLS, self uintptr, input TSInput) { /* lexer.c:286:6: */
	(*Lexer)(unsafe.Pointer(self)).Input = input
	ts_lexer__clear_chunk(tls, self)
	ts_lexer_goto(tls, self, (*Lexer)(unsafe.Pointer(self)).Current_position)
}

// Move the lexer to the given position. This doesn't do any work
// if the parser is already at the given position.
func Xts_lexer_reset(tls *libc.TLS, self uintptr, position Length) { /* lexer.c:294:6: */
	if position.Bytes != (*Lexer)(unsafe.Pointer(self)).Current_position.Bytes {
		ts_lexer_goto(tls, self, position)
	}
}

func Xts_lexer_start(tls *libc.TLS, self uintptr) { /* lexer.c:300:6: */
	(*Lexer)(unsafe.Pointer(self)).Token_start_position = (*Lexer)(unsafe.Pointer(self)).Current_position
	(*Lexer)(unsafe.Pointer(self)).Token_end_position = sLENGTH_UNDEFINED2
	(*Lexer)(unsafe.Pointer(self)).Data.Result_symbol = TSSymbol(0)
	(*Lexer)(unsafe.Pointer(self)).Did_get_column = uint8(False)
	if !(ts_lexer__eof(tls, (self /* &.data */)) != 0) {
		if !(int32((*Lexer)(unsafe.Pointer(self)).Chunk_size) != 0) {
			ts_lexer__get_chunk(tls, self)
		}
		if !(int32((*Lexer)(unsafe.Pointer(self)).Lookahead_size) != 0) {
			ts_lexer__get_lookahead(tls, self)
		}
		if ((*Lexer)(unsafe.Pointer(self)).Current_position.Bytes == Uint32_t(0)) && ((*Lexer)(unsafe.Pointer(self)).Data.Lookahead == sBYTE_ORDER_MARK) {
			ts_lexer__advance(tls, (self /* &.data */), uint8(True))
		}
	}
}

func Xts_lexer_finish(tls *libc.TLS, self uintptr, lookahead_end_byte uintptr) { /* lexer.c:315:6: */
	if length_is_undefined(tls, (*Lexer)(unsafe.Pointer(self)).Token_end_position) != 0 {
		ts_lexer__mark_end(tls, (self /* &.data */))
	}

	var current_lookahead_end_byte Uint32_t = ((*Lexer)(unsafe.Pointer(self)).Current_position.Bytes + Uint32_t(1))

	// In order to determine that a byte sequence is invalid UTF8 or UTF16,
	// the character decoding algorithm may have looked at the following byte.
	// Therefore, the next byte *after* the current (invalid) character
	// affects the interpretation of the current character.
	if (*Lexer)(unsafe.Pointer(self)).Data.Lookahead == sTS_DECODE_ERROR {
		current_lookahead_end_byte++
	}

	if current_lookahead_end_byte > *(*Uint32_t)(unsafe.Pointer(lookahead_end_byte)) {
		*(*Uint32_t)(unsafe.Pointer(lookahead_end_byte)) = current_lookahead_end_byte
	}
}

func Xts_lexer_advance_to_end(tls *libc.TLS, self uintptr) { /* lexer.c:335:6: */
	for (*Lexer)(unsafe.Pointer(self)).Chunk != 0 {
		ts_lexer__advance(tls, (self /* &.data */), uint8(False))
	}
}

func Xts_lexer_mark_end(tls *libc.TLS, self uintptr) { /* lexer.c:341:6: */
	ts_lexer__mark_end(tls, (self /* &.data */))
}

func Xts_lexer_set_included_ranges(tls *libc.TLS, self uintptr, ranges uintptr, count Uint32_t) uint8 { /* lexer.c:345:6: */
	if (count == Uint32_t(0)) || !(ranges != 0) {
		ranges = uintptr(unsafe.Pointer(&sDEFAULT_RANGE))
		count = Uint32_t(1)
	} else {
		var previous_byte Uint32_t = Uint32_t(0)
		{
			var i uint32 = uint32(0)
		__1:
			if !(i < count) {
				goto __3
			}
			{
				var range1 uintptr = (ranges + uintptr(i)*24)
				if ((*TSRange)(unsafe.Pointer(range1)).Start_byte < previous_byte) || ((*TSRange)(unsafe.Pointer(range1)).End_byte < (*TSRange)(unsafe.Pointer(range1)).Start_byte) {
					return uint8(False)
				}
				previous_byte = (*TSRange)(unsafe.Pointer(range1)).End_byte

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	var size Size_t = (uint64(count) * uint64(unsafe.Sizeof(TSRange{})))
	(*Lexer)(unsafe.Pointer(self)).Included_ranges = ts_realloc_default(tls, (*Lexer)(unsafe.Pointer(self)).Included_ranges, size)
	libc.X__builtin___memcpy_chk(tls, (*Lexer)(unsafe.Pointer(self)).Included_ranges, ranges, size, libc.X__builtin_object_size(tls, (*Lexer)(unsafe.Pointer(self)).Included_ranges, 0))
	(*Lexer)(unsafe.Pointer(self)).Included_range_count = count
	ts_lexer_goto(tls, self, (*Lexer)(unsafe.Pointer(self)).Current_position)
	return uint8(True)
}

func Xts_lexer_included_ranges(tls *libc.TLS, self uintptr, count uintptr) uintptr { /* lexer.c:373:9: */
	*(*Uint32_t)(unsafe.Pointer(count)) = (*Lexer)(unsafe.Pointer(self)).Included_range_count
	return (*Lexer)(unsafe.Pointer(self)).Included_ranges
}

type TSParser = STSParser           /* api.h:39:25 */
type TSTree = STSTree               /* api.h:40:23 */
type TSQuery = STSQuery             /* api.h:41:24 */
type TSQueryCursor = STSQueryCursor /* api.h:42:30 */

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

type ParentCacheEntry = struct {
	Child        uintptr
	Parent       uintptr
	Position     Length
	Alias_symbol TSSymbol
	__ccgo_pad1  [2]byte
} /* tree.h:13:3 */

type NodeChildIterator = struct {
	Parent                 Subtree
	Tree                   uintptr
	Position               Length
	Child_index            Uint32_t
	Structural_child_index Uint32_t
	__ccgo_pad1            [4]byte
	Alias_sequence         uintptr
} /* node.c:13:3 */

// TSNode - constructors

func Xts_node_new(tls *libc.TLS, tree uintptr, subtree uintptr, position Length, alias TSSymbol) TSNode { /* node.c:17:8: */
	return TSNode{
		Context: [4]Uint32_t{position.Bytes, position.Extent.Row, position.Extent.Column, Uint32_t(alias)},
		Id:      subtree,
		Tree:    tree}
}

func ts_node__null(tls *libc.TLS) TSNode { /* node.c:30:22: */
	return Xts_node_new(tls, uintptr(0), uintptr(0), length_zero(tls), uint16(0))
}

// TSNode - accessors

func Xts_node_start_byte(tls *libc.TLS, self TSNode) Uint32_t { /* node.c:36:10: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TSNode)(unsafe.Pointer(bp)) = self

	return *(*Uint32_t)(unsafe.Pointer((bp /* &self */ /* &.context */)))
}

func Xts_node_start_point(tls *libc.TLS, self TSNode) TSPoint { /* node.c:40:9: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TSNode)(unsafe.Pointer(bp)) = self

	return TSPoint{Row: *(*Uint32_t)(unsafe.Pointer((bp /* &self */ /* &.context */) + 1*4)), Column: *(*Uint32_t)(unsafe.Pointer((bp /* &self */ /* &.context */) + 2*4))}
}

func ts_node__alias(tls *libc.TLS, self uintptr) Uint32_t { /* node.c:44:24: */
	return *(*Uint32_t)(unsafe.Pointer((self /* &.context */) + 3*4))
}

func ts_node__subtree(tls *libc.TLS, self TSNode) Subtree { /* node.c:48:23: */
	return *(*Subtree)(unsafe.Pointer(self.Id))
}

// NodeChildIterator

func ts_node_iterate_children(tls *libc.TLS, node uintptr) NodeChildIterator { /* node.c:54:33: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Subtree)(unsafe.Pointer(bp /* subtree */)) = ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(node)))
	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* subtree */))) == Uint32_t(0) {
		return NodeChildIterator{Tree: (*TSNode)(unsafe.Pointer(node)).Tree, Position: length_zero(tls)}
	}
	var alias_sequence uintptr = ts_language_alias_sequence(tls,
		(*TSTree)(unsafe.Pointer((*TSNode)(unsafe.Pointer(node)).Tree)).Language,
		uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &subtree */)) + 68))))
	return NodeChildIterator{Parent: *(*Subtree)(unsafe.Pointer(bp /* subtree */)), Tree: (*TSNode)(unsafe.Pointer(node)).Tree, Position: Length{Bytes: Xts_node_start_byte(tls, *(*TSNode)(unsafe.Pointer(node))), Extent: Xts_node_start_point(tls, *(*TSNode)(unsafe.Pointer(node)))}, Alias_sequence: alias_sequence}
}

func ts_node_child_iterator_done(tls *libc.TLS, self uintptr) uint8 { /* node.c:73:20: */
	return (uint8(libc.Bool32((*NodeChildIterator)(unsafe.Pointer(self)).Child_index == (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* &.parent */)))).Child_count)))
}

func ts_node_child_iterator_next(tls *libc.TLS, self uintptr, result uintptr) uint8 { /* node.c:77:20: */
	if !(int32(*(*uintptr)(unsafe.Pointer(self /* &.parent */))) != 0) || (ts_node_child_iterator_done(tls, self) != 0) {
		return uint8(False)
	}
	var child uintptr = ((func() uintptr {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(self /* &.parent */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return uintptr(0)
		}
		return ((*(*uintptr)(unsafe.Pointer(self /* &.parent */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* &.parent */)))).Child_count)*16)
	}()) + uintptr((*NodeChildIterator)(unsafe.Pointer(self)).Child_index)*16)
	var alias_symbol TSSymbol = TSSymbol(0)
	if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(child))) != 0) {
		if (*NodeChildIterator)(unsafe.Pointer(self)).Alias_sequence != 0 {
			alias_symbol = *(*TSSymbol)(unsafe.Pointer((*NodeChildIterator)(unsafe.Pointer(self)).Alias_sequence + uintptr((*NodeChildIterator)(unsafe.Pointer(self)).Structural_child_index)*2))
		}
		(*NodeChildIterator)(unsafe.Pointer(self)).Structural_child_index++
	}
	if (*NodeChildIterator)(unsafe.Pointer(self)).Child_index > Uint32_t(0) {
		(*NodeChildIterator)(unsafe.Pointer(self)).Position = length_add(tls, (*NodeChildIterator)(unsafe.Pointer(self)).Position, ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(child))))
	}
	*(*TSNode)(unsafe.Pointer(result)) = Xts_node_new(tls,
		(*NodeChildIterator)(unsafe.Pointer(self)).Tree,
		child,
		(*NodeChildIterator)(unsafe.Pointer(self)).Position,
		alias_symbol)
	(*NodeChildIterator)(unsafe.Pointer(self)).Position = length_add(tls, (*NodeChildIterator)(unsafe.Pointer(self)).Position, ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(child))))
	(*NodeChildIterator)(unsafe.Pointer(self)).Child_index++
	return uint8(True)
}

// TSNode - private

func ts_node__is_relevant(tls *libc.TLS, self TSNode, include_anonymous uint8) uint8 { /* node.c:106:20: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TSNode)(unsafe.Pointer(bp)) = self

	var tree = ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp /* self */)))
	if include_anonymous != 0 {
		return (uint8(libc.Bool32((ts_subtree_visible(tls, tree) != 0) || (ts_node__alias(tls, bp /* &self */) != 0))))
	} else {
		var alias TSSymbol = TSSymbol(ts_node__alias(tls, bp /* &self */))
		if alias != 0 {
			return Xts_language_symbol_metadata(tls, (*TSTree)(unsafe.Pointer((*TSNode)(unsafe.Pointer(bp /* &self */)).Tree)).Language, alias).Named
		} else {
			return (uint8(libc.Bool32((ts_subtree_visible(tls, tree) != 0) && (ts_subtree_named(tls, tree) != 0))))
		}
	}
	return uint8(0)
}

func ts_node__relevant_child_count(tls *libc.TLS, self TSNode, include_anonymous uint8) Uint32_t { /* node.c:120:24: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Subtree)(unsafe.Pointer(bp /* tree */)) = ts_node__subtree(tls, self)
	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */))) > Uint32_t(0) {
		if include_anonymous != 0 {
			return *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)) + 48))
		} else {
			return *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)) + 52))
		}
	} else {
		return Uint32_t(0)
	}
	return Uint32_t(0)
}

func ts_node__child(tls *libc.TLS, self TSNode, child_index Uint32_t, include_anonymous uint8) TSNode { /* node.c:136:22: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*TSNode)(unsafe.Pointer(bp /* result */)) = self
	var did_descend uint8 = uint8(True)

	for did_descend != 0 {
		did_descend = uint8(False)
		// var child TSNode at bp+88, 32

		var index Uint32_t = Uint32_t(0)
		*(*NodeChildIterator)(unsafe.Pointer(bp + 32 /* iterator */)) = ts_node_iterate_children(tls, bp /* &result */)
		for ts_node_child_iterator_next(tls, bp+32 /* &iterator */, bp+88 /* &child */) != 0 {
			if ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), include_anonymous) != 0 {
				if index == child_index {
					return *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				}
				index++
			} else {
				var grandchild_index Uint32_t = (child_index - index)
				var grandchild_count Uint32_t = ts_node__relevant_child_count(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), include_anonymous)
				if grandchild_index < grandchild_count {
					did_descend = uint8(True)
					*(*TSNode)(unsafe.Pointer(bp /* result */)) = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
					child_index = grandchild_index
					break
				}
				index = index + (grandchild_count)
			}
		}
	}

	return ts_node__null(tls)
}

func ts_subtree_has_trailing_empty_descendant(tls *libc.TLS, self Subtree, other Subtree) uint8 { /* node.c:173:13: */
	bp := tls.Alloc(48)
	defer tls.Free(48)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	*(*Subtree)(unsafe.Pointer(bp + 32)) = other

	{
		var i uint32 = (ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* self */))) - Uint32_t(1))
	__1:
		if !((i + uint32(1)) > uint32(0)) {
			goto __3
		}
		{
			*(*Subtree)(unsafe.Pointer(bp + 16 /* child */)) = *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp /* &self */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count)*16)
			}()) + uintptr(i)*16))
			if ts_subtree_total_bytes(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) > Uint32_t(0) {
				goto __3
			}
			if (*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)) == *(*uintptr)(unsafe.Pointer(bp + 32 /* &other */))) || (ts_subtree_has_trailing_empty_descendant(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */)), *(*Subtree)(unsafe.Pointer(bp + 32 /* other */))) != 0) {
				return uint8(True)
			}

		}
		goto __2
	__2:
		i--
		goto __1
		goto __3
	__3:
		;
	}
	return uint8(False)
}

func ts_node__prev_sibling(tls *libc.TLS, self TSNode, include_anonymous uint8) TSNode { /* node.c:187:22: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var self_subtree = ts_node__subtree(tls, self)
	var self_is_empty uint8 = (uint8(libc.Bool32(ts_subtree_total_bytes(tls, self_subtree) == Uint32_t(0))))
	var target_end_byte Uint32_t = Xts_node_end_byte(tls, self)

	*(*TSNode)(unsafe.Pointer(bp /* node */)) = Xts_node_parent(tls, self)
	var earlier_node = ts_node__null(tls)
	var earlier_node_is_relevant uint8 = uint8(False)

	for !(Xts_node_is_null(tls, *(*TSNode)(unsafe.Pointer(bp /* node */))) != 0) {
		var earlier_child = ts_node__null(tls)
		var earlier_child_is_relevant uint8 = uint8(False)
		var found_child_containing_target uint8 = uint8(False)
		// var child TSNode at bp+88, 32

		*(*NodeChildIterator)(unsafe.Pointer(bp + 32 /* iterator */)) = ts_node_iterate_children(tls, bp /* &node */)
		for ts_node_child_iterator_next(tls, bp+32 /* &iterator */, bp+88 /* &child */) != 0 {
			if (*TSNode)(unsafe.Pointer(bp+88 /* &child */)).Id == self.Id {
				break
			}
			if (*NodeChildIterator)(unsafe.Pointer(bp+32 /* &iterator */)).Position.Bytes > target_end_byte {
				found_child_containing_target = uint8(True)
				break
			}

			if ((*NodeChildIterator)(unsafe.Pointer(bp+32 /* &iterator */)).Position.Bytes == target_end_byte) && (!(self_is_empty != 0) || (ts_subtree_has_trailing_empty_descendant(tls, ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))), self_subtree) != 0)) {
				found_child_containing_target = uint8(True)
				break
			}

			if ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), include_anonymous) != 0 {
				earlier_child = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				earlier_child_is_relevant = uint8(True)
			} else if ts_node__relevant_child_count(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), include_anonymous) > Uint32_t(0) {
				earlier_child = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				earlier_child_is_relevant = uint8(False)
			}
		}

		if found_child_containing_target != 0 {
			if !(Xts_node_is_null(tls, earlier_child) != 0) {
				earlier_node = earlier_child
				earlier_node_is_relevant = earlier_child_is_relevant
			}
			*(*TSNode)(unsafe.Pointer(bp /* node */)) = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
		} else if earlier_child_is_relevant != 0 {
			return earlier_child
		} else if !(Xts_node_is_null(tls, earlier_child) != 0) {
			*(*TSNode)(unsafe.Pointer(bp /* node */)) = earlier_child
		} else if earlier_node_is_relevant != 0 {
			return earlier_node
		} else {
			*(*TSNode)(unsafe.Pointer(bp /* node */)) = earlier_node
		}
	}

	return ts_node__null(tls)
}

func ts_node__next_sibling(tls *libc.TLS, self TSNode, include_anonymous uint8) TSNode { /* node.c:246:22: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var target_end_byte Uint32_t = Xts_node_end_byte(tls, self)

	*(*TSNode)(unsafe.Pointer(bp /* node */)) = Xts_node_parent(tls, self)
	var later_node = ts_node__null(tls)
	var later_node_is_relevant uint8 = uint8(False)

	for !(Xts_node_is_null(tls, *(*TSNode)(unsafe.Pointer(bp /* node */))) != 0) {
		var later_child = ts_node__null(tls)
		var later_child_is_relevant uint8 = uint8(False)
		var child_containing_target = ts_node__null(tls)
		// var child TSNode at bp+88, 32

		*(*NodeChildIterator)(unsafe.Pointer(bp + 32 /* iterator */)) = ts_node_iterate_children(tls, bp /* &node */)
		for ts_node_child_iterator_next(tls, bp+32 /* &iterator */, bp+88 /* &child */) != 0 {
			if (*NodeChildIterator)(unsafe.Pointer(bp+32 /* &iterator */)).Position.Bytes < target_end_byte {
				continue
			}
			if Xts_node_start_byte(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))) <= Xts_node_start_byte(tls, self) {
				if *(*uintptr)(unsafe.Pointer(func() uintptr {
					*(*Subtree)(unsafe.Pointer(bp + 120)) = ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)))
					return bp + 120
				}())) != *(*uintptr)(unsafe.Pointer(func() uintptr { *(*Subtree)(unsafe.Pointer(bp + 136)) = ts_node__subtree(tls, self); return bp + 136 }())) {
					child_containing_target = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				}
			} else if ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), include_anonymous) != 0 {
				later_child = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				later_child_is_relevant = uint8(True)
				break
			} else if ts_node__relevant_child_count(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), include_anonymous) > Uint32_t(0) {
				later_child = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				later_child_is_relevant = uint8(False)
				break
			}
		}

		if !(Xts_node_is_null(tls, child_containing_target) != 0) {
			if !(Xts_node_is_null(tls, later_child) != 0) {
				later_node = later_child
				later_node_is_relevant = later_child_is_relevant
			}
			*(*TSNode)(unsafe.Pointer(bp /* node */)) = child_containing_target
		} else if later_child_is_relevant != 0 {
			return later_child
		} else if !(Xts_node_is_null(tls, later_child) != 0) {
			*(*TSNode)(unsafe.Pointer(bp /* node */)) = later_child
		} else if later_node_is_relevant != 0 {
			return later_node
		} else {
			*(*TSNode)(unsafe.Pointer(bp /* node */)) = later_node
		}
	}

	return ts_node__null(tls)
}

func ts_node__first_child_for_byte(tls *libc.TLS, self TSNode, goal Uint32_t, include_anonymous uint8) TSNode { /* node.c:297:22: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*TSNode)(unsafe.Pointer(bp /* node */)) = self
	var did_descend uint8 = uint8(True)

	for did_descend != 0 {
		did_descend = uint8(False)
		// var child TSNode at bp+88, 32

		*(*NodeChildIterator)(unsafe.Pointer(bp + 32 /* iterator */)) = ts_node_iterate_children(tls, bp /* &node */)
		for ts_node_child_iterator_next(tls, bp+32 /* &iterator */, bp+88 /* &child */) != 0 {
			if Xts_node_end_byte(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))) > goal {
				if ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), include_anonymous) != 0 {
					return *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				} else if Xts_node_child_count(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))) > Uint32_t(0) {
					did_descend = uint8(True)
					*(*TSNode)(unsafe.Pointer(bp /* node */)) = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
					break
				}
			}
		}
	}

	return ts_node__null(tls)
}

func ts_node__descendant_for_byte_range(tls *libc.TLS, self TSNode, range_start Uint32_t, range_end Uint32_t, include_anonymous uint8) TSNode { /* node.c:326:22: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*TSNode)(unsafe.Pointer(bp /* node */)) = self
	var last_visible_node = self

	var did_descend uint8 = uint8(True)
	for did_descend != 0 {
		did_descend = uint8(False)
		// var child TSNode at bp+88, 32

		*(*NodeChildIterator)(unsafe.Pointer(bp + 32 /* iterator */)) = ts_node_iterate_children(tls, bp /* &node */)
		for ts_node_child_iterator_next(tls, bp+32 /* &iterator */, bp+88 /* &child */) != 0 {
			var node_end Uint32_t = (*NodeChildIterator)(unsafe.Pointer(bp + 32 /* &iterator */)).Position.Bytes

			// The end of this node must extend far enough forward to touch
			// the end of the range and exceed the start of the range.
			if node_end < range_end {
				continue
			}
			if node_end <= range_start {
				continue
			}

			// The start of this node must extend far enough backward to
			// touch the start of the range.
			if range_start < Xts_node_start_byte(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))) {
				break
			}

			*(*TSNode)(unsafe.Pointer(bp /* node */)) = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
			if ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp /* node */)), include_anonymous) != 0 {
				last_visible_node = *(*TSNode)(unsafe.Pointer(bp /* node */))
			}
			did_descend = uint8(True)
			break
		}
	}

	return last_visible_node
}

func ts_node__descendant_for_point_range(tls *libc.TLS, self TSNode, range_start TSPoint, range_end TSPoint, include_anonymous uint8) TSNode { /* node.c:365:22: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*TSNode)(unsafe.Pointer(bp /* node */)) = self
	var last_visible_node = self

	var did_descend uint8 = uint8(True)
	for did_descend != 0 {
		did_descend = uint8(False)
		// var child TSNode at bp+88, 32

		*(*NodeChildIterator)(unsafe.Pointer(bp + 32 /* iterator */)) = ts_node_iterate_children(tls, bp /* &node */)
		for ts_node_child_iterator_next(tls, bp+32 /* &iterator */, bp+88 /* &child */) != 0 {
			var node_end = (*NodeChildIterator)(unsafe.Pointer(bp + 32 /* &iterator */)).Position.Extent

			// The end of this node must extend far enough forward to touch
			// the end of the range and exceed the start of the range.
			if point_lt(tls, node_end, range_end) != 0 {
				continue
			}
			if point_lte(tls, node_end, range_start) != 0 {
				continue
			}

			// The start of this node must extend far enough backward to
			// touch the start of the range.
			if point_lt(tls, range_start, Xts_node_start_point(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)))) != 0 {
				break
			}

			*(*TSNode)(unsafe.Pointer(bp /* node */)) = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
			if ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp /* node */)), include_anonymous) != 0 {
				last_visible_node = *(*TSNode)(unsafe.Pointer(bp /* node */))
			}
			did_descend = uint8(True)
			break
		}
	}

	return last_visible_node
}

// TSNode - public

func Xts_node_end_byte(tls *libc.TLS, self TSNode) Uint32_t { /* node.c:406:10: */
	return (Xts_node_start_byte(tls, self) + ts_subtree_size(tls, ts_node__subtree(tls, self)).Bytes)
}

func Xts_node_end_point(tls *libc.TLS, self TSNode) TSPoint { /* node.c:410:9: */
	return point_add(tls, Xts_node_start_point(tls, self), ts_subtree_size(tls, ts_node__subtree(tls, self)).Extent)
}

func Xts_node_symbol(tls *libc.TLS, self TSNode) TSSymbol { /* node.c:414:10: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TSNode)(unsafe.Pointer(bp)) = self

	var symbol TSSymbol = TSSymbol(ts_node__alias(tls, bp /* &self */))
	if !(symbol != 0) {
		symbol = ts_subtree_symbol(tls, ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp /* self */))))
	}
	return Xts_language_public_symbol(tls, (*TSTree)(unsafe.Pointer((*TSNode)(unsafe.Pointer(bp /* &self */)).Tree)).Language, symbol)
}

func Xts_node_type(tls *libc.TLS, self TSNode) uintptr { /* node.c:420:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TSNode)(unsafe.Pointer(bp)) = self

	var symbol TSSymbol = TSSymbol(ts_node__alias(tls, bp /* &self */))
	if !(symbol != 0) {
		symbol = ts_subtree_symbol(tls, ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp /* self */))))
	}
	return Xts_language_symbol_name(tls, (*TSTree)(unsafe.Pointer((*TSNode)(unsafe.Pointer(bp /* &self */)).Tree)).Language, symbol)
}

func Xts_node_string(tls *libc.TLS, self TSNode) uintptr { /* node.c:426:6: */
	return Xts_subtree_string(tls, ts_node__subtree(tls, self), (*TSTree)(unsafe.Pointer(self.Tree)).Language, uint8(False))
}

func Xts_node_eq(tls *libc.TLS, self TSNode, other TSNode) uint8 { /* node.c:430:6: */
	return (uint8(libc.Bool32((self.Tree == other.Tree) && (self.Id == other.Id))))
}

func Xts_node_is_null(tls *libc.TLS, self TSNode) uint8 { /* node.c:434:6: */
	return (uint8(libc.Bool32(self.Id == uintptr(0))))
}

func Xts_node_is_extra(tls *libc.TLS, self TSNode) uint8 { /* node.c:438:6: */
	return ts_subtree_extra(tls, ts_node__subtree(tls, self))
}

func Xts_node_is_named(tls *libc.TLS, self TSNode) uint8 { /* node.c:442:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TSNode)(unsafe.Pointer(bp)) = self

	var alias TSSymbol = TSSymbol(ts_node__alias(tls, bp /* &self */))
	if alias != 0 {
		return Xts_language_symbol_metadata(tls, (*TSTree)(unsafe.Pointer((*TSNode)(unsafe.Pointer(bp /* &self */)).Tree)).Language, alias).Named
	}
	return ts_subtree_named(tls, ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp /* self */))))
}

func Xts_node_is_missing(tls *libc.TLS, self TSNode) uint8 { /* node.c:449:6: */
	return ts_subtree_missing(tls, ts_node__subtree(tls, self))
}

func Xts_node_has_changes(tls *libc.TLS, self TSNode) uint8 { /* node.c:453:6: */
	return ts_subtree_has_changes(tls, ts_node__subtree(tls, self))
}

func Xts_node_has_error(tls *libc.TLS, self TSNode) uint8 { /* node.c:457:6: */
	return (uint8(libc.Bool32(ts_subtree_error_cost(tls, ts_node__subtree(tls, self)) > Uint32_t(0))))
}

func Xts_node_parent(tls *libc.TLS, self TSNode) TSNode { /* node.c:461:8: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*TSNode)(unsafe.Pointer(bp /* node */)) = Xts_tree_root_node(tls, self.Tree)
	var end_byte Uint32_t = Xts_node_end_byte(tls, self)
	if (*TSNode)(unsafe.Pointer(bp /* &node */)).Id == self.Id {
		return ts_node__null(tls)
	}

	var last_visible_node = *(*TSNode)(unsafe.Pointer(bp /* node */))
	var did_descend uint8 = uint8(True)
	for did_descend != 0 {
		did_descend = uint8(False)
		// var child TSNode at bp+88, 32

		*(*NodeChildIterator)(unsafe.Pointer(bp + 32 /* iterator */)) = ts_node_iterate_children(tls, bp /* &node */)
		for ts_node_child_iterator_next(tls, bp+32 /* &iterator */, bp+88 /* &child */) != 0 {
			if (Xts_node_start_byte(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))) > Xts_node_start_byte(tls, self)) || ((*TSNode)(unsafe.Pointer(bp+88 /* &child */)).Id == self.Id) {
				break
			}
			if (*NodeChildIterator)(unsafe.Pointer(bp+32 /* &iterator */)).Position.Bytes >= end_byte {
				*(*TSNode)(unsafe.Pointer(bp /* node */)) = *(*TSNode)(unsafe.Pointer(bp + 88 /* child */))
				if ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp + 88 /* child */)), uint8(True)) != 0 {
					last_visible_node = *(*TSNode)(unsafe.Pointer(bp /* node */))
				}
				did_descend = uint8(True)
				break
			}
		}
	}

	return last_visible_node
}

func Xts_node_child(tls *libc.TLS, self TSNode, child_index Uint32_t) TSNode { /* node.c:492:8: */
	return ts_node__child(tls, self, child_index, uint8(True))
}

func Xts_node_named_child(tls *libc.TLS, self TSNode, child_index Uint32_t) TSNode { /* node.c:496:8: */
	return ts_node__child(tls, self, child_index, uint8(False))
}

func Xts_node_child_by_field_id(tls *libc.TLS, self TSNode, field_id TSFieldId) TSNode { /* node.c:500:8: */
	bp := tls.Alloc(152)
	defer tls.Free(152)
	*(*TSNode)(unsafe.Pointer(bp + 32)) = self

	// var field_map uintptr at bp+16, 8

	// var field_map_end uintptr at bp+24, 8

	// var child TSNode at bp+120, 32

	// var iterator NodeChildIterator at bp+64, 56

	var result TSNode
	var index Uint32_t
recur:
	if !(!(field_id != 0) || (Xts_node_child_count(tls, *(*TSNode)(unsafe.Pointer(bp + 32 /* self */))) == Uint32_t(0))) {
		goto __1
	}
	return ts_node__null(tls)
__1:
	;
	ts_language_field_map(tls,
		(*TSTree)(unsafe.Pointer((*TSNode)(unsafe.Pointer(bp+32 /* &self */)).Tree)).Language,
		uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(func() uintptr {
			*(*Subtree)(unsafe.Pointer(bp)) = ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp + 32 /* self */)))
			return bp
		}())) + 68))),
		bp+16, /* &field_map */
		bp+24 /* &field_map_end */)
	if !(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) == *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
		goto __2
	}
	return ts_node__null(tls)
__2:
	;

	// The field mappings are sorted by their field id. Scan all
	// the mappings to find the ones for the given field id.
__3:
	if !(int32((*TSFieldMapEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)))).Field_id) < int32(field_id)) {
		goto __4
	}
	*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) += 4
	if !(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) == *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
		goto __5
	}
	return ts_node__null(tls)
__5:
	;
	goto __3
__4:
	;
__6:
	if !(int32((*TSFieldMapEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))+libc.UintptrFromInt32(-1)*4)).Field_id) > int32(field_id)) {
		goto __7
	}
	*(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */)) -= 4
	if !(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) == *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
		goto __8
	}
	return ts_node__null(tls)
__8:
	;
	goto __6
__7:
	;
	*(*NodeChildIterator)(unsafe.Pointer(bp + 64 /* iterator */)) = ts_node_iterate_children(tls, bp+32 /* &self */)
__9:
	if !(ts_node_child_iterator_next(tls, bp+64 /* &iterator */, bp+120 /* &child */) != 0) {
		goto __10
	}
	if !(!(ts_subtree_extra(tls, ts_node__subtree(tls, *(*TSNode)(unsafe.Pointer(bp + 120 /* child */)))) != 0)) {
		goto __11
	}
	index = ((*NodeChildIterator)(unsafe.Pointer(bp+64 /* &iterator */)).Structural_child_index - Uint32_t(1))
	if !(index < Uint32_t((*TSFieldMapEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)))).Child_index)) {
		goto __12
	}
	goto __9
__12:
	;

	// Hidden nodes' fields are "inherited" by their visible parent.
	if !((*TSFieldMapEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)))).Inherited != 0) {
		goto __13
	}

	// If this is the *last* possible child node for this field,
	// then perform a tail call to avoid recursion.
	if !((*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) + uintptr(1)*4) == *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
		goto __15
	}
	*(*TSNode)(unsafe.Pointer(bp + 32 /* self */)) = *(*TSNode)(unsafe.Pointer(bp + 120 /* child */))
	goto recur
	goto __16
__15:
	result = Xts_node_child_by_field_id(tls, *(*TSNode)(unsafe.Pointer(bp + 120 /* child */)), field_id)
	if !(result.Id != 0) {
		goto __17
	}
	return result
__17:
	;
	*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) += 4
	if !(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) == *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
		goto __18
	}
	return ts_node__null(tls)
__18:
	;
__16:
	;
	goto __14
__13:
	if !(ts_node__is_relevant(tls, *(*TSNode)(unsafe.Pointer(bp + 120 /* child */)), uint8(True)) != 0) {
		goto __19
	}
	return *(*TSNode)(unsafe.Pointer(bp + 120 /* child */))
	goto __20
__19:
	if !(Xts_node_child_count(tls, *(*TSNode)(unsafe.Pointer(bp + 120 /* child */))) > Uint32_t(0)) {
		goto __21
	}
	return Xts_node_child(tls, *(*TSNode)(unsafe.Pointer(bp + 120 /* child */)), uint32(0))
	goto __22
__21:
	*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) += 4
	if !(*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */)) == *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
		goto __23
	}
	return ts_node__null(tls)
__23:
	;
__22:
	;
__20:
	;
__14:
	;
__11:
	;
	goto __9
__10:
	;

	return ts_node__null(tls)
}

func Xts_node_field_name_for_child(tls *libc.TLS, self TSNode, child_index Uint32_t) uintptr { /* node.c:572:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*uintptr)(unsafe.Pointer(bp + 16 /* field_map_start */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */)) = uintptr(0)
	ts_language_field_map(tls,
		(*TSTree)(unsafe.Pointer(self.Tree)).Language,
		uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(func() uintptr { *(*Subtree)(unsafe.Pointer(bp)) = ts_node__subtree(tls, self); return bp }())) + 68))),
		bp+16, /* &field_map_start */
		bp+24 /* &field_map_end */)

	{
		var i uintptr = *(*uintptr)(unsafe.Pointer(bp + 16 /* field_map_start */))
	__1:
		if !(i < *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
			goto __3
		}
		{
			if Uint32_t((*TSFieldMapEntry)(unsafe.Pointer(i)).Child_index) == child_index {
				return *(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSTree)(unsafe.Pointer(self.Tree)).Language)).Field_names + uintptr((*TSFieldMapEntry)(unsafe.Pointer(i)).Field_id)*8))
			}

		}
		goto __2
	__2:
		i += 4
		goto __1
		goto __3
	__3:
		;
	}
	return uintptr(0)
}

func Xts_node_child_by_field_name(tls *libc.TLS, self TSNode, name uintptr, name_length Uint32_t) TSNode { /* node.c:589:8: */
	var field_id TSFieldId = Xts_language_field_id_for_name(tls,
		(*TSTree)(unsafe.Pointer(self.Tree)).Language,
		name,
		name_length)
	return Xts_node_child_by_field_id(tls, self, field_id)
}

func Xts_node_child_count(tls *libc.TLS, self TSNode) Uint32_t { /* node.c:602:10: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Subtree)(unsafe.Pointer(bp /* tree */)) = ts_node__subtree(tls, self)
	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */))) > Uint32_t(0) {
		return *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)) + 48))
	} else {
		return Uint32_t(0)
	}
	return Uint32_t(0)
}

func Xts_node_named_child_count(tls *libc.TLS, self TSNode) Uint32_t { /* node.c:611:10: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Subtree)(unsafe.Pointer(bp /* tree */)) = ts_node__subtree(tls, self)
	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */))) > Uint32_t(0) {
		return *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)) + 52))
	} else {
		return Uint32_t(0)
	}
	return Uint32_t(0)
}

func Xts_node_next_sibling(tls *libc.TLS, self TSNode) TSNode { /* node.c:620:8: */
	return ts_node__next_sibling(tls, self, uint8(True))
}

func Xts_node_next_named_sibling(tls *libc.TLS, self TSNode) TSNode { /* node.c:624:8: */
	return ts_node__next_sibling(tls, self, uint8(False))
}

func Xts_node_prev_sibling(tls *libc.TLS, self TSNode) TSNode { /* node.c:628:8: */
	return ts_node__prev_sibling(tls, self, uint8(True))
}

func Xts_node_prev_named_sibling(tls *libc.TLS, self TSNode) TSNode { /* node.c:632:8: */
	return ts_node__prev_sibling(tls, self, uint8(False))
}

func Xts_node_first_child_for_byte(tls *libc.TLS, self TSNode, byte Uint32_t) TSNode { /* node.c:636:8: */
	return ts_node__first_child_for_byte(tls, self, byte, uint8(True))
}

func Xts_node_first_named_child_for_byte(tls *libc.TLS, self TSNode, byte Uint32_t) TSNode { /* node.c:640:8: */
	return ts_node__first_child_for_byte(tls, self, byte, uint8(False))
}

func Xts_node_descendant_for_byte_range(tls *libc.TLS, self TSNode, start Uint32_t, end Uint32_t) TSNode { /* node.c:644:8: */
	return ts_node__descendant_for_byte_range(tls, self, start, end, uint8(True))
}

func Xts_node_named_descendant_for_byte_range(tls *libc.TLS, self TSNode, start Uint32_t, end Uint32_t) TSNode { /* node.c:652:8: */
	return ts_node__descendant_for_byte_range(tls, self, start, end, uint8(False))
}

func Xts_node_descendant_for_point_range(tls *libc.TLS, self TSNode, start TSPoint, end TSPoint) TSNode { /* node.c:660:8: */
	return ts_node__descendant_for_point_range(tls, self, start, end, uint8(True))
}

func Xts_node_named_descendant_for_point_range(tls *libc.TLS, self TSNode, start TSPoint, end TSPoint) TSNode { /* node.c:668:8: */
	return ts_node__descendant_for_point_range(tls, self, start, end, uint8(False))
}

func Xts_node_edit(tls *libc.TLS, self uintptr, edit uintptr) { /* node.c:676:6: */
	var start_byte Uint32_t = Xts_node_start_byte(tls, *(*TSNode)(unsafe.Pointer(self)))
	var start_point = Xts_node_start_point(tls, *(*TSNode)(unsafe.Pointer(self)))

	if start_byte >= (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_byte {
		start_byte = ((*TSInputEdit)(unsafe.Pointer(edit)).New_end_byte + (start_byte - (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_byte))
		start_point = point_add(tls, (*TSInputEdit)(unsafe.Pointer(edit)).New_end_point, point_sub(tls, start_point, (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_point))
	} else if start_byte > (*TSInputEdit)(unsafe.Pointer(edit)).Start_byte {
		start_byte = (*TSInputEdit)(unsafe.Pointer(edit)).New_end_byte
		start_point = (*TSInputEdit)(unsafe.Pointer(edit)).New_end_point
	}

	*(*Uint32_t)(unsafe.Pointer((self /* &.context */))) = start_byte
	*(*Uint32_t)(unsafe.Pointer((self /* &.context */) + 1*4)) = start_point.Row
	*(*Uint32_t)(unsafe.Pointer((self /* &.context */) + 2*4)) = start_point.Column
}

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.3 (Berkeley) 1/21/94

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Clock_t = X__darwin_clock_t /* _clock_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Time_t = X__darwin_time_t /* _time_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type Stimespec = struct {
	Tv_sec  X__darwin_time_t
	Tv_nsec int64
} /* _timespec.h:33:1 */

type Stm = struct {
	Tm_sec      int32
	Tm_min      int32
	Tm_hour     int32
	Tm_mday     int32
	Tm_mon      int32
	Tm_year     int32
	Tm_wday     int32
	Tm_yday     int32
	Tm_isdst    int32
	__ccgo_pad1 [4]byte
	Tm_gmtoff   int64
	Tm_zone     uintptr
} /* time.h:75:1 */

type Clockid_t = uint32 /* time.h:172:3 */

// 8462256: modified __assert_rtn() replaces deprecated __eprintf()

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (C) 1992-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

func atomic_load(tls *libc.TLS, p uintptr) Size_t { /* atomic.h:40:22: */
	return Size_t(libc.AtomicLoadNUint64(p, 0))
}

func atomic_inc(tls *libc.TLS, p uintptr) Uint32_t { /* atomic.h:48:24: */
	return libc.X__sync_add_and_fetch_uint32(tls, p, 1)
}

func atomic_dec(tls *libc.TLS, p uintptr) Uint32_t { /* atomic.h:52:24: */
	return libc.X__sync_sub_and_fetch_uint32(tls, p, 1)
}

type TSDuration = Uint64_t /* clock.h:6:18 */

// macOS or POSIX without monotonic clock support
// * Represent a time as a process clock value.
// * Represent a duration as a number of process clock ticks.
//
// On these platforms, parse timeouts may be affected by other processes,
// which is not ideal, but is better than using a non-monotonic time API
// like `gettimeofday`.

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.3 (Berkeley) 1/21/94

type TSClock = Uint64_t /* clock.h:109:18 */

func duration_from_micros(tls *libc.TLS, micros Uint64_t) TSDuration { /* clock.h:111:26: */
	return ((micros * uint64(CLOCKS_PER_SEC)) / uint64(1000000))
}

func duration_to_micros(tls *libc.TLS, self TSDuration) Uint64_t { /* clock.h:115:24: */
	return ((self * uint64(1000000)) / uint64(CLOCKS_PER_SEC))
}

func clock_null(tls *libc.TLS) TSClock { /* clock.h:119:23: */
	return uint64(0)
}

func clock_now(tls *libc.TLS) TSClock { /* clock.h:123:23: */
	return Uint64_t(libc.Xclock(tls))
}

func clock_after(tls *libc.TLS, base TSClock, duration TSDuration) TSClock { /* clock.h:127:23: */
	return (base + duration)
}

func clock_is_null(tls *libc.TLS, self TSClock) uint8 { /* clock.h:131:20: */
	return libc.BoolUint8(!(self != 0))
}

func clock_is_gt(tls *libc.TLS, self TSClock, other TSClock) uint8 { /* clock.h:135:20: */
	return (uint8(libc.Bool32(self > other)))
}

type ReduceAction = struct {
	Count              Uint32_t
	Symbol             TSSymbol
	__ccgo_pad1        [2]byte
	Dynamic_precedence int32
	Production_id      uint16
	__ccgo_pad2        [2]byte
} /* reduce_action.h:16:3 */

type ReduceActionSet = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* reduce_action.h:18:29 */

func ts_reduce_action_set_add(tls *libc.TLS, self uintptr, new_action ReduceAction) { /* reduce_action.h:20:20: */
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < (*ReduceActionSet)(unsafe.Pointer(self)).Size) {
			goto __3
		}
		{
			var action = *(*ReduceAction)(unsafe.Pointer((*ReduceActionSet)(unsafe.Pointer(self)).Contents + uintptr(i)*16))
			if (int32(action.Symbol) == int32(new_action.Symbol)) && (action.Count == new_action.Count) {
				return
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	array__grow(tls, self, uint64(1), uint64(unsafe.Sizeof(ReduceAction{})))
	*(*ReduceAction)(unsafe.Pointer((*ReduceActionSet)(unsafe.Pointer((self))).Contents + uintptr(libc.PostIncUint32(&(*ReduceActionSet)(unsafe.Pointer(self)).Size, 1))*16)) = new_action
}

type StackEntry = struct {
	Tree        Subtree
	Child_index Uint32_t
	Byte_offset Uint32_t
} /* reusable_node.h:7:3 */

type ReusableNode = struct {
	Stack struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Last_external_token Subtree
} /* reusable_node.h:12:3 */

func reusable_node_new(tls *libc.TLS) ReusableNode { /* reusable_node.h:14:28: */
	return ReusableNode{}
}

func reusable_node_clear(tls *libc.TLS, self uintptr) { /* reusable_node.h:18:20: */
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.stack */))).Size = Uint32_t(0)
	(*ReusableNode)(unsafe.Pointer(self)).Last_external_token = Subtree{}
}

func reusable_node_tree(tls *libc.TLS, self uintptr) Subtree { /* reusable_node.h:23:23: */
	if (*ReusableNode)(unsafe.Pointer(self)).Stack.Size > Uint32_t(0) {
		return (*StackEntry)(unsafe.Pointer((*ReusableNode)(unsafe.Pointer(self)).Stack.Contents + uintptr(((*ReusableNode)(unsafe.Pointer(self)).Stack.Size-Uint32_t(1)))*24)).Tree
	}
	return Subtree{}
}

func reusable_node_byte_offset(tls *libc.TLS, self uintptr) Uint32_t { /* reusable_node.h:29:24: */
	if (*ReusableNode)(unsafe.Pointer(self)).Stack.Size > Uint32_t(0) {
		return (*StackEntry)(unsafe.Pointer((*ReusableNode)(unsafe.Pointer(self)).Stack.Contents + uintptr(((*ReusableNode)(unsafe.Pointer(self)).Stack.Size-Uint32_t(1)))*24)).Byte_offset
	}
	return UINT32_MAX
}

func reusable_node_delete(tls *libc.TLS, self uintptr) { /* reusable_node.h:35:20: */
	array__delete(tls, (self /* &.stack */))
}

func reusable_node_advance(tls *libc.TLS, self uintptr) { /* reusable_node.h:39:20: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var last_entry = *(*StackEntry)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__68)), ts+713 /* "upstream/tree-si..." */, 40, ts+758 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size-Uint32_t(1)))*24)
	}()))
	var byte_offset Uint32_t = (last_entry.Byte_offset + ts_subtree_total_bytes(tls, last_entry.Tree))
	if ts_subtree_has_external_tokens(tls, last_entry.Tree) != 0 {
		(*ReusableNode)(unsafe.Pointer(self)).Last_external_token = Xts_subtree_last_external_token(tls, last_entry.Tree)
	}
	// var tree Subtree at bp, 16

	var next_index Uint32_t
	for ok := true; ok; ok = (ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */))) <= next_index) {
		var popped_entry = *(*StackEntry)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Contents + uintptr(libc.PreDecUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size, 1))*24))
		next_index = (popped_entry.Child_index + Uint32_t(1))
		if (*ReusableNode)(unsafe.Pointer(self)).Stack.Size == Uint32_t(0) {
			return
		}
		*(*Subtree)(unsafe.Pointer(bp /* tree */)) = (*StackEntry)(unsafe.Pointer(func() uintptr {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.stack */))).Size-Uint32_t(1)) < (*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.stack */))).Size)), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__68)), ts+713 /* "upstream/tree-si..." */, 52, ts+758 /* "(uint32_t)(&self..." */)
			} else {
			}
			return ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.stack */))).Contents + uintptr(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self /* &.stack */))).Size-Uint32_t(1)))*24)
		}())).Tree
	}

	array__grow(tls, (self /* &.stack */), uint64(1), uint64(unsafe.Sizeof(StackEntry{})))
	*(*StackEntry)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.stack */))).Size, 1))*24)) = StackEntry{Tree: *(*Subtree)(unsafe.Pointer((func() uintptr {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return uintptr(0)
		}
		return ((*(*uintptr)(unsafe.Pointer(bp /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count)*16)
	}()) + uintptr(next_index)*16)), Child_index: next_index, Byte_offset: byte_offset}
}

var __func__68 = *(*[22]int8)(unsafe.Pointer(ts + 816 /* "reusable_node_ad..." */)) /* reusable_node.h:39:62 */

func reusable_node_descend(tls *libc.TLS, self uintptr) uint8 { /* reusable_node.h:62:20: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*StackEntry)(unsafe.Pointer(bp /* last_entry */)) = *(*StackEntry)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__69)), ts+713 /* "upstream/tree-si..." */, 63, ts+758 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size-Uint32_t(1)))*24)
	}()))
	if ts_subtree_child_count(tls, (*StackEntry)(unsafe.Pointer(bp /* &last_entry */)).Tree) > Uint32_t(0) {
		array__grow(tls, (self /* &.stack */), uint64(1), uint64(unsafe.Sizeof(StackEntry{})))
		*(*StackEntry)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.stack */))).Size, 1))*24)) = StackEntry{Tree: *(*Subtree)(unsafe.Pointer((func() uintptr {
			if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &last_entry */ /* &.tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
				return uintptr(0)
			}
			return ((*(*uintptr)(unsafe.Pointer(bp /* &last_entry */ /* &.tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &last_entry */ /* &.tree */)))).Child_count)*16)
		}()))), Byte_offset: (*StackEntry)(unsafe.Pointer(bp /* &last_entry */)).Byte_offset}
		return uint8(True)
	} else {
		return uint8(False)
	}
	return uint8(0)
}

var __func__69 = *(*[22]int8)(unsafe.Pointer(ts + 838 /* "reusable_node_de..." */)) /* reusable_node.h:62:62 */

func reusable_node_advance_past_leaf(tls *libc.TLS, self uintptr) { /* reusable_node.h:76:20: */
	for reusable_node_descend(tls, self) != 0 {
	}
	reusable_node_advance(tls, self)
}

func reusable_node_reset(tls *libc.TLS, self uintptr, tree Subtree) { /* reusable_node.h:81:20: */
	reusable_node_clear(tls, self)
	array__grow(tls, (self /* &.stack */), uint64(1), uint64(unsafe.Sizeof(StackEntry{})))
	*(*StackEntry)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.stack */))).Size, 1))*24)) = StackEntry{Tree: tree}

	// Never reuse the root node, because it has a non-standard internal structure
	// due to transformations that are applied when it is accepted: adding the EOF
	// child and any extra children.
	if !(reusable_node_descend(tls, self) != 0) {
		reusable_node_clear(tls, self)
	}
}

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

type SStack = struct {
	Heads struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Slices    StackSliceArray
	Iterators struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Node_pool    StackNodeArray
	Base_node    uintptr
	Subtree_pool uintptr
} /* api.h:39:9 */

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

type Stack = SStack /* stack.h:13:22 */

type StackVersion = uint32 /* stack.h:15:18 */

type StackSlice = struct {
	Subtrees    SubtreeArray
	Version     StackVersion
	__ccgo_pad1 [4]byte
} /* stack.h:21:3 */
type StackSliceArray = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* stack.h:22:27 */

type StackSummaryEntry = struct {
	Position    Length
	Depth       uint32
	State       TSStateId
	__ccgo_pad1 [2]byte
} /* stack.h:28:3 */
type StackSummary = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* stack.h:29:34 */

type StackIterateCallback = uintptr /* stack.h:127:14 */

var sMAX_VERSION_COUNT uint32 = uint32(6)                                    /* parser.c:74:23 */
var sMAX_VERSION_COUNT_OVERFLOW uint32 = uint32(4)                           /* parser.c:75:23 */
var sMAX_SUMMARY_DEPTH uint32 = uint32(16)                                   /* parser.c:76:23 */
var sMAX_COST_DIFFERENCE uint32 = (uint32(16 * ERROR_COST_PER_SKIPPED_TREE)) /* parser.c:77:23 */
var sOP_COUNT_PER_TIMEOUT_CHECK uint32 = uint32(100)                         /* parser.c:78:23 */

type TokenCache = struct {
	Token               Subtree
	Last_external_token Subtree
	Byte_index          Uint32_t
	__ccgo_pad1         [4]byte
} /* parser.c:84:3 */

type ErrorStatus = struct {
	Cost               uint32
	Node_count         uint32
	Dynamic_precedence int32
	Is_in_error        uint8
	__ccgo_pad1        [3]byte
} /* parser.c:115:3 */

type ErrorComparison = uint32 /* parser.c:123:3 */

type TSStringInput = struct {
	String      uintptr
	Length      Uint32_t
	__ccgo_pad1 [4]byte
} /* parser.c:128:3 */

// StringInput

func ts_string_input_read(tls *libc.TLS, _self uintptr, byte Uint32_t, pt TSPoint, length uintptr) uintptr { /* parser.c:132:19: */
	_ = pt
	var self uintptr = _self
	if byte >= (*TSStringInput)(unsafe.Pointer(self)).Length {
		*(*Uint32_t)(unsafe.Pointer(length)) = Uint32_t(0)
		return ts + 860 /* "" */
	} else {
		*(*Uint32_t)(unsafe.Pointer(length)) = ((*TSStringInput)(unsafe.Pointer(self)).Length - byte)
		return ((*TSStringInput)(unsafe.Pointer(self)).String + uintptr(byte))
	}
	return uintptr(0)
}

// Parser - Private

func ts_parser__log(tls *libc.TLS, self uintptr) { /* parser.c:151:13: */
	if (*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, TSLogType, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log})).f(tls,
			(*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Payload,
			TSLogTypeParse,
			self /* &.lexer */ +165 /* &.debug_buffer */)
	}

	if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
		libc.Xfprintf(tls, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file, ts+861 /* "graph {\nlabel=\"" */, 0)
		{
			var c uintptr = (self /* &.lexer */ + 165 /* &.debug_buffer */)
		__1:
			if !(int32(*(*int8)(unsafe.Pointer(c))) != 0) {
				goto __3
			}
			{
				if int32(*(*int8)(unsafe.Pointer(c))) == '"' {
					libc.Xfputc(tls, '\\', (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
				}
				libc.Xfputc(tls, int32(*(*int8)(unsafe.Pointer(c))), (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)

			}
			goto __2
		__2:
			c++
			goto __1
			goto __3
		__3:
			;
		}
		libc.Xfprintf(tls, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file, ts+877 /* "\"\n}\n\n" */, 0)
	}
}

func ts_parser__breakdown_top_of_stack(tls *libc.TLS, self uintptr, version StackVersion) uint8 { /* parser.c:170:13: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var did_break_down uint8 = uint8(False)
	var pending uint8 = uint8(False)

	for ok := true; ok; ok = pending != 0 {
		var pop = Xts_stack_pop_pending(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
		if !(int32(pop.Size) != 0) {
			break
		}

		did_break_down = uint8(True)
		pending = uint8(False)
		{
			var i Uint32_t = Uint32_t(0)
		__1:
			if !(i < pop.Size) {
				goto __3
			}
			{
				*(*StackSlice)(unsafe.Pointer(bp + 8 /* slice */)) = *(*StackSlice)(unsafe.Pointer(pop.Contents + uintptr(i)*24))
				var state TSStateId = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp+8 /* &slice */)).Version)
				*(*Subtree)(unsafe.Pointer(bp + 32 /* parent */)) = *(*Subtree)(unsafe.Pointer(func() uintptr {
					if libc.X__builtin_expect(tls, libc.BoolInt64(!(Uint32_t(0) < (*SubtreeArray)(unsafe.Pointer((bp+8 /* &slice */ /* &.subtrees */))).Size)), int64(0)) != 0 {
						libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__70)), ts+883 /* "upstream/tree-si..." */, 186, ts+921 /* "(uint32_t)0 < (&..." */)
					} else {
					}
					return ((*SubtreeArray)(unsafe.Pointer((bp + 8 /* &slice */ /* &.subtrees */))).Contents)
				}()))

				{
					var j Uint32_t = Uint32_t(0)
					var n Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 32 /* parent */)))
				__4:
					if !(j < n) {
						goto __6
					}
					{
						var child = *(*Subtree)(unsafe.Pointer((func() uintptr {
							if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &parent */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
								return uintptr(0)
							}
							return ((*(*uintptr)(unsafe.Pointer(bp + 32 /* &parent */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &parent */)))).Child_count)*16)
						}()) + uintptr(j)*16))
						pending = (uint8(libc.Bool32(ts_subtree_child_count(tls, child) > Uint32_t(0))))

						if ts_subtree_is_error(tls, child) != 0 {
							state = TSStateId(ERROR_STATE)
						} else if !(ts_subtree_extra(tls, child) != 0) {
							state = ts_language_next_state(tls, (*TSParser)(unsafe.Pointer(self)).Language, state, ts_subtree_symbol(tls, child))
						}

						Xts_subtree_retain(tls, child)
						Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp+8 /* &slice */)).Version, child, pending, state)

					}
					goto __5
				__5:
					j++
					goto __4
					goto __6
				__6:
					;
				}

				{
					var j1 Uint32_t = Uint32_t(1)
				__7:
					if !(j1 < (*StackSlice)(unsafe.Pointer(bp+8 /* &slice */)).Subtrees.Size) {
						goto __9
					}
					{
						var tree = *(*Subtree)(unsafe.Pointer((*StackSlice)(unsafe.Pointer(bp+8 /* &slice */)).Subtrees.Contents + uintptr(j1)*16))
						Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp+8 /* &slice */)).Version, tree, uint8(False), state)

					}
					goto __8
				__8:
					j1++
					goto __7
					goto __9
				__9:
					;
				}

				Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(bp + 32 /* parent */)))
				array__delete(tls, (bp + 8 /* &slice */ /* &.subtrees */))

				if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
					libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
						if X_USE_FORTIFY_LEVEL > 1 {
							return 1
						}
						return 0
					}()), ts+959 /* "breakdown_top_of..." */, libc.VaList(bp, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 32 /* parent */))))))
					ts_parser__log(tls, self)
				}

				if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
					Xts_stack_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
					libc.Xfputs(tls, ts+990 /* "\n\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	return did_break_down
}

var __func__70 = *(*[34]int8)(unsafe.Pointer(ts + 993 /* "ts_parser__break..." */)) /* parser.c:173:3 */

func ts_parser__breakdown_lookahead(tls *libc.TLS, self uintptr, lookahead uintptr, state TSStateId, reusable_node uintptr) { /* parser.c:218:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var did_descend uint8 = uint8(False)
	var tree = reusable_node_tree(tls, reusable_node)
	for (ts_subtree_child_count(tls, tree) > Uint32_t(0)) && (int32(ts_subtree_parse_state(tls, tree)) != int32(state)) {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1027 /* "state_mismatch s..." */, libc.VaList(bp, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, tree))))
			ts_parser__log(tls, self)
		}

		reusable_node_descend(tls, reusable_node)
		tree = reusable_node_tree(tls, reusable_node)
		did_descend = uint8(True)
	}

	if did_descend != 0 {
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(lookahead)))
		*(*Subtree)(unsafe.Pointer(lookahead)) = tree
		Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer(lookahead)))
	}
}

func ts_parser__compare_versions(tls *libc.TLS, self uintptr, a ErrorStatus, b ErrorStatus) ErrorComparison { /* parser.c:240:24: */
	_ = self
	if !(int32(a.Is_in_error) != 0) && (b.Is_in_error != 0) {
		if a.Cost < b.Cost {
			return ErrorComparisonTakeLeft
		} else {
			return ErrorComparisonPreferLeft
		}
	}

	if (a.Is_in_error != 0) && !(int32(b.Is_in_error) != 0) {
		if b.Cost < a.Cost {
			return ErrorComparisonTakeRight
		} else {
			return ErrorComparisonPreferRight
		}
	}

	if a.Cost < b.Cost {
		if ((b.Cost - a.Cost) * (uint32(1) + a.Node_count)) > sMAX_COST_DIFFERENCE {
			return ErrorComparisonTakeLeft
		} else {
			return ErrorComparisonPreferLeft
		}
	}

	if b.Cost < a.Cost {
		if ((a.Cost - b.Cost) * (uint32(1) + b.Node_count)) > sMAX_COST_DIFFERENCE {
			return ErrorComparisonTakeRight
		} else {
			return ErrorComparisonPreferRight
		}
	}

	if a.Dynamic_precedence > b.Dynamic_precedence {
		return ErrorComparisonPreferLeft
	}
	if b.Dynamic_precedence > a.Dynamic_precedence {
		return ErrorComparisonPreferRight
	}
	return ErrorComparisonNone
}

func ts_parser__version_status(tls *libc.TLS, self uintptr, version StackVersion) ErrorStatus { /* parser.c:283:20: */
	var cost uint32 = Xts_stack_error_cost(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var is_paused uint8 = Xts_stack_is_paused(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	if is_paused != 0 {
		cost = cost + (uint32(ERROR_COST_PER_SKIPPED_TREE))
	}
	return ErrorStatus{Cost: cost, Node_count: Xts_stack_node_count_since_error(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version), Dynamic_precedence: Xts_stack_dynamic_precedence(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version), Is_in_error: (uint8(libc.Bool32((is_paused != 0) || (int32(Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)) == ERROR_STATE))))}
}

func ts_parser__better_version_exists(tls *libc.TLS, self uintptr, version StackVersion, is_in_error uint8, cost uint32) uint8 { /* parser.c:298:13: */
	if (*(*uintptr)(unsafe.Pointer(self + 1256 /* &.finished_tree */)) != 0) && (ts_subtree_error_cost(tls, (*TSParser)(unsafe.Pointer(self)).Finished_tree) <= cost) {
		return uint8(True)
	}

	var position = Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var status = ErrorStatus{Cost: cost, Node_count: Xts_stack_node_count_since_error(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version), Dynamic_precedence: Xts_stack_dynamic_precedence(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version), Is_in_error: is_in_error}

	{
		var i StackVersion = StackVersion(0)
		var n StackVersion = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
	__1:
		if !(i < n) {
			goto __3
		}
		{
			if ((i == version) || !(Xts_stack_is_active(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i) != 0)) || (Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i).Bytes < position.Bytes) {
				goto __2
			}
			var status_i = ts_parser__version_status(tls, self, i)
			switch ts_parser__compare_versions(tls, self, status, status_i) {
			case ErrorComparisonTakeRight:
				return uint8(True)
			case ErrorComparisonPreferRight:
				if Xts_stack_can_merge(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i, version) != 0 {
					return uint8(True)
				}
				break
			default:
				break
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	return uint8(False)
}

func ts_parser__restore_external_scanner(tls *libc.TLS, self uintptr, external_token Subtree) { /* parser.c:335:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = external_token

	if *(*uintptr)(unsafe.Pointer(bp /* &external_token */)) != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uint32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Deserialize})).f(tls,
			(*TSParser)(unsafe.Pointer(self)).External_scanner_payload,
			Xts_external_scanner_state_data(tls, (*(*uintptr)(unsafe.Pointer(bp /* &external_token */))+48 /* &.external_scanner_state */)),
			(*(*ExternalScannerState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &external_token */)) + 48))).Length)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uint32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Deserialize})).f(tls, (*TSParser)(unsafe.Pointer(self)).External_scanner_payload, uintptr(0), uint32(0))
	}
}

func ts_parser__can_reuse_first_leaf(tls *libc.TLS, self uintptr, state TSStateId, tree Subtree, table_entry uintptr) uint8 { /* parser.c:350:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*TSLexMode)(unsafe.Pointer(bp + 4 /* current_lex_mode */)) = *(*TSLexMode)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Lex_modes + uintptr(state)*4))
	var leaf_symbol TSSymbol = ts_subtree_leaf_symbol(tls, tree)
	var leaf_state TSStateId = ts_subtree_leaf_parse_state(tls, tree)
	*(*TSLexMode)(unsafe.Pointer(bp /* leaf_lex_mode */)) = *(*TSLexMode)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Lex_modes + uintptr(leaf_state)*4))

	// At the end of a non-terminal extra node, the lexer normally returns
	// NULL, which indicates that the parser should look for a reduce action
	// at symbol `0`. Avoid reusing tokens in this situation to ensure that
	// the same thing happens when incrementally reparsing.
	if int32((*TSLexMode)(unsafe.Pointer(bp+4 /* &current_lex_mode */)).Lex_state) == int32((libc.Uint16FromInt32(-1))) {
		return uint8(False)
	}

	// If the token was created in a state with the same set of lookaheads, it is reusable.
	if (((*TableEntry)(unsafe.Pointer(table_entry)).Action_count > Uint32_t(0)) && (libc.Xmemcmp(tls, bp /* &leaf_lex_mode */, bp+4 /* &current_lex_mode */, uint64(unsafe.Sizeof(TSLexMode{}))) == 0)) && ((int32(leaf_symbol) != int32((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Keyword_capture_token)) || (!(ts_subtree_is_keyword(tls, tree) != 0) && (int32(ts_subtree_parse_state(tls, tree)) == int32(state)))) {
		return uint8(True)
	}

	// Empty tokens are not reusable in states with different lookaheads.
	if (ts_subtree_size(tls, tree).Bytes == Uint32_t(0)) && (int32(leaf_symbol) != Ts_builtin_sym_end) {
		return uint8(False)
	}

	// If the current state allows external tokens or other tokens that conflict with this
	// token, this token is not reusable.
	return (uint8(libc.Bool32((int32((*TSLexMode)(unsafe.Pointer(bp+4 /* &current_lex_mode */)).External_lex_state) == 0) && ((*TableEntry)(unsafe.Pointer(table_entry)).Is_reusable != 0))))
}

func ts_parser__lex(tls *libc.TLS, self uintptr, version StackVersion, parse_state TSStateId) Subtree { /* parser.c:385:16: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var lex_mode = *(*TSLexMode)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Lex_modes + uintptr(parse_state)*4))
	if int32(lex_mode.Lex_state) == int32(libc.Uint16FromInt32(-1)) {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1049 /* "no_lookahead_aft..." */, 0)
			ts_parser__log(tls, self)
		}

		return Subtree{}
	}

	var start_position = Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var external_token = Xts_stack_last_external_token(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var valid_external_tokens uintptr = ts_language_enabled_external_tokens(tls,
		(*TSParser)(unsafe.Pointer(self)).Language,
		uint32(lex_mode.External_lex_state))

	var found_external_token uint8 = uint8(False)
	var error_mode uint8 = (uint8(libc.Bool32(int32(parse_state) == ERROR_STATE)))
	var skipped_error uint8 = uint8(False)
	var called_get_column uint8 = uint8(False)
	var first_error_character Int32_t = 0
	var error_start_position = length_zero(tls)
	var error_end_position = length_zero(tls)
	*(*Uint32_t)(unsafe.Pointer(bp + 64 /* lookahead_end_byte */)) = Uint32_t(0)
	Xts_lexer_reset(tls, (self /* &.lexer */), start_position)

	for {
		var current_position = (*TSParser)(unsafe.Pointer(self)).Lexer.Current_position

		if valid_external_tokens != 0 {
			if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
				libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+1087 /* "lex_external sta..." */, libc.VaList(bp, int32(lex_mode.External_lex_state), (current_position.Extent.Row+Uint32_t(1)), current_position.Extent.Column))
				ts_parser__log(tls, self)
			}

			Xts_lexer_start(tls, (self /* &.lexer */))
			ts_parser__restore_external_scanner(tls, self, external_token)
			var found_token uint8 = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) uint8
			})(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Scan})).f(tls,
				(*TSParser)(unsafe.Pointer(self)).External_scanner_payload,
				(self /* &.lexer */ /* &.data */),
				valid_external_tokens)
			Xts_lexer_finish(tls, (self /* &.lexer */), bp+64 /* &lookahead_end_byte */)

			// Zero-length external tokens are generally allowed, but they're not
			// allowed right after a syntax error. This is for two reasons:
			// 1. After a syntax error, the lexer is looking for any possible token,
			//    as opposed to the specific set of tokens that are valid in some
			//    parse state. In this situation, it's very easy for an external
			//    scanner to produce unwanted zero-length tokens.
			// 2. The parser sometimes inserts *missing* tokens to recover from
			//    errors. These tokens are also zero-length. If we allow more
			//    zero-length tokens to be created after missing tokens, it
			//    can lead to infinite loops. Forbidding zero-length tokens
			//    right at the point of error recovery is a conservative strategy
			//    for preventing this kind of infinite loop.
			if (found_token != 0) && (((*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position.Bytes > current_position.Bytes) || (!(error_mode != 0) && (Xts_stack_has_advanced_since_error(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version) != 0))) {
				found_external_token = uint8(True)
				called_get_column = (*TSParser)(unsafe.Pointer(self)).Lexer.Did_get_column
				break
			}

			Xts_lexer_reset(tls, (self /* &.lexer */), current_position)
		}

		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1128 /* "lex_internal sta..." */, libc.VaList(bp+24, int32(lex_mode.Lex_state), (current_position.Extent.Row+Uint32_t(1)), current_position.Extent.Column))
			ts_parser__log(tls, self)
		}

		Xts_lexer_start(tls, (self /* &.lexer */))
		var found_token uint8 = (*struct {
			f func(*libc.TLS, uintptr, TSStateId) uint8
		})(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Lex_fn})).f(tls, (self /* &.lexer */ /* &.data */), lex_mode.Lex_state)
		Xts_lexer_finish(tls, (self /* &.lexer */), bp+64 /* &lookahead_end_byte */)
		if found_token != 0 {
			break
		}

		if !(error_mode != 0) {
			error_mode = uint8(True)
			lex_mode = *(*TSLexMode)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Lex_modes))
			valid_external_tokens = ts_language_enabled_external_tokens(tls,
				(*TSParser)(unsafe.Pointer(self)).Language,
				uint32(lex_mode.External_lex_state))
			Xts_lexer_reset(tls, (self /* &.lexer */), start_position)
			continue
		}

		if !(skipped_error != 0) {
			if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
				libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+1169 /* "skip_unrecognize..." */, 0)
				ts_parser__log(tls, self)
			}

			skipped_error = uint8(True)
			error_start_position = (*TSParser)(unsafe.Pointer(self)).Lexer.Token_start_position
			error_end_position = (*TSParser)(unsafe.Pointer(self)).Lexer.Token_start_position
			first_error_character = (*TSParser)(unsafe.Pointer(self)).Lexer.Data.Lookahead
		}

		if (*TSParser)(unsafe.Pointer(self)).Lexer.Current_position.Bytes == error_end_position.Bytes {
			if (*struct {
				f func(*libc.TLS, uintptr) uint8
			})(unsafe.Pointer(&struct{ uintptr }{(*TSParser)(unsafe.Pointer(self)).Lexer.Data.Eof})).f(tls, (self /* &.lexer */ /* &.data */)) != 0 {
				(*TSParser)(unsafe.Pointer(self)).Lexer.Data.Result_symbol = libc.Uint16(libc.Uint16FromInt32(-1))
				break
			}
			(*struct {
				f func(*libc.TLS, uintptr, uint8)
			})(unsafe.Pointer(&struct{ uintptr }{(*TSParser)(unsafe.Pointer(self)).Lexer.Data.Advance})).f(tls, (self /* &.lexer */ /* &.data */), uint8(False))
		}

		error_end_position = (*TSParser)(unsafe.Pointer(self)).Lexer.Current_position
	}
	// var result Subtree at bp+72, 16

	if skipped_error != 0 {
		var padding = length_sub(tls, error_start_position, start_position)
		var size = length_sub(tls, error_end_position, error_start_position)
		var lookahead_bytes Uint32_t = (*(*Uint32_t)(unsafe.Pointer(bp + 64 /* lookahead_end_byte */)) - error_end_position.Bytes)
		*(*Subtree)(unsafe.Pointer(bp + 72 /* result */)) = Xts_subtree_new_error(tls,
			(self + 1200 /* &.tree_pool */),
			first_error_character,
			padding,
			size,
			lookahead_bytes,
			parse_state,
			(*TSParser)(unsafe.Pointer(self)).Language)

		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			var buf uintptr = self /* &.lexer */ + 165 /* &.debug_buffer */
			var symbol uintptr = Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 72 /* result */))))
			var off int32 = libc.X__builtin___sprintf_chk(tls, buf, 0, libc.X__builtin_object_size(tls, buf, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1197 /* "lexed_lookahead ..." */, 0)
			{
				var i int32 = 0
			__1:
				if !((int32(*(*int8)(unsafe.Pointer(symbol + uintptr(i)))) != 0) && (off < TREE_SITTER_SERIALIZATION_BUFFER_SIZE)) {
					goto __3
				}
				{
					switch int32(*(*int8)(unsafe.Pointer(symbol + uintptr(i)))) {
					case '\t':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('t')
						break
						fallthrough
					case '\n':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('n')
						break
						fallthrough
					case '\v':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('v')
						break
						fallthrough
					case '\f':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('f')
						break
						fallthrough
					case '\r':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('r')
						break
						fallthrough
					case '\\':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						break
						fallthrough
					default:
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = *(*int8)(unsafe.Pointer(symbol + uintptr(i)))
						break
					}
				}
				goto __2
			__2:
				i++
				goto __1
				goto __3
			__3:
				;
			}
			libc.X__builtin___snprintf_chk(tls, (buf + uintptr(off)), (uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE - off)), 0, libc.X__builtin_object_size(tls, (buf+uintptr(off)), func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1218 /* ", size:%u" */, libc.VaList(bp+48, ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(bp + 72 /* result */))).Bytes))
			ts_parser__log(tls, self)
		}

	} else {
		if (*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position.Bytes < (*TSParser)(unsafe.Pointer(self)).Lexer.Token_start_position.Bytes {
			(*TSParser)(unsafe.Pointer(self)).Lexer.Token_start_position = (*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position
		}

		var is_keyword uint8 = uint8(False)
		var symbol TSSymbol = (*TSParser)(unsafe.Pointer(self)).Lexer.Data.Result_symbol
		var padding = length_sub(tls, (*TSParser)(unsafe.Pointer(self)).Lexer.Token_start_position, start_position)
		var size = length_sub(tls, (*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position, (*TSParser)(unsafe.Pointer(self)).Lexer.Token_start_position)
		var lookahead_bytes Uint32_t = (*(*Uint32_t)(unsafe.Pointer(bp + 64 /* lookahead_end_byte */)) - (*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position.Bytes)

		if found_external_token != 0 {
			symbol = *(*TSSymbol)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Symbol_map + uintptr(symbol)*2))
		} else if (int32(symbol) == int32((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Keyword_capture_token)) && (int32(symbol) != 0) {
			var end_byte Uint32_t = (*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position.Bytes
			Xts_lexer_reset(tls, (self /* &.lexer */), (*TSParser)(unsafe.Pointer(self)).Lexer.Token_start_position)
			Xts_lexer_start(tls, (self /* &.lexer */))
			if (((*struct {
				f func(*libc.TLS, uintptr, TSStateId) uint8
			})(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Keyword_lex_fn})).f(tls, (self /* &.lexer */ /* &.data */), uint16(0)) != 0) && ((*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position.Bytes == end_byte)) && (ts_language_has_actions(tls, (*TSParser)(unsafe.Pointer(self)).Language, parse_state, (*TSParser)(unsafe.Pointer(self)).Lexer.Data.Result_symbol) != 0) {
				is_keyword = uint8(True)
				symbol = (*TSParser)(unsafe.Pointer(self)).Lexer.Data.Result_symbol
			}
		}

		*(*Subtree)(unsafe.Pointer(bp + 72 /* result */)) = Xts_subtree_new_leaf(tls,
			(self + 1200 /* &.tree_pool */),
			symbol,
			padding,
			size,
			lookahead_bytes,
			parse_state,
			found_external_token,
			called_get_column,
			is_keyword,
			(*TSParser)(unsafe.Pointer(self)).Language)

		if found_external_token != 0 {
			var length uint32 = (*struct {
				f func(*libc.TLS, uintptr, uintptr) uint32
			})(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Serialize})).f(tls,
				(*TSParser)(unsafe.Pointer(self)).External_scanner_payload,
				self /* &.lexer */ +165 /* &.debug_buffer */)
			Xts_external_scanner_state_init(tls,
				(*(*uintptr)(unsafe.Pointer(bp + 72 /* &result */)) + 48 /* &.external_scanner_state */),
				self /* &.lexer */ +165, /* &.debug_buffer */
				length)
		}

		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			var buf uintptr = self /* &.lexer */ + 165 /* &.debug_buffer */
			var symbol uintptr = Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 72 /* result */))))
			var off int32 = libc.X__builtin___sprintf_chk(tls, buf, 0, libc.X__builtin_object_size(tls, buf, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1197 /* "lexed_lookahead ..." */, 0)
			{
				var i int32 = 0
			__4:
				if !((int32(*(*int8)(unsafe.Pointer(symbol + uintptr(i)))) != 0) && (off < TREE_SITTER_SERIALIZATION_BUFFER_SIZE)) {
					goto __6
				}
				{
					switch int32(*(*int8)(unsafe.Pointer(symbol + uintptr(i)))) {
					case '\t':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('t')
						break
						fallthrough
					case '\n':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('n')
						break
						fallthrough
					case '\v':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('v')
						break
						fallthrough
					case '\f':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('f')
						break
						fallthrough
					case '\r':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('r')
						break
						fallthrough
					case '\\':
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = int8('\\')
						break
						fallthrough
					default:
						*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&off, 1)))) = *(*int8)(unsafe.Pointer(symbol + uintptr(i)))
						break
					}
				}
				goto __5
			__5:
				i++
				goto __4
				goto __6
			__6:
				;
			}
			libc.X__builtin___snprintf_chk(tls, (buf + uintptr(off)), (uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE - off)), 0, libc.X__builtin_object_size(tls, (buf+uintptr(off)), func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1218 /* ", size:%u" */, libc.VaList(bp+56, ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(bp + 72 /* result */))).Bytes))
			ts_parser__log(tls, self)
		}

	}

	return *(*Subtree)(unsafe.Pointer(bp + 72 /* result */))
}

func ts_parser__get_cached_token(tls *libc.TLS, self uintptr, state TSStateId, position Size_t, last_external_token Subtree, table_entry uintptr) Subtree { /* parser.c:577:16: */
	var cache uintptr = (self + 1320 /* &.token_cache */)
	if ((*(*uintptr)(unsafe.Pointer(cache /* &.token */)) != 0) && (Size_t((*TokenCache)(unsafe.Pointer(cache)).Byte_index) == position)) && (Xts_subtree_external_scanner_state_eq(tls, (*TokenCache)(unsafe.Pointer(cache)).Last_external_token, last_external_token) != 0) {
		Xts_language_table_entry(tls, (*TSParser)(unsafe.Pointer(self)).Language, state, ts_subtree_symbol(tls, (*TokenCache)(unsafe.Pointer(cache)).Token), table_entry)
		if ts_parser__can_reuse_first_leaf(tls, self, state, (*TokenCache)(unsafe.Pointer(cache)).Token, table_entry) != 0 {
			Xts_subtree_retain(tls, (*TokenCache)(unsafe.Pointer(cache)).Token)
			return (*TokenCache)(unsafe.Pointer(cache)).Token
		}
	}
	return Subtree{}
}

func ts_parser__set_cached_token(tls *libc.TLS, self uintptr, byte_index Size_t, last_external_token Subtree, token Subtree) { /* parser.c:598:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*Subtree)(unsafe.Pointer(bp + 16)) = last_external_token
	*(*Subtree)(unsafe.Pointer(bp)) = token

	var cache uintptr = (self + 1320 /* &.token_cache */)
	if *(*uintptr)(unsafe.Pointer(bp /* &token */)) != 0 {
		Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer(bp /* token */)))
	}
	if *(*uintptr)(unsafe.Pointer(bp + 16 /* &last_external_token */)) != 0 {
		Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* last_external_token */)))
	}
	if *(*uintptr)(unsafe.Pointer(cache /* &.token */)) != 0 {
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), (*TokenCache)(unsafe.Pointer(cache)).Token)
	}
	if *(*uintptr)(unsafe.Pointer(cache + 16 /* &.last_external_token */)) != 0 {
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), (*TokenCache)(unsafe.Pointer(cache)).Last_external_token)
	}
	(*TokenCache)(unsafe.Pointer(cache)).Token = *(*Subtree)(unsafe.Pointer(bp /* token */))
	(*TokenCache)(unsafe.Pointer(cache)).Byte_index = Uint32_t(byte_index)
	(*TokenCache)(unsafe.Pointer(cache)).Last_external_token = *(*Subtree)(unsafe.Pointer(bp + 16 /* last_external_token */))
}

func ts_parser__has_included_range_difference(tls *libc.TLS, self uintptr, start_position Uint32_t, end_position Uint32_t) uint8 { /* parser.c:614:13: */
	return Xts_range_array_intersects(tls,
		(self + 1456 /* &.included_range_differences */),
		(*TSParser)(unsafe.Pointer(self)).Included_range_difference_index,
		start_position,
		end_position)
}

func ts_parser__reuse_node(tls *libc.TLS, self uintptr, version StackVersion, state uintptr, position Uint32_t, last_external_token Subtree, table_entry uintptr) Subtree { /* parser.c:627:16: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// var result Subtree at bp+64, 16

	for *(*uintptr)(unsafe.Pointer(libc.Xmemmove(tls, bp+64 /* &result */, func() uintptr {
		*(*Subtree)(unsafe.Pointer(bp + 80)) = reusable_node_tree(tls, (self + 1360 /* &.reusable_node */))
		return bp + 80
	}(), 16))) != 0 {
		var byte_offset Uint32_t = reusable_node_byte_offset(tls, (self + 1360 /* &.reusable_node */))
		var end_byte_offset Uint32_t = (byte_offset + ts_subtree_total_bytes(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))))

		// Do not reuse an EOF node if the included ranges array has changes
		// later on in the file.
		if ts_subtree_is_eof(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))) != 0 {
			end_byte_offset = UINT32_MAX
		}

		if byte_offset > position {
			if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
				libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+1228 /* "before_reusable_..." */, libc.VaList(bp, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))))))
				ts_parser__log(tls, self)
			}

			break
		}

		if byte_offset < position {
			if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
				libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+1259 /* "past_reusable_no..." */, libc.VaList(bp+8, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))))))
				ts_parser__log(tls, self)
			}

			if (end_byte_offset <= position) || !(reusable_node_descend(tls, (self+1360 /* &.reusable_node */)) != 0) {
				reusable_node_advance(tls, (self + 1360 /* &.reusable_node */))
			}
			continue
		}

		if !(Xts_subtree_external_scanner_state_eq(tls, (*TSParser)(unsafe.Pointer(self)).Reusable_node.Last_external_token, last_external_token) != 0) {
			if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
				libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+1288 /* "reusable_node_ha..." */, libc.VaList(bp+16, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))))))
				ts_parser__log(tls, self)
			}

			reusable_node_advance(tls, (self + 1360 /* &.reusable_node */))
			continue
		}

		var reason uintptr = uintptr(0)
		if ts_subtree_has_changes(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))) != 0 {
			reason = ts + 1349 /* "has_changes" */
		} else if ts_subtree_is_error(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))) != 0 {
			reason = ts + 1361 /* "is_error" */
		} else if ts_subtree_missing(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))) != 0 {
			reason = ts + 1370 /* "is_missing" */
		} else if ts_subtree_is_fragile(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))) != 0 {
			reason = ts + 1381 /* "is_fragile" */
		} else if ts_parser__has_included_range_difference(tls, self, byte_offset, end_byte_offset) != 0 {
			reason = ts + 1392 /* "contains_differe..." */
		}

		if reason != 0 {
			if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
				libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+1426 /* "cant_reuse_node_..." */, libc.VaList(bp+24, reason, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))))))
				ts_parser__log(tls, self)
			}

			if !(reusable_node_descend(tls, (self+1360 /* &.reusable_node */)) != 0) {
				reusable_node_advance(tls, (self + 1360 /* &.reusable_node */))
				ts_parser__breakdown_top_of_stack(tls, self, version)
				*(*TSStateId)(unsafe.Pointer(state)) = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
			}
			continue
		}

		var leaf_symbol TSSymbol = ts_subtree_leaf_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */)))
		Xts_language_table_entry(tls, (*TSParser)(unsafe.Pointer(self)).Language, *(*TSStateId)(unsafe.Pointer(state)), leaf_symbol, table_entry)
		if !(ts_parser__can_reuse_first_leaf(tls, self, *(*TSStateId)(unsafe.Pointer(state)), *(*Subtree)(unsafe.Pointer(bp + 64 /* result */)), table_entry) != 0) {
			if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
				libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+1453 /* "cant_reuse_node ..." */, libc.VaList(bp+40, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */)))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, leaf_symbol)))
				ts_parser__log(tls, self)
			}

			reusable_node_advance_past_leaf(tls, (self + 1360 /* &.reusable_node */))
			break
		}

		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1501 /* "reuse_node symbo..." */, libc.VaList(bp+56, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))))))
			ts_parser__log(tls, self)
		}

		Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* result */)))
		return *(*Subtree)(unsafe.Pointer(bp + 64 /* result */))
	}

	return Subtree{}
}

// Determine if a given tree should be replaced by an alternative tree.
//
// The decision is based on the trees' error costs (if any), their dynamic precedence,
// and finally, as a default, by a recursive comparison of the trees' symbols.
func ts_parser__select_tree(tls *libc.TLS, self uintptr, left Subtree, right Subtree) uint8 { /* parser.c:710:13: */
	bp := tls.Alloc(176)
	defer tls.Free(176)
	*(*Subtree)(unsafe.Pointer(bp + 144)) = left
	*(*Subtree)(unsafe.Pointer(bp + 160)) = right

	if !(int32(*(*uintptr)(unsafe.Pointer(bp + 144 /* &left */))) != 0) {
		return uint8(True)
	}
	if !(int32(*(*uintptr)(unsafe.Pointer(bp + 160 /* &right */))) != 0) {
		return uint8(False)
	}

	if ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))) < ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))) {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1522 /* "select_smaller_e..." */, libc.VaList(bp, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */)))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))))))
			ts_parser__log(tls, self)
		}

		return uint8(True)
	}

	if ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))) < ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))) {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1522 /* "select_smaller_e..." */, libc.VaList(bp+16, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */)))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))))))
			ts_parser__log(tls, self)
		}

		return uint8(False)
	}

	if ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))) > ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))) {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1569 /* "select_higher_pr..." */, libc.VaList(bp+32, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */)))), ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */)))), ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */)))))
			ts_parser__log(tls, self)
		}

		return uint8(True)
	}

	if ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))) > ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))) {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1569 /* "select_higher_pr..." */, libc.VaList(bp+64, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */)))), ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */)))), ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */)))))
			ts_parser__log(tls, self)
		}

		return uint8(False)
	}

	if ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))) > Uint32_t(0) {
		return uint8(True)
	}

	var comparison int32 = Xts_subtree_compare(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */)), *(*Subtree)(unsafe.Pointer(bp + 160 /* right */)))
	switch comparison {
	case -1:
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1644 /* "select_earlier s..." */, libc.VaList(bp+96, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */)))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))))))
			ts_parser__log(tls, self)
		}

		return uint8(False)
		break
	case 1:
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1644 /* "select_earlier s..." */, libc.VaList(bp+112, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */)))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */))))))
			ts_parser__log(tls, self)
		}

		return uint8(True)
	default:
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1685 /* "select_existing ..." */, libc.VaList(bp+128, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 144 /* left */)))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 160 /* right */))))))
			ts_parser__log(tls, self)
		}

		return uint8(False)
	}
	return uint8(0)
}

// Determine if a given tree's children should be replaced by an alternative
// array of children.
func ts_parser__select_children(tls *libc.TLS, self uintptr, left Subtree, children uintptr) uint8 { /* parser.c:757:13: */
	array__assign(tls, (self + 1304 /* &.scratch_trees */), children, uint64(unsafe.Sizeof(Subtree{})))

	// Create a temporary subtree using the scratch trees array. This node does
	// not perform any allocation except for possibly growing the array to make
	// room for its own heap data. The scratch tree is never explicitly released,
	// so the same 'scratch trees' array can be reused again later.
	var scratch_tree = Xts_subtree_new_node(tls,
		ts_subtree_symbol(tls, left),
		(self + 1304 /* &.scratch_trees */),
		uint32(0),
		(*TSParser)(unsafe.Pointer(self)).Language)

	return ts_parser__select_tree(tls,
		self,
		left,
		ts_subtree_from_mut(tls, scratch_tree))
}

func ts_parser__shift(tls *libc.TLS, self uintptr, version StackVersion, state TSStateId, lookahead Subtree, extra uint8) { /* parser.c:782:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var subtree_to_push Subtree
	if extra != ts_subtree_extra(tls, lookahead) {
		*(*MutableSubtree)(unsafe.Pointer(bp /* result */)) = Xts_subtree_make_mut(tls, (self + 1200 /* &.tree_pool */), lookahead)
		ts_subtree_set_extra(tls, bp /* &result */)
		subtree_to_push = ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp /* result */)))
	} else {
		subtree_to_push = lookahead
	}

	var is_pending uint8 = (uint8(libc.Bool32(ts_subtree_child_count(tls, subtree_to_push) > Uint32_t(0))))
	Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, subtree_to_push, is_pending, state)
	if ts_subtree_has_external_tokens(tls, subtree_to_push) != 0 {
		Xts_stack_set_last_external_token(tls,
			(*TSParser)(unsafe.Pointer(self)).Stack, version, Xts_subtree_last_external_token(tls, subtree_to_push))
	}
}

func ts_parser__reduce(tls *libc.TLS, self uintptr, version StackVersion, symbol TSSymbol, count Uint32_t, dynamic_precedence int32, production_id Uint16_t, is_fragile uint8, end_of_non_terminal_extra uint8) StackVersion { /* parser.c:807:21: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var initial_version_count Uint32_t = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)

	// Pop the given number of nodes from the given version of the parse stack.
	// If stack versions have previously merged, then there may be more than one
	// path back through the stack. For each path, create a new parent node to
	// contain the popped children, and push it onto the stack in place of the
	// children.
	var pop = Xts_stack_pop_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, count)
	var removed_version_count Uint32_t = Uint32_t(0)
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < pop.Size) {
			goto __3
		}
		{
			*(*StackSlice)(unsafe.Pointer(bp /* slice */)) = *(*StackSlice)(unsafe.Pointer(pop.Contents + uintptr(i)*24))
			var slice_version StackVersion = ((*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version - removed_version_count)

			// This is where new versions are added to the parse stack. The versions
			// will all be sorted and truncated at the end of the outer parsing loop.
			// Allow the maximum version count to be temporarily exceeded, but only
			// by a limited threshold.
			if slice_version > (sMAX_VERSION_COUNT + sMAX_VERSION_COUNT_OVERFLOW) {
				Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, slice_version)
				Xts_subtree_array_delete(tls, (self + 1200 /* &.tree_pool */), (bp /* &slice */ /* &.subtrees */))
				removed_version_count++
				for (i + Uint32_t(1)) < pop.Size {
					*(*StackSlice)(unsafe.Pointer(bp + 24 /* next_slice */)) = *(*StackSlice)(unsafe.Pointer(pop.Contents + uintptr((i+Uint32_t(1)))*24))
					if (*StackSlice)(unsafe.Pointer(bp+24 /* &next_slice */)).Version != (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version {
						break
					}
					Xts_subtree_array_delete(tls, (self + 1200 /* &.tree_pool */), (bp + 24 /* &next_slice */ /* &.subtrees */))
					i++
				}
				goto __2
			}

			// Extra tokens on top of the stack should not be included in this new parent
			// node. They will be re-pushed onto the stack after the parent node is
			// created and pushed.
			*(*SubtreeArray)(unsafe.Pointer(bp + 48 /* children */)) = (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Subtrees
			Xts_subtree_array_remove_trailing_extras(tls, bp+48 /* &children */, (self + 1272 /* &.trailing_extras */))

			*(*MutableSubtree)(unsafe.Pointer(bp + 104 /* parent */)) = Xts_subtree_new_node(tls,
				symbol, bp+48 /* &children */, uint32(production_id), (*TSParser)(unsafe.Pointer(self)).Language)

			// This pop operation may have caused multiple stack versions to collapse
			// into one, because they all diverged from a common state. In that case,
			// choose one of the arrays of trees to be the parent node's children, and
			// delete the rest of the tree arrays.
			for (i + Uint32_t(1)) < pop.Size {
				*(*StackSlice)(unsafe.Pointer(bp + 80 /* next_slice */)) = *(*StackSlice)(unsafe.Pointer(pop.Contents + uintptr((i+Uint32_t(1)))*24))
				if (*StackSlice)(unsafe.Pointer(bp+80 /* &next_slice */)).Version != (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version {
					break
				}
				i++

				*(*SubtreeArray)(unsafe.Pointer(bp + 64 /* children */)) = (*StackSlice)(unsafe.Pointer(bp + 80 /* &next_slice */)).Subtrees
				Xts_subtree_array_remove_trailing_extras(tls, bp+64 /* &children */, (self + 1288 /* &.trailing_extras2 */))

				if ts_parser__select_children(tls,
					self,
					ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 104 /* parent */))),
					bp+64 /* &children */) != 0 {
					Xts_subtree_array_clear(tls, (self + 1200 /* &.tree_pool */), (self + 1272 /* &.trailing_extras */))
					Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 104 /* parent */))))
					array__swap(tls, (self + 1272 /* &.trailing_extras */), (self + 1288 /* &.trailing_extras2 */))
					*(*MutableSubtree)(unsafe.Pointer(bp + 104 /* parent */)) = Xts_subtree_new_node(tls,
						symbol, bp+64 /* &children */, uint32(production_id), (*TSParser)(unsafe.Pointer(self)).Language)
				} else {
					(*SubtreeArray)(unsafe.Pointer((self + 1288 /* &.trailing_extras2 */))).Size = Uint32_t(0)
					Xts_subtree_array_delete(tls, (self + 1200 /* &.tree_pool */), (bp + 80 /* &next_slice */ /* &.subtrees */))
				}
			}

			var state TSStateId = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, slice_version)
			var next_state TSStateId = ts_language_next_state(tls, (*TSParser)(unsafe.Pointer(self)).Language, state, symbol)
			if (end_of_non_terminal_extra != 0) && (int32(next_state) == int32(state)) {
				libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp + 104 /* &parent */))+44 /* &.extra */, uint8(True), 2, 0x4)
			}
			if ((is_fragile != 0) || (pop.Size > Uint32_t(1))) || (initial_version_count > Uint32_t(1)) {
				libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp + 104 /* &parent */))+44 /* &.fragile_left */, uint8(True), 3, 0x8)
				libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp + 104 /* &parent */))+44 /* &.fragile_right */, uint8(True), 4, 0x10)
				(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 104 /* &parent */)))).Parse_state = (TSStateId((0x7fff * 2) + 1))
			} else {
				(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 104 /* &parent */)))).Parse_state = state
			}
			*(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 104 /* &parent */)) + 64 /* &.dynamic_precedence */)) += (dynamic_precedence)

			// Push the parent node onto the stack, along with any extra tokens that
			// were previously on top of the stack.
			Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, slice_version, ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 104 /* parent */))), uint8(False), next_state)
			{
				var j Uint32_t = Uint32_t(0)
			__4:
				if !(j < (*TSParser)(unsafe.Pointer(self)).Trailing_extras.Size) {
					goto __6
				}
				{
					Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, slice_version, *(*Subtree)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Trailing_extras.Contents + uintptr(j)*16)), uint8(False), next_state)

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
				;
			}

			{
				var j1 StackVersion = StackVersion(0)
			__7:
				if !(j1 < slice_version) {
					goto __9
				}
				{
					if j1 == version {
						goto __8
					}
					if Xts_stack_merge(tls, (*TSParser)(unsafe.Pointer(self)).Stack, j1, slice_version) != 0 {
						removed_version_count++
						goto __9
					}

				}
				goto __8
			__8:
				j1++
				goto __7
				goto __9
			__9:
				;
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	// Return the first new stack version that was created.
	if Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack) > initial_version_count {
		return initial_version_count
	}
	return libc.Uint32(libc.Uint32FromInt32(-1))
}

func ts_parser__accept(tls *libc.TLS, self uintptr, version StackVersion, lookahead Subtree) { /* parser.c:922:13: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	if libc.X__builtin_expect(tls, libc.BoolInt64(!(ts_subtree_is_eof(tls, lookahead) != 0)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__71)), ts+883 /* "upstream/tree-si..." */, 927, ts+1727 /* "ts_subtree_is_eo..." */)
	} else {
	}
	Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, lookahead, uint8(False), uint16(1))

	var pop = Xts_stack_pop_all(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < pop.Size) {
			goto __3
		}
		{
			*(*SubtreeArray)(unsafe.Pointer(bp + 16 /* trees */)) = (*StackSlice)(unsafe.Pointer(pop.Contents + uintptr(i)*24)).Subtrees

			*(*Subtree)(unsafe.Pointer(bp + 32 /* root */)) = Subtree{}
			{
				var j Uint32_t = ((*SubtreeArray)(unsafe.Pointer(bp+16 /* &trees */)).Size - Uint32_t(1))
			__4:
				if !((j + Uint32_t(1)) > Uint32_t(0)) {
					goto __6
				}
				{
					*(*Subtree)(unsafe.Pointer(bp /* tree */)) = *(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(bp+16 /* &trees */)).Contents + uintptr(j)*16))
					if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */))) != 0) {
						if libc.X__builtin_expect(tls, libc.BoolInt64(!(!((int32(*(*uint8)(unsafe.Pointer(bp /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0)) != 0))), int64(0)) != 0 {
							libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__71)), ts+883 /* "upstream/tree-si..." */, 938, ts+1756 /* "!tree.data.is_in..." */)
						} else {
						}
						var child_count Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */)))
						var children uintptr = func() uintptr {
							if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
								return uintptr(0)
							}
							return ((*(*uintptr)(unsafe.Pointer(bp /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count)*16)
						}()
						{
							var k Uint32_t = Uint32_t(0)
						__7:
							if !(k < child_count) {
								goto __9
							}
							{
								Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer(children + uintptr(k)*16)))

							}
							goto __8
						__8:
							k++
							goto __7
							goto __9
						__9:
							;
						}
						array__splice(tls, bp+16 /* &trees */, uint64(unsafe.Sizeof(Subtree{})), j, uint32(1), child_count, children)
						*(*Subtree)(unsafe.Pointer(bp + 32 /* root */)) = ts_subtree_from_mut(tls, Xts_subtree_new_node(tls,
							ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */))),
							bp+16, /* &trees */
							uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)) + 68))),
							(*TSParser)(unsafe.Pointer(self)).Language))
						Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(bp /* tree */)))
						goto __6
					}

				}
				goto __5
			__5:
				j--
				goto __4
				goto __6
			__6:
				;
			}

			if libc.X__builtin_expect(tls, libc.BoolInt64(!(*(*uintptr)(unsafe.Pointer(bp + 32 /* &root */)) != 0)), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__71)), ts+883 /* "upstream/tree-si..." */, 956, ts+1777 /* "root.ptr" */)
			} else {
			}
			(*TSParser)(unsafe.Pointer(self)).Accept_count++

			if *(*uintptr)(unsafe.Pointer(self + 1256 /* &.finished_tree */)) != 0 {
				if ts_parser__select_tree(tls, self, (*TSParser)(unsafe.Pointer(self)).Finished_tree, *(*Subtree)(unsafe.Pointer(bp + 32 /* root */))) != 0 {
					Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), (*TSParser)(unsafe.Pointer(self)).Finished_tree)
					(*TSParser)(unsafe.Pointer(self)).Finished_tree = *(*Subtree)(unsafe.Pointer(bp + 32 /* root */))
				} else {
					Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(bp + 32 /* root */)))
				}
			} else {
				(*TSParser)(unsafe.Pointer(self)).Finished_tree = *(*Subtree)(unsafe.Pointer(bp + 32 /* root */))
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(pop.Contents)).Version)
	Xts_stack_halt(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
}

var __func__71 = *(*[18]int8)(unsafe.Pointer(ts + 1786 /* "ts_parser__accep..." */)) /* parser.c:926:3 */

func ts_parser__do_all_potential_reductions(tls *libc.TLS, self uintptr, starting_version StackVersion, lookahead_symbol TSSymbol) uint8 { /* parser.c:975:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var initial_version_count Uint32_t = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)

	var can_shift_lookahead_symbol uint8 = uint8(False)
	var version StackVersion = starting_version
	{
		var i uint32 = uint32(0)
	__1:
		if !(1 != 0) {
			goto __3
		}
		{
			var version_count Uint32_t = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
			if version >= version_count {
				goto __3
			}

			var merged uint8 = uint8(False)
			{
				var i StackVersion = initial_version_count
			__4:
				if !(i < version) {
					goto __6
				}
				{
					if Xts_stack_merge(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i, version) != 0 {
						merged = uint8(True)
						goto __6
					}

				}
				goto __5
			__5:
				i++
				goto __4
				goto __6
			__6:
				;
			}
			if merged != 0 {
				goto __2
			}

			var state TSStateId = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
			var has_shift_action uint8 = uint8(False)
			(*ReduceActionSet)(unsafe.Pointer((self + 1240 /* &.reduce_actions */))).Size = Uint32_t(0)
			var first_symbol TSSymbol
			var end_symbol TSSymbol
			if int32(lookahead_symbol) != 0 {
				first_symbol = lookahead_symbol
				end_symbol = (TSSymbol(int32(lookahead_symbol) + 1))
			} else {
				first_symbol = TSSymbol(1)
				end_symbol = TSSymbol((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Token_count)
			}

			{
				var symbol TSSymbol = first_symbol
			__7:
				if !(int32(symbol) < int32(end_symbol)) {
					goto __9
				}
				{
					// var entry TableEntry at bp, 16

					Xts_language_table_entry(tls, (*TSParser)(unsafe.Pointer(self)).Language, state, symbol, bp /* &entry */)
					{
						var i Uint32_t = Uint32_t(0)
					__10:
						if !(i < (*TableEntry)(unsafe.Pointer(bp /* &entry */)).Action_count) {
							goto __12
						}
						{
							*(*TSParseAction)(unsafe.Pointer(bp + 16 /* action */)) = *(*TSParseAction)(unsafe.Pointer((*TableEntry)(unsafe.Pointer(bp /* &entry */)).Actions + uintptr(i)*8))
							switch int32(*(*Uint8_t)(unsafe.Pointer(bp + 16 /* &action */))) {
							case TSParseActionTypeShift:
								fallthrough
							case TSParseActionTypeRecover:
								if !(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &action */ /* &.shift */ + 4 /* &.extra */))) != 0) && !(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &action */ /* &.shift */ + 5 /* &.repetition */))) != 0) {
									has_shift_action = uint8(True)
								}
								break
							case TSParseActionTypeReduce:
								if int32(*(*Uint8_t)(unsafe.Pointer((bp + 16 /* &action */ /* &.reduce */) + 1 /* &.child_count */))) > 0 {
									ts_reduce_action_set_add(tls, (self + 1240 /* &.reduce_actions */), ReduceAction{Count: Uint32_t(*(*Uint8_t)(unsafe.Pointer(bp + 16 /* &action */ /* &.reduce */ + 1 /* &.child_count */))), Symbol: *(*TSSymbol)(unsafe.Pointer(bp + 16 /* &action */ /* &.reduce */ + 2 /* &.symbol */)), Dynamic_precedence: int32(*(*Int16_t)(unsafe.Pointer(bp + 16 /* &action */ /* &.reduce */ + 4 /* &.dynamic_precedence */))), Production_id: *(*Uint16_t)(unsafe.Pointer(bp + 16 /* &action */ /* &.reduce */ + 6 /* &.production_id */))})
								}
								break
							default:
								break
							}

						}
						goto __11
					__11:
						i++
						goto __10
						goto __12
					__12:
						;
					}

				}
				goto __8
			__8:
				symbol++
				goto __7
				goto __9
			__9:
				;
			}

			var reduction_version StackVersion = libc.Uint32(libc.Uint32FromInt32(-1))
			{
				var i1 Uint32_t = Uint32_t(0)
			__13:
				if !(i1 < (*TSParser)(unsafe.Pointer(self)).Reduce_actions.Size) {
					goto __15
				}
				{
					var action = *(*ReduceAction)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Reduce_actions.Contents + uintptr(i1)*16))

					reduction_version = ts_parser__reduce(tls,
						self, version, action.Symbol, action.Count,
						action.Dynamic_precedence, action.Production_id,
						uint8(True), uint8(False))

				}
				goto __14
			__14:
				i1++
				goto __13
				goto __15
			__15:
				;
			}

			if has_shift_action != 0 {
				can_shift_lookahead_symbol = uint8(True)
			} else if (reduction_version != (libc.Uint32(libc.Uint32FromInt32(-1)))) && (i < sMAX_VERSION_COUNT) {
				Xts_stack_renumber_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, reduction_version, version)
				goto __2
			} else if int32(lookahead_symbol) != 0 {
				Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
			}

			if version == starting_version {
				version = version_count
			} else {
				version++
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	return can_shift_lookahead_symbol
}

func ts_parser__handle_error(tls *libc.TLS, self uintptr, version StackVersion, lookahead_symbol TSSymbol) { /* parser.c:1065:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var previous_version_count Uint32_t = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)

	// Perform any reductions that can happen in this state, regardless of the lookahead. After
	// skipping one or more invalid tokens, the parser might find a token that would have allowed
	// a reduction to take place.
	ts_parser__do_all_potential_reductions(tls, self, version, uint16(0))
	var version_count Uint32_t = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
	var position = Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)

	// Push a discontinuity onto the stack. Merge all of the stack versions that
	// were created in the previous step.
	var did_insert_missing_token uint8 = uint8(False)
	{
		var v StackVersion = version
	__1:
		if !(v < version_count) {
			goto __3
		}
		{
			if !(did_insert_missing_token != 0) {
				var state TSStateId = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, v)
				{
					var missing_symbol TSSymbol = TSSymbol(1)
				__4:
					if !(Uint32_t(missing_symbol) < (*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Token_count) {
						goto __6
					}
					{
						var state_after_missing_symbol TSStateId = ts_language_next_state(tls,
							(*TSParser)(unsafe.Pointer(self)).Language, state, missing_symbol)
						if (int32(state_after_missing_symbol) == 0) || (int32(state_after_missing_symbol) == int32(state)) {
							goto __5
						}

						if ts_language_has_reduce_action(tls,
							(*TSParser)(unsafe.Pointer(self)).Language,
							state_after_missing_symbol,
							lookahead_symbol) != 0 {
							// In case the parser is currently outside of any included range, the lexer will
							// snap to the beginning of the next included range. The missing token's padding
							// must be assigned to position it within the next included range.
							Xts_lexer_reset(tls, (self /* &.lexer */), position)
							Xts_lexer_mark_end(tls, (self /* &.lexer */))
							var padding = length_sub(tls, (*TSParser)(unsafe.Pointer(self)).Lexer.Token_end_position, position)

							var version_with_missing_tree StackVersion = Xts_stack_copy_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, v)
							var missing_tree = Xts_subtree_new_missing_leaf(tls,
								(self + 1200 /* &.tree_pool */), missing_symbol, padding, (*TSParser)(unsafe.Pointer(self)).Language)
							Xts_stack_push(tls,
								(*TSParser)(unsafe.Pointer(self)).Stack, version_with_missing_tree,
								missing_tree, uint8(False),
								state_after_missing_symbol)

							if ts_parser__do_all_potential_reductions(tls,
								self, version_with_missing_tree,
								lookahead_symbol) != 0 {
								if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
									libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
										if X_USE_FORTIFY_LEVEL > 1 {
											return 1
										}
										return 0
									}()), ts+1804 /* "recover_with_mis..." */, libc.VaList(bp, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, missing_symbol), int32(Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version_with_missing_tree))))
									ts_parser__log(tls, self)
								}

								did_insert_missing_token = uint8(True)
								goto __6
							}
						}

					}
					goto __5
				__5:
					missing_symbol++
					goto __4
					goto __6
				__6:
					;
				}
			}

			Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, v, Subtree{}, uint8(False), uint16(ERROR_STATE))
			if v == version {
				v = previous_version_count
			} else {
				v = (v + StackVersion(1))
			}

		}
		goto __2
	__2:
		;
		goto __1
		goto __3
	__3:
		;
	}

	{
		var i uint32 = previous_version_count
	__7:
		if !(i < version_count) {
			goto __9
		}
		{
			var did_merge uint8 = Xts_stack_merge(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, previous_version_count)
			if libc.X__builtin_expect(tls, libc.BoolInt64(!(did_merge != 0)), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__72)), ts+883 /* "upstream/tree-si..." */, 1139, ts+1845 /* "did_merge" */)
			} else {
			}

		}
		goto __8
	__8:
		i++
		goto __7
		goto __9
	__9:
		;
	}

	Xts_stack_record_summary(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, sMAX_SUMMARY_DEPTH)
	if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
		Xts_stack_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
		libc.Xfputs(tls, ts+990 /* "\n\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
	}

}

var __func__72 = *(*[24]int8)(unsafe.Pointer(ts + 1855 /* "ts_parser__handl..." */)) /* parser.c:1069:3 */

func ts_parser__recover_to_state(tls *libc.TLS, self uintptr, version StackVersion, depth uint32, goal_state TSStateId) uint8 { /* parser.c:1146:13: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*StackSliceArray)(unsafe.Pointer(bp + 24 /* pop */)) = Xts_stack_pop_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, depth)
	var previous_version StackVersion = libc.Uint32(libc.Uint32FromInt32(-1))

	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*StackSliceArray)(unsafe.Pointer(bp+24 /* &pop */)).Size) {
			goto __3
		}
		{
			*(*StackSlice)(unsafe.Pointer(bp /* slice */)) = *(*StackSlice)(unsafe.Pointer((*StackSliceArray)(unsafe.Pointer(bp+24 /* &pop */)).Contents + uintptr(i)*24))

			if (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version == previous_version {
				Xts_subtree_array_delete(tls, (self + 1200 /* &.tree_pool */), (bp /* &slice */ /* &.subtrees */))
				array__erase(tls, bp+24 /* &pop */, uint64(unsafe.Sizeof(StackSlice{})), libc.PostDecUint32(&i, 1))
				goto __2
			}

			if int32(Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version)) != int32(goal_state) {
				Xts_stack_halt(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version)
				Xts_subtree_array_delete(tls, (self + 1200 /* &.tree_pool */), (bp /* &slice */ /* &.subtrees */))
				array__erase(tls, bp+24 /* &pop */, uint64(unsafe.Sizeof(StackSlice{})), libc.PostDecUint32(&i, 1))
				goto __2
			}

			*(*SubtreeArray)(unsafe.Pointer(bp + 56 /* error_trees */)) = Xts_stack_pop_error(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version)
			if (*SubtreeArray)(unsafe.Pointer(bp+56 /* &error_trees */)).Size > Uint32_t(0) {
				if libc.X__builtin_expect(tls, libc.BoolInt64(!((*SubtreeArray)(unsafe.Pointer(bp+56 /* &error_trees */)).Size == Uint32_t(1))), int64(0)) != 0 {
					libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__73)), ts+883 /* "upstream/tree-si..." */, 1173, ts+1879 /* "error_trees.size..." */)
				} else {
				}
				*(*Subtree)(unsafe.Pointer(bp + 40 /* error_tree */)) = *(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(bp + 56 /* &error_trees */)).Contents))
				var error_child_count Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* error_tree */)))
				if error_child_count > Uint32_t(0) {
					array__splice(tls, (bp /* &slice */ /* &.subtrees */), uint64(unsafe.Sizeof(Subtree{})), uint32(0), uint32(0), error_child_count, func() uintptr {
						if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 40 /* &error_tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
							return uintptr(0)
						}
						return ((*(*uintptr)(unsafe.Pointer(bp + 40 /* &error_tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* &error_tree */)))).Child_count)*16)
					}())
					{
						var j uint32 = uint32(0)
					__4:
						if !(j < error_child_count) {
							goto __6
						}
						{
							Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer((*StackSlice)(unsafe.Pointer(bp /* &slice */)).Subtrees.Contents + uintptr(j)*16)))

						}
						goto __5
					__5:
						j++
						goto __4
						goto __6
					__6:
						;
					}
				}
				Xts_subtree_array_delete(tls, (self + 1200 /* &.tree_pool */), bp+56 /* &error_trees */)
			}

			Xts_subtree_array_remove_trailing_extras(tls, (bp /* &slice */ /* &.subtrees */), (self + 1272 /* &.trailing_extras */))

			if (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Subtrees.Size > Uint32_t(0) {
				var error = Xts_subtree_new_error_node(tls, (bp /* &slice */ /* &.subtrees */), uint8(True), (*TSParser)(unsafe.Pointer(self)).Language)
				Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version, error, uint8(False), goal_state)
			} else {
				array__delete(tls, (bp /* &slice */ /* &.subtrees */))
			}

			{
				var j uint32 = uint32(0)
			__7:
				if !(j < (*TSParser)(unsafe.Pointer(self)).Trailing_extras.Size) {
					goto __9
				}
				{
					var tree = *(*Subtree)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Trailing_extras.Contents + uintptr(j)*16))
					Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version, tree, uint8(False), goal_state)

				}
				goto __8
			__8:
				j++
				goto __7
				goto __9
			__9:
				;
			}

			previous_version = (*StackSlice)(unsafe.Pointer(bp /* &slice */)).Version

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	return (uint8(libc.Bool32(previous_version != (libc.Uint32(libc.Uint32FromInt32(-1))))))
}

var __func__73 = *(*[28]int8)(unsafe.Pointer(ts + 1901 /* "ts_parser__recov..." */)) /* parser.c:1151:3 */

func ts_parser__recover(tls *libc.TLS, self uintptr, version StackVersion, lookahead Subtree) { /* parser.c:1205:13: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var did_recover uint8 = uint8(False)
	var previous_version_count uint32 = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
	var position = Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var summary uintptr = Xts_stack_get_summary(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var node_count_since_error uint32 = Xts_stack_node_count_since_error(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var current_error_cost uint32 = Xts_stack_error_cost(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)

	// When the parser is in the error state, there are two strategies for recovering with a
	// given lookahead token:
	// 1. Find a previous state on the stack in which that lookahead token would be valid. Then,
	//    create a new stack version that is in that state again. This entails popping all of the
	//    subtrees that have been pushed onto the stack since that previous state, and wrapping
	//    them in an ERROR node.
	// 2. Wrap the lookahead token in an ERROR node, push that ERROR node onto the stack, and
	//    move on to the next lookahead token, remaining in the error state.
	//
	// First, try the strategy 1. Upon entering the error state, the parser recorded a summary
	// of the previous parse states and their depths. Look at each state in the summary, to see
	// if the current lookahead token would be valid in that state.
	if (summary != 0) && !(ts_subtree_is_error(tls, lookahead) != 0) {
		{
			var i uint32 = uint32(0)
		__1:
			if !(i < (*StackSummary)(unsafe.Pointer(summary)).Size) {
				goto __3
			}
			{
				var entry = *(*StackSummaryEntry)(unsafe.Pointer((*StackSummary)(unsafe.Pointer(summary)).Contents + uintptr(i)*20))

				if int32(entry.State) == ERROR_STATE {
					goto __2
				}
				if entry.Position.Bytes == position.Bytes {
					goto __2
				}
				var depth uint32 = entry.Depth
				if node_count_since_error > uint32(0) {
					depth++
				}

				// Do not recover in ways that create redundant stack versions.
				var would_merge uint8 = uint8(False)
				{
					var j uint32 = uint32(0)
				__4:
					if !(j < previous_version_count) {
						goto __6
					}
					{
						if (int32(Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, j)) == int32(entry.State)) && (Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, j).Bytes == position.Bytes) {
							would_merge = uint8(True)
							goto __6
						}

					}
					goto __5
				__5:
					j++
					goto __4
					goto __6
				__6:
					;
				}
				if would_merge != 0 {
					goto __2
				}

				// Do not recover if the result would clearly be worse than some existing stack version.
				var new_cost uint32 = (((current_error_cost + (entry.Depth * uint32(ERROR_COST_PER_SKIPPED_TREE))) + ((position.Bytes - entry.Position.Bytes) * Uint32_t(ERROR_COST_PER_SKIPPED_CHAR))) + ((position.Extent.Row - entry.Position.Extent.Row) * Uint32_t(ERROR_COST_PER_SKIPPED_LINE)))
				if ts_parser__better_version_exists(tls, self, version, uint8(False), new_cost) != 0 {
					goto __3
				}

				// If the current lookahead token is valid in some previous state, recover to that state.
				// Then stop looking for further recoveries.
				if ts_language_has_actions(tls, (*TSParser)(unsafe.Pointer(self)).Language, entry.State, ts_subtree_symbol(tls, lookahead)) != 0 {
					if ts_parser__recover_to_state(tls, self, version, depth, entry.State) != 0 {
						did_recover = uint8(True)
						if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
							libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
								if X_USE_FORTIFY_LEVEL > 1 {
									return 1
								}
								return 0
							}()), ts+1929 /* "recover_to_previ..." */, libc.VaList(bp, int32(entry.State), depth))
							ts_parser__log(tls, self)
						}

						if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
							Xts_stack_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
							libc.Xfputs(tls, ts+990 /* "\n\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
						}

						goto __3
					}
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	// In the process of attempting to recover, some stack versions may have been created
	// and subsequently halted. Remove those versions.
	{
		var i uint32 = previous_version_count
	__7:
		if !(i < Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)) {
			goto __9
		}
		{
			if !(Xts_stack_is_active(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i) != 0) {
				Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, libc.PostDecUint32(&i, 1))
			}

		}
		goto __8
	__8:
		i++
		goto __7
		goto __9
	__9:
		;
	}

	// If strategy 1 succeeded, a new stack version will have been created which is able to handle
	// the current lookahead token. Now, in addition, try strategy 2 described above: skip the
	// current lookahead token by wrapping it in an ERROR node.

	// Don't pursue this additional strategy if there are already too many stack versions.
	if (did_recover != 0) && (Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack) > sMAX_VERSION_COUNT) {
		Xts_stack_halt(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), lookahead)
		return
	}

	// If the parser is still in the error state at the end of the file, just wrap everything
	// in an ERROR node and terminate.
	if ts_subtree_is_eof(tls, lookahead) != 0 {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+1968 /* "recover_eof" */, 0)
			ts_parser__log(tls, self)
		}

		*(*SubtreeArray)(unsafe.Pointer(bp + 24 /* children */)) = SubtreeArray{}
		var parent = Xts_subtree_new_error_node(tls, bp+24 /* &children */, uint8(False), (*TSParser)(unsafe.Pointer(self)).Language)
		Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, parent, uint8(False), uint16(1))
		ts_parser__accept(tls, self, version, lookahead)
		return
	}

	// Do not recover if the result would clearly be worse than some existing stack version.
	var new_cost uint32 = (((current_error_cost + uint32(ERROR_COST_PER_SKIPPED_TREE)) + (ts_subtree_total_bytes(tls, lookahead) * Uint32_t(ERROR_COST_PER_SKIPPED_CHAR))) + (ts_subtree_total_size(tls, lookahead).Extent.Row * Uint32_t(ERROR_COST_PER_SKIPPED_LINE)))
	if ts_parser__better_version_exists(tls, self, version, uint8(False), new_cost) != 0 {
		Xts_stack_halt(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), lookahead)
		return
	}

	// If the current lookahead token is an extra token, mark it as extra. This means it won't
	// be counted in error cost calculations.
	// var n uint32 at bp+40, 4

	var actions uintptr = ts_language_actions(tls, (*TSParser)(unsafe.Pointer(self)).Language, uint16(1), ts_subtree_symbol(tls, lookahead), bp+40 /* &n */)
	if ((*(*uint32)(unsafe.Pointer(bp + 40 /* n */)) > uint32(0)) && (int32(*(*Uint8_t)(unsafe.Pointer(actions + uintptr((*(*uint32)(unsafe.Pointer(bp + 40 /* n */))-uint32(1)))*8))) == TSParseActionTypeShift)) && (*(*uint8)(unsafe.Pointer((actions + uintptr((*(*uint32)(unsafe.Pointer(bp + 40 /* n */))-uint32(1)))*8 /* &.shift */) + 4 /* &.extra */)) != 0) {
		*(*MutableSubtree)(unsafe.Pointer(bp + 48 /* mutable_lookahead */)) = Xts_subtree_make_mut(tls, (self + 1200 /* &.tree_pool */), lookahead)
		ts_subtree_set_extra(tls, bp+48 /* &mutable_lookahead */)
		lookahead = ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 48 /* mutable_lookahead */)))
	}

	// Wrap the lookahead token in an ERROR.
	if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
		libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+1980 /* "skip_token symbo..." */, libc.VaList(bp+16, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, lookahead))))
		ts_parser__log(tls, self)
	}

	*(*SubtreeArray)(unsafe.Pointer(bp + 64 /* children */)) = SubtreeArray{}
	array__reserve(tls, bp+64 /* &children */, uint64(unsafe.Sizeof(Subtree{})), uint32(1))
	array__grow(tls, bp+64 /* &children */, uint64(1), uint64(unsafe.Sizeof(Subtree{})))
	*(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer((bp + 64 /* &children */))).Contents + uintptr(libc.PostIncUint32(&(*SubtreeArray)(unsafe.Pointer(bp+64 /* &children */)).Size, 1))*16)) = lookahead
	var error_repeat = Xts_subtree_new_node(tls,
		(uint16((int32(libc.Uint16FromInt32(-1))) - 1)),
		bp+64, /* &children */
		uint32(0),
		(*TSParser)(unsafe.Pointer(self)).Language)

	// If other tokens have already been skipped, so there is already an ERROR at the top of the
	// stack, then pop that ERROR off the stack and wrap the two ERRORs together into one larger
	// ERROR.
	if node_count_since_error > uint32(0) {
		var pop = Xts_stack_pop_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, uint32(1))

		// TODO: Figure out how to make this condition occur.
		// See https://github.com/atom/atom/issues/18450#issuecomment-439579778
		// If multiple stack versions have merged at this point, just pick one of the errors
		// arbitrarily and discard the rest.
		if pop.Size > Uint32_t(1) {
			{
				var i uint32 = uint32(1)
			__10:
				if !(i < pop.Size) {
					goto __12
				}
				{
					Xts_subtree_array_delete(tls, (self + 1200 /* &.tree_pool */), (pop.Contents + uintptr(i)*24 /* &.subtrees */))

				}
				goto __11
			__11:
				i++
				goto __10
				goto __12
			__12:
				;
			}
			for Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack) > ((*StackSlice)(unsafe.Pointer(pop.Contents)).Version + StackVersion(1)) {
				Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, ((*StackSlice)(unsafe.Pointer(pop.Contents)).Version + StackVersion(1)))
			}
		}

		Xts_stack_renumber_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*StackSlice)(unsafe.Pointer(pop.Contents)).Version, version)
		array__grow(tls, (pop.Contents /* &.subtrees */), uint64(1), uint64(unsafe.Sizeof(Subtree{})))
		*(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer((pop.Contents /* &.subtrees */))).Contents + uintptr(libc.PostIncUint32(&(*SubtreeArray)(unsafe.Pointer((pop.Contents /* &.subtrees */))).Size, 1))*16)) = ts_subtree_from_mut(tls, error_repeat)
		error_repeat = Xts_subtree_new_node(tls,
			(uint16((int32(libc.Uint16FromInt32(-1))) - 1)),
			(pop.Contents /* &.subtrees */),
			uint32(0),
			(*TSParser)(unsafe.Pointer(self)).Language)
	}

	// Push the new ERROR onto the stack.
	Xts_stack_push(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, ts_subtree_from_mut(tls, error_repeat), uint8(False), uint16(ERROR_STATE))
	if ts_subtree_has_external_tokens(tls, lookahead) != 0 {
		Xts_stack_set_last_external_token(tls,
			(*TSParser)(unsafe.Pointer(self)).Stack, version, Xts_subtree_last_external_token(tls, lookahead))
	}
}

func ts_parser__advance(tls *libc.TLS, self uintptr, version StackVersion, allow_node_reuse uint8) uint8 { /* parser.c:1373:13: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	*(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)) = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
	var position Uint32_t = Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version).Bytes
	var last_external_token = Xts_stack_last_external_token(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)

	var did_reuse uint8 = uint8(True)
	*(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)) = Subtree{}
	*(*TableEntry)(unsafe.Pointer(bp + 48 /* table_entry */)) = TableEntry{}

	// If possible, reuse a node from the previous syntax tree.
	if allow_node_reuse != 0 {
		*(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)) = ts_parser__reuse_node(tls,
			self, version, bp+40 /* &state */, position, last_external_token, bp+48 /* &table_entry */)
	}

	// If no node from the previous syntax tree could be reused, then try to
	// reuse the token previously returned by the lexer.
	if !(int32(*(*uintptr)(unsafe.Pointer(bp + 64 /* &lookahead */))) != 0) {
		did_reuse = uint8(False)
		*(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)) = ts_parser__get_cached_token(tls,
			self, *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)), uint64(position), last_external_token, bp+48 /* &table_entry */)
	}

	var needs_lex uint8 = libc.BoolUint8(!(*(*uintptr)(unsafe.Pointer(bp + 64 /* &lookahead */)) != 0))
	for {
		// Otherwise, re-run the lexer.
		if needs_lex != 0 {
			needs_lex = uint8(False)
			*(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)) = ts_parser__lex(tls, self, version, *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)))

			if *(*uintptr)(unsafe.Pointer(bp + 64 /* &lookahead */)) != 0 {
				ts_parser__set_cached_token(tls, self, uint64(position), last_external_token, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
				Xts_language_table_entry(tls, (*TSParser)(unsafe.Pointer(self)).Language, *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)), ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */))), bp+48 /* &table_entry */)
			} else {
				Xts_language_table_entry(tls, (*TSParser)(unsafe.Pointer(self)).Language, *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)), uint16(Ts_builtin_sym_end), bp+48 /* &table_entry */)
			}
		}

		// If a cancellation flag or a timeout was provided, then check every
		// time a fixed number of parse actions has been processed.
		if libc.PreIncUint32(&(*TSParser)(unsafe.Pointer(self)).Operation_count, 1) == sOP_COUNT_PER_TIMEOUT_CHECK {
			(*TSParser)(unsafe.Pointer(self)).Operation_count = uint32(0)
		}
		if ((*TSParser)(unsafe.Pointer(self)).Operation_count == uint32(0)) && ((((*TSParser)(unsafe.Pointer(self)).Cancellation_flag != 0) && (atomic_load(tls, (*TSParser)(unsafe.Pointer(self)).Cancellation_flag) != 0)) || (!(clock_is_null(tls, (*TSParser)(unsafe.Pointer(self)).End_clock) != 0) && (clock_is_gt(tls, clock_now(tls), (*TSParser)(unsafe.Pointer(self)).End_clock) != 0))) {
			Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
			return uint8(False)
		}

		// Process each parse action for the current lookahead token in
		// the current state. If there are multiple actions, then this is
		// an ambiguous state. REDUCE actions always create a new stack
		// version, whereas SHIFT actions update the existing stack version
		// and terminate this loop.
		var last_reduction_version StackVersion = libc.Uint32(libc.Uint32FromInt32(-1))
		{
			var i Uint32_t = Uint32_t(0)
		__1:
			if !(i < (*TableEntry)(unsafe.Pointer(bp+48 /* &table_entry */)).Action_count) {
				goto __3
			}
			{
				*(*TSParseAction)(unsafe.Pointer(bp + 80 /* action */)) = *(*TSParseAction)(unsafe.Pointer((*TableEntry)(unsafe.Pointer(bp+48 /* &table_entry */)).Actions + uintptr(i)*8))

				switch int32(*(*Uint8_t)(unsafe.Pointer(bp + 80 /* &action */))) {
				case TSParseActionTypeShift:
					{
						if *(*uint8)(unsafe.Pointer(bp + 80 /* &action */ /* &.shift */ + 5 /* &.repetition */)) != 0 {
							break
						}
						var next_state TSStateId
						if *(*uint8)(unsafe.Pointer(bp + 80 /* &action */ /* &.shift */ + 4 /* &.extra */)) != 0 {
							next_state = *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */))
							if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
								libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
									if X_USE_FORTIFY_LEVEL > 1 {
										return 1
									}
									return 0
								}()), ts+2001 /* "shift_extra" */, 0)
								ts_parser__log(tls, self)
							}

						} else {
							next_state = *(*TSStateId)(unsafe.Pointer(bp + 80 /* &action */ /* &.shift */ + 2 /* &.state */))
							if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
								libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
									if X_USE_FORTIFY_LEVEL > 1 {
										return 1
									}
									return 0
								}()), ts+2013 /* "shift state:%u" */, libc.VaList(bp, int32(next_state)))
								ts_parser__log(tls, self)
							}

						}

						if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */))) > Uint32_t(0) {
							ts_parser__breakdown_lookahead(tls, self, bp+64 /* &lookahead */, *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)), (self + 1360 /* &.reusable_node */))
							next_state = ts_language_next_state(tls, (*TSParser)(unsafe.Pointer(self)).Language, *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)), ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */))))
						}

						ts_parser__shift(tls, self, version, next_state, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)), *(*uint8)(unsafe.Pointer(bp + 80 /* &action */ /* &.shift */ + 4 /* &.extra */)))
						if did_reuse != 0 {
							reusable_node_advance(tls, (self + 1360 /* &.reusable_node */))
						}
						return uint8(True)

					}

				case TSParseActionTypeReduce:
					{
						var is_fragile uint8 = (uint8(libc.Bool32((*TableEntry)(unsafe.Pointer(bp+48 /* &table_entry */)).Action_count > Uint32_t(1))))
						var end_of_non_terminal_extra uint8 = (uint8(libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 64 /* &lookahead */)) == (uintptr(0)))))
						if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
							libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
								if X_USE_FORTIFY_LEVEL > 1 {
									return 1
								}
								return 0
							}()), ts+2028 /* "reduce sym:%s, c..." */, libc.VaList(bp+8, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, *(*TSSymbol)(unsafe.Pointer(bp + 80 /* &action */ /* &.reduce */ + 2 /* &.symbol */))), int32(*(*Uint8_t)(unsafe.Pointer(bp + 80 /* &action */ /* &.reduce */ + 1 /* &.child_count */)))))
							ts_parser__log(tls, self)
						}

						var reduction_version StackVersion = ts_parser__reduce(tls,
							self, version, *(*TSSymbol)(unsafe.Pointer(bp + 80 /* &action */ /* &.reduce */ + 2 /* &.symbol */)), uint32(*(*Uint8_t)(unsafe.Pointer(bp + 80 /* &action */ /* &.reduce */ + 1 /* &.child_count */))),
							int32(*(*Int16_t)(unsafe.Pointer(bp + 80 /* &action */ /* &.reduce */ + 4 /* &.dynamic_precedence */))), *(*Uint16_t)(unsafe.Pointer(bp + 80 /* &action */ /* &.reduce */ + 6 /* &.production_id */)),
							is_fragile, end_of_non_terminal_extra)
						if reduction_version != (libc.Uint32(libc.Uint32FromInt32(-1))) {
							last_reduction_version = reduction_version
						}
						break

					}

				case TSParseActionTypeAccept:
					{
						if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
							libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
								if X_USE_FORTIFY_LEVEL > 1 {
									return 1
								}
								return 0
							}()), ts+2058 /* "accept" */, 0)
							ts_parser__log(tls, self)
						}

						ts_parser__accept(tls, self, version, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
						return uint8(True)

					}

				case TSParseActionTypeRecover:
					{
						if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */))) > Uint32_t(0) {
							ts_parser__breakdown_lookahead(tls, self, bp+64 /* &lookahead */, uint16(ERROR_STATE), (self + 1360 /* &.reusable_node */))
						}

						ts_parser__recover(tls, self, version, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
						if did_reuse != 0 {
							reusable_node_advance(tls, (self + 1360 /* &.reusable_node */))
						}
						return uint8(True)

					}
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}

		// If a reduction was performed, then replace the current stack version
		// with one of the stack versions created by a reduction, and continue
		// processing this version of the stack with the same lookahead symbol.
		if last_reduction_version != (libc.Uint32(libc.Uint32FromInt32(-1))) {
			Xts_stack_renumber_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, last_reduction_version, version)
			if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
				Xts_stack_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
				libc.Xfputs(tls, ts+990 /* "\n\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
			}

			*(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)) = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)

			// At the end of a non-terminal extra rule, the lexer will return a
			// null subtree, because the parser needs to perform a fixed reduction
			// regardless of the lookahead node. After performing that reduction,
			// (and completing the non-terminal extra rule) run the lexer again based
			// on the current parse state.
			if !(int32(*(*uintptr)(unsafe.Pointer(bp + 64 /* &lookahead */))) != 0) {
				needs_lex = uint8(True)
				continue
			}

			Xts_language_table_entry(tls,
				(*TSParser)(unsafe.Pointer(self)).Language,
				*(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)),
				ts_subtree_leaf_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */))),
				bp+48 /* &table_entry */)
			continue
		}

		if !(int32(*(*uintptr)(unsafe.Pointer(bp + 64 /* &lookahead */))) != 0) {
			Xts_stack_pause(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, uint16(Ts_builtin_sym_end))
			return uint8(True)
		}

		// If there were no parse actions for the current lookahead token, then
		// it is not valid in this state. If the current lookahead token is a
		// keyword, then switch to treating it as the normal word token if that
		// token is valid in this state.
		if (ts_subtree_is_keyword(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */))) != 0) && (int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))) != int32((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Keyword_capture_token)) {
			Xts_language_table_entry(tls, (*TSParser)(unsafe.Pointer(self)).Language, *(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)), (*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Keyword_capture_token, bp+48 /* &table_entry */)
			if (*TableEntry)(unsafe.Pointer(bp+48 /* &table_entry */)).Action_count > Uint32_t(0) {
				if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
					libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
						if X_USE_FORTIFY_LEVEL > 1 {
							return 1
						}
						return 0
					}()), ts+2065 /* "switch from_keyw..." */, libc.VaList(bp+24, Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))), Xts_language_symbol_name(tls, (*TSParser)(unsafe.Pointer(self)).Language, (*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Keyword_capture_token)))
					ts_parser__log(tls, self)
				}

				*(*MutableSubtree)(unsafe.Pointer(bp + 88 /* mutable_lookahead */)) = Xts_subtree_make_mut(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
				Xts_subtree_set_symbol(tls, bp+88 /* &mutable_lookahead */, (*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).Keyword_capture_token, (*TSParser)(unsafe.Pointer(self)).Language)
				*(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)) = ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 88 /* mutable_lookahead */)))
				continue
			}
		}

		// If the current lookahead token is not valid and the parser is
		// already in the error state, restart the error recovery process.
		// TODO - can this be unified with the other `RECOVER` case above?
		if int32(*(*TSStateId)(unsafe.Pointer(bp + 40 /* state */))) == ERROR_STATE {
			ts_parser__recover(tls, self, version, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
			return uint8(True)
		}

		// If the current lookahead token is not valid and the previous
		// subtree on the stack was reused from an old tree, it isn't actually
		// valid to reuse it. Remove it from the stack, and in its place,
		// push each of its children. Then try again to process the current
		// lookahead.
		if ts_parser__breakdown_top_of_stack(tls, self, version) != 0 {
			*(*TSStateId)(unsafe.Pointer(bp + 40 /* state */)) = Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)
			Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
			needs_lex = uint8(True)
			continue
		}

		// At this point, the current lookahead token is definitely not valid
		// for this parse stack version. Mark this version as paused and continue
		// processing any other stack versions that might exist. If some other
		// version advances successfully, then this version can simply be removed.
		// But if all versions end up paused, then error recovery is needed.
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+2106 /* "detect_error" */, 0)
			ts_parser__log(tls, self)
		}

		Xts_stack_pause(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version, ts_subtree_leaf_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */))))
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), *(*Subtree)(unsafe.Pointer(bp + 64 /* lookahead */)))
		return uint8(True)
	}
	return uint8(0)
}

func ts_parser__condense_stack(tls *libc.TLS, self uintptr) uint32 { /* parser.c:1587:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var made_changes uint8 = uint8(False)
	var min_error_cost uint32 = ((uint32(0x7fffffff) * 2) + 1)
	{
		var i StackVersion = StackVersion(0)
	__1:
		if !(i < Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)) {
			goto __3
		}
		{
			// Prune any versions that have been marked for removal.
			if Xts_stack_is_halted(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i) != 0 {
				Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i)
				i--
				goto __2
			}

			// Keep track of the minimum error cost of any stack version so
			// that it can be returned.
			var status_i = ts_parser__version_status(tls, self, i)
			if !(int32(status_i.Is_in_error) != 0) && (status_i.Cost < min_error_cost) {
				min_error_cost = status_i.Cost
			}

			// Examine each pair of stack versions, removing any versions that
			// are clearly worse than another version. Ensure that the versions
			// are ordered from most promising to least promising.
			{
				var j StackVersion = StackVersion(0)
			__4:
				if !(j < i) {
					goto __6
				}
				{
					var status_j = ts_parser__version_status(tls, self, j)

					switch ts_parser__compare_versions(tls, self, status_j, status_i) {
					case ErrorComparisonTakeLeft:
						made_changes = uint8(True)
						Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i)
						i--
						j = i
						break

					case ErrorComparisonPreferLeft:
						fallthrough
					case ErrorComparisonNone:
						if Xts_stack_merge(tls, (*TSParser)(unsafe.Pointer(self)).Stack, j, i) != 0 {
							made_changes = uint8(True)
							i--
							j = i
						}
						break

					case ErrorComparisonPreferRight:
						made_changes = uint8(True)
						if Xts_stack_merge(tls, (*TSParser)(unsafe.Pointer(self)).Stack, j, i) != 0 {
							i--
							j = i
						} else {
							Xts_stack_swap_versions(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i, j)
						}
						break

					case ErrorComparisonTakeRight:
						made_changes = uint8(True)
						Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, j)
						i--
						j--
						break
					}

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
				;
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	// Enfore a hard upper bound on the number of stack versions by
	// discarding the least promising versions.
	for Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack) > sMAX_VERSION_COUNT {
		Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, sMAX_VERSION_COUNT)
		made_changes = uint8(True)
	}

	// If the best-performing stack version is currently paused, or all
	// versions are paused, then resume the best paused version and begin
	// the error recovery process. Otherwise, remove the paused versions.
	if Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack) > Uint32_t(0) {
		var has_unpaused_version uint8 = uint8(False)
		{
			var i StackVersion = StackVersion(0)
			var n StackVersion = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
		__7:
			if !(i < n) {
				goto __9
			}
			{
				if Xts_stack_is_paused(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i) != 0 {
					if !(has_unpaused_version != 0) && ((*TSParser)(unsafe.Pointer(self)).Accept_count < sMAX_VERSION_COUNT) {
						if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
							libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
								if X_USE_FORTIFY_LEVEL > 1 {
									return 1
								}
								return 0
							}()), ts+2119 /* "resume version:%..." */, libc.VaList(bp, i))
							ts_parser__log(tls, self)
						}

						min_error_cost = Xts_stack_error_cost(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i)
						var lookahead_symbol TSSymbol = Xts_stack_resume(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i)
						ts_parser__handle_error(tls, self, i, lookahead_symbol)
						has_unpaused_version = uint8(True)
					} else {
						Xts_stack_remove_version(tls, (*TSParser)(unsafe.Pointer(self)).Stack, i)
						i--
						n--
					}
				} else {
					has_unpaused_version = uint8(True)
				}

			}
			goto __8
		__8:
			i++
			goto __7
			goto __9
		__9:
			;
		}
	}

	if made_changes != 0 {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+2137 /* "condense" */, 0)
			ts_parser__log(tls, self)
		}

		if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
			Xts_stack_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
			libc.Xfputs(tls, ts+990 /* "\n\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
		}

	}

	return min_error_cost
}

func ts_parser_has_outstanding_parse(tls *libc.TLS, self uintptr) uint8 { /* parser.c:1687:13: */
	return (uint8(libc.Bool32((int32(Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, uint32(0))) != 1) || (Xts_stack_node_count_since_error(tls, (*TSParser)(unsafe.Pointer(self)).Stack, uint32(0)) != uint32(0)))))
}

// Parser - Public

func Xts_parser_new(tls *libc.TLS) uintptr { /* parser.c:1696:10: */
	var self uintptr = ts_calloc_default(tls, uint64(1), uint64(unsafe.Sizeof(TSParser{})))
	Xts_lexer_init(tls, (self /* &.lexer */))
	(*ReduceActionSet)(unsafe.Pointer((self + 1240 /* &.reduce_actions */))).Size = Uint32_t(0)
	(*ReduceActionSet)(unsafe.Pointer((self + 1240 /* &.reduce_actions */))).Capacity = Uint32_t(0)
	(*ReduceActionSet)(unsafe.Pointer((self + 1240 /* &.reduce_actions */))).Contents = uintptr(0)
	array__reserve(tls, (self + 1240 /* &.reduce_actions */), uint64(unsafe.Sizeof(ReduceAction{})), uint32(4))
	(*TSParser)(unsafe.Pointer(self)).Tree_pool = Xts_subtree_pool_new(tls, uint32(32))
	(*TSParser)(unsafe.Pointer(self)).Stack = Xts_stack_new(tls, (self + 1200 /* &.tree_pool */))
	(*TSParser)(unsafe.Pointer(self)).Finished_tree = Subtree{}
	(*TSParser)(unsafe.Pointer(self)).Reusable_node = reusable_node_new(tls)
	(*TSParser)(unsafe.Pointer(self)).Dot_graph_file = uintptr(0)
	(*TSParser)(unsafe.Pointer(self)).Cancellation_flag = uintptr(0)
	(*TSParser)(unsafe.Pointer(self)).Timeout_duration = uint64(0)
	(*TSParser)(unsafe.Pointer(self)).End_clock = clock_null(tls)
	(*TSParser)(unsafe.Pointer(self)).Operation_count = uint32(0)
	(*TSParser)(unsafe.Pointer(self)).Old_tree = Subtree{}
	(*TSParser)(unsafe.Pointer(self)).Included_range_differences = TSRangeArray{}
	(*TSParser)(unsafe.Pointer(self)).Included_range_difference_index = uint32(0)
	ts_parser__set_cached_token(tls, self, uint64(0), Subtree{}, Subtree{})
	return self
}

func Xts_parser_delete(tls *libc.TLS, self uintptr) { /* parser.c:1717:6: */
	if !(self != 0) {
		return
	}

	Xts_parser_set_language(tls, self, uintptr(0))
	Xts_stack_delete(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
	if (*TSParser)(unsafe.Pointer(self)).Reduce_actions.Contents != 0 {
		array__delete(tls, (self + 1240 /* &.reduce_actions */))
	}
	if (*TSParser)(unsafe.Pointer(self)).Included_range_differences.Contents != 0 {
		array__delete(tls, (self + 1456 /* &.included_range_differences */))
	}
	if *(*uintptr)(unsafe.Pointer(self + 1440 /* &.old_tree */)) != 0 {
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), (*TSParser)(unsafe.Pointer(self)).Old_tree)
		(*TSParser)(unsafe.Pointer(self)).Old_tree = Subtree{}
	}
	Xts_lexer_delete(tls, (self /* &.lexer */))
	ts_parser__set_cached_token(tls, self, uint64(0), Subtree{}, Subtree{})
	Xts_subtree_pool_delete(tls, (self + 1200 /* &.tree_pool */))
	reusable_node_delete(tls, (self + 1360 /* &.reusable_node */))
	array__delete(tls, (self + 1272 /* &.trailing_extras */))
	array__delete(tls, (self + 1288 /* &.trailing_extras2 */))
	array__delete(tls, (self + 1304 /* &.scratch_trees */))
	ts_free_default(tls, self)
}

func Xts_parser_language(tls *libc.TLS, self uintptr) uintptr { /* parser.c:1742:18: */
	return (*TSParser)(unsafe.Pointer(self)).Language
}

func Xts_parser_set_language(tls *libc.TLS, self uintptr, language uintptr) uint8 { /* parser.c:1746:6: */
	if language != 0 {
		if (*TSLanguage)(unsafe.Pointer(language)).Version > Uint32_t(TREE_SITTER_LANGUAGE_VERSION) {
			return uint8(False)
		}
		if (*TSLanguage)(unsafe.Pointer(language)).Version < Uint32_t(TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION) {
			return uint8(False)
		}
	}

	if ((*TSParser)(unsafe.Pointer(self)).External_scanner_payload != 0) && ((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Destroy != 0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Destroy})).f(tls, (*TSParser)(unsafe.Pointer(self)).External_scanner_payload)
	}

	if (language != 0) && ((*TSLanguage)(unsafe.Pointer(language)).External_scanner.Create != 0) {
		(*TSParser)(unsafe.Pointer(self)).External_scanner_payload = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer(language)).External_scanner.Create})).f(tls)
	} else {
		(*TSParser)(unsafe.Pointer(self)).External_scanner_payload = uintptr(0)
	}

	(*TSParser)(unsafe.Pointer(self)).Language = language
	Xts_parser_reset(tls, self)
	return uint8(True)
}

func Xts_parser_logger(tls *libc.TLS, self uintptr) TSLogger { /* parser.c:1767:10: */
	return (*TSParser)(unsafe.Pointer(self)).Lexer.Logger
}

func Xts_parser_set_logger(tls *libc.TLS, self uintptr, logger TSLogger) { /* parser.c:1771:6: */
	(*TSParser)(unsafe.Pointer(self)).Lexer.Logger = logger
}

func Xts_parser_print_dot_graphs(tls *libc.TLS, self uintptr, fd int32) { /* parser.c:1775:6: */
	if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
		libc.Xfclose(tls, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
	}

	if fd >= 0 {
		(*TSParser)(unsafe.Pointer(self)).Dot_graph_file = libc.Xfdopen(tls, fd, ts+2146 /* "a" */)
	} else {
		(*TSParser)(unsafe.Pointer(self)).Dot_graph_file = uintptr(0)
	}
}

func Xts_parser_cancellation_flag(tls *libc.TLS, self uintptr) uintptr { /* parser.c:1787:14: */
	return (*TSParser)(unsafe.Pointer(self)).Cancellation_flag
}

func Xts_parser_set_cancellation_flag(tls *libc.TLS, self uintptr, flag uintptr) { /* parser.c:1791:6: */
	(*TSParser)(unsafe.Pointer(self)).Cancellation_flag = flag
}

func Xts_parser_timeout_micros(tls *libc.TLS, self uintptr) Uint64_t { /* parser.c:1795:10: */
	return duration_to_micros(tls, (*TSParser)(unsafe.Pointer(self)).Timeout_duration)
}

func Xts_parser_set_timeout_micros(tls *libc.TLS, self uintptr, timeout_micros Uint64_t) { /* parser.c:1799:6: */
	(*TSParser)(unsafe.Pointer(self)).Timeout_duration = duration_from_micros(tls, timeout_micros)
}

func Xts_parser_set_included_ranges(tls *libc.TLS, self uintptr, ranges uintptr, count Uint32_t) uint8 { /* parser.c:1803:6: */
	return Xts_lexer_set_included_ranges(tls, (self /* &.lexer */), ranges, count)
}

func Xts_parser_included_ranges(tls *libc.TLS, self uintptr, count uintptr) uintptr { /* parser.c:1811:15: */
	return Xts_lexer_included_ranges(tls, (self /* &.lexer */), count)
}

func Xts_parser_reset(tls *libc.TLS, self uintptr) { /* parser.c:1815:6: */
	if ((*TSParser)(unsafe.Pointer(self)).Language != 0) && ((*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Deserialize != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uint32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TSLanguage)(unsafe.Pointer((*TSParser)(unsafe.Pointer(self)).Language)).External_scanner.Deserialize})).f(tls, (*TSParser)(unsafe.Pointer(self)).External_scanner_payload, uintptr(0), uint32(0))
	}

	if *(*uintptr)(unsafe.Pointer(self + 1440 /* &.old_tree */)) != 0 {
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), (*TSParser)(unsafe.Pointer(self)).Old_tree)
		(*TSParser)(unsafe.Pointer(self)).Old_tree = Subtree{}
	}

	reusable_node_clear(tls, (self + 1360 /* &.reusable_node */))
	Xts_lexer_reset(tls, (self /* &.lexer */), length_zero(tls))
	Xts_stack_clear(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
	ts_parser__set_cached_token(tls, self, uint64(0), Subtree{}, Subtree{})
	if *(*uintptr)(unsafe.Pointer(self + 1256 /* &.finished_tree */)) != 0 {
		Xts_subtree_release(tls, (self + 1200 /* &.tree_pool */), (*TSParser)(unsafe.Pointer(self)).Finished_tree)
		(*TSParser)(unsafe.Pointer(self)).Finished_tree = Subtree{}
	}
	(*TSParser)(unsafe.Pointer(self)).Accept_count = uint32(0)
}

func Xts_parser_parse(tls *libc.TLS, self uintptr, old_tree uintptr, input TSInput) uintptr { /* parser.c:1836:8: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	if !(int32((*TSParser)(unsafe.Pointer(self)).Language) != 0) || !(int32(input.Read) != 0) {
		return uintptr(0)
	}

	Xts_lexer_set_input(tls, (self /* &.lexer */), input)

	(*TSRangeArray)(unsafe.Pointer((self + 1456 /* &.included_range_differences */))).Size = Uint32_t(0)
	(*TSParser)(unsafe.Pointer(self)).Included_range_difference_index = uint32(0)

	if ts_parser_has_outstanding_parse(tls, self) != 0 {
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+2148 /* "resume_parsing" */, 0)
			ts_parser__log(tls, self)
		}

	} else if old_tree != 0 {
		Xts_subtree_retain(tls, (*TSTree)(unsafe.Pointer(old_tree)).Root)
		(*TSParser)(unsafe.Pointer(self)).Old_tree = (*TSTree)(unsafe.Pointer(old_tree)).Root
		Xts_range_array_get_changed_ranges(tls,
			(*TSTree)(unsafe.Pointer(old_tree)).Included_ranges, (*TSTree)(unsafe.Pointer(old_tree)).Included_range_count,
			(*TSParser)(unsafe.Pointer(self)).Lexer.Included_ranges, (*TSParser)(unsafe.Pointer(self)).Lexer.Included_range_count,
			(self + 1456 /* &.included_range_differences */))
		reusable_node_reset(tls, (self + 1360 /* &.reusable_node */), (*TSTree)(unsafe.Pointer(old_tree)).Root)
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+2163 /* "parse_after_edit" */, 0)
			ts_parser__log(tls, self)
		}

		if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
			Xts_subtree_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Old_tree, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
			libc.Xfputs(tls, ts+2180 /* "\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
		}

		{
			var i uint32 = uint32(0)
		__1:
			if !(i < (*TSParser)(unsafe.Pointer(self)).Included_range_differences.Size) {
				goto __3
			}
			{
				var range1 uintptr = ((*TSParser)(unsafe.Pointer(self)).Included_range_differences.Contents + uintptr(i)*24)
				if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
					libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
						if X_USE_FORTIFY_LEVEL > 1 {
							return 1
						}
						return 0
					}()), ts+2182 /* "different_includ..." */, libc.VaList(bp, (*TSRange)(unsafe.Pointer(range1)).Start_byte, (*TSRange)(unsafe.Pointer(range1)).End_byte))
					ts_parser__log(tls, self)
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	} else {
		reusable_node_clear(tls, (self + 1360 /* &.reusable_node */))
		if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
			libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+2215 /* "new_parse" */, 0)
			ts_parser__log(tls, self)
		}

	}

	var position Uint32_t = Uint32_t(0)
	var last_position Uint32_t = Uint32_t(0)
	var version_count Uint32_t = Uint32_t(0)
	(*TSParser)(unsafe.Pointer(self)).Operation_count = uint32(0)
	if (*TSParser)(unsafe.Pointer(self)).Timeout_duration != 0 {
		(*TSParser)(unsafe.Pointer(self)).End_clock = clock_after(tls, clock_now(tls), (*TSParser)(unsafe.Pointer(self)).Timeout_duration)
	} else {
		(*TSParser)(unsafe.Pointer(self)).End_clock = clock_null(tls)
	}

	for ok := true; ok; ok = (version_count != Uint32_t(0)) {
		{
			var version StackVersion = StackVersion(0)
		__4:
			if !(func() bool {
				version_count = Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack)
				return (version < version_count)
			}()) {
				goto __6
			}
			{
				var allow_node_reuse uint8 = (uint8(libc.Bool32(version_count == Uint32_t(1))))
				for Xts_stack_is_active(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version) != 0 {
					if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
						libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
							if X_USE_FORTIFY_LEVEL > 1 {
								return 1
							}
							return 0
						}()), ts+2225 /* "process version:..." */, libc.VaList(bp+16, version, Xts_stack_version_count(tls, (*TSParser)(unsafe.Pointer(self)).Stack), int32(Xts_stack_state(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version)), (Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version).Extent.Row+Uint32_t(1)), Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version).Extent.Column))
						ts_parser__log(tls, self)
					}

					if !(ts_parser__advance(tls, self, version, allow_node_reuse) != 0) {
						return uintptr(0)
					}
					if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
						Xts_stack_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Stack, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
						libc.Xfputs(tls, ts+990 /* "\n\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
					}

					position = Xts_stack_position(tls, (*TSParser)(unsafe.Pointer(self)).Stack, version).Bytes
					if (position > last_position) || ((version > StackVersion(0)) && (position == last_position)) {
						last_position = position
						break
					}
				}

			}
			goto __5
		__5:
			version++
			goto __4
			goto __6
		__6:
			;
		}

		var min_error_cost uint32 = ts_parser__condense_stack(tls, self)
		if (*(*uintptr)(unsafe.Pointer(self + 1256 /* &.finished_tree */)) != 0) && (ts_subtree_error_cost(tls, (*TSParser)(unsafe.Pointer(self)).Finished_tree) < min_error_cost) {
			break
		}

		for (*TSParser)(unsafe.Pointer(self)).Included_range_difference_index < (*TSParser)(unsafe.Pointer(self)).Included_range_differences.Size {
			var range1 uintptr = ((*TSParser)(unsafe.Pointer(self)).Included_range_differences.Contents + uintptr((*TSParser)(unsafe.Pointer(self)).Included_range_difference_index)*24)
			if (*TSRange)(unsafe.Pointer(range1)).End_byte <= position {
				(*TSParser)(unsafe.Pointer(self)).Included_range_difference_index++
			} else {
				break
			}
		}
	}

	Xts_subtree_balance(tls, (*TSParser)(unsafe.Pointer(self)).Finished_tree, (self + 1200 /* &.tree_pool */), (*TSParser)(unsafe.Pointer(self)).Language)
	if ((*TSParser)(unsafe.Pointer(self)).Lexer.Logger.Log != 0) || ((*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0) {
		libc.X__builtin___snprintf_chk(tls, self /* &.lexer */ +165 /* &.debug_buffer */, uint64(TREE_SITTER_SERIALIZATION_BUFFER_SIZE), 0, libc.X__builtin_object_size(tls, self /* &.lexer */ +165 /* &.debug_buffer */, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+2288 /* "done" */, 0)
		ts_parser__log(tls, self)
	}

	if (*TSParser)(unsafe.Pointer(self)).Dot_graph_file != 0 {
		Xts_subtree_print_dot_graph(tls, (*TSParser)(unsafe.Pointer(self)).Finished_tree, (*TSParser)(unsafe.Pointer(self)).Language, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
		libc.Xfputs(tls, ts+2180 /* "\n" */, (*TSParser)(unsafe.Pointer(self)).Dot_graph_file)
	}

	var result uintptr = Xts_tree_new(tls,
		(*TSParser)(unsafe.Pointer(self)).Finished_tree,
		(*TSParser)(unsafe.Pointer(self)).Language,
		(*TSParser)(unsafe.Pointer(self)).Lexer.Included_ranges,
		(*TSParser)(unsafe.Pointer(self)).Lexer.Included_range_count)
	(*TSParser)(unsafe.Pointer(self)).Finished_tree = Subtree{}
	Xts_parser_reset(tls, self)
	return result
}

func Xts_parser_parse_string(tls *libc.TLS, self uintptr, old_tree uintptr, string uintptr, length Uint32_t) uintptr { /* parser.c:1931:8: */
	return Xts_parser_parse_string_encoding(tls, self, old_tree, string, length, TSInputEncodingUTF8)
}

func Xts_parser_parse_string_encoding(tls *libc.TLS, self uintptr, old_tree uintptr, string uintptr, length Uint32_t, encoding TSInputEncoding) uintptr { /* parser.c:1940:8: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*TSStringInput)(unsafe.Pointer(bp /* input */)) = TSStringInput{String: string, Length: length}
	return Xts_parser_parse(tls, self, old_tree, TSInput{
		Payload: bp, /* &input */
		Read: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, Uint32_t, TSPoint, uintptr) uintptr
		}{ts_string_input_read})),
		Encoding: encoding})
}

// -
// Copyright (c)1999 Citrus Project,
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	citrus Id: wctype.h,v 1.4 2000/12/21 01:50:21 itojun Exp
//	$NetBSD: wctype.h,v 1.3 2000/12/22 14:16:16 itojun Exp $
// $FreeBSD: /repoman/r/ncvs/src/include/wctype.h,v 1.10 2002/08/21 16:19:55 mike Exp $

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

type Wctrans_t = X__darwin_wctrans_t /* _wctrans_t.h:32:28 */

// -
// Copyright (c)1999 Citrus Project,
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//

// Common header for wctype.h and wchar.h
//
// Contains everything required by wctype.h except:
//
//	#include <_types/_wctrans_t.h>
//	int iswblank(wint_t);
//	wint_t towctrans(wint_t, wctrans_t);
//	wctrans_t wctrans(const char *);

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c)1999 Citrus Project,
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//

// Common header for _wctype.h and xlocale/__wctype.h

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Wint_t = X__darwin_wint_t /* _wint_t.h:32:25 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

type Wctype_t = X__darwin_wctype_t /* _wctype_t.h:32:27 */

// Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// This code is derived from software contributed to Berkeley by
// Paul Borman at Krystal Technologies.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)ctype.h	8.4 (Berkeley) 1/21/94

// Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// This code is derived from software contributed to Berkeley by
// Paul Borman at Krystal Technologies.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)ctype.h	8.4 (Berkeley) 1/21/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// -
// Copyright (c) 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Paul Borman at Krystal Technologies.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)runetype.h	8.1 (Berkeley) 6/2/93

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// The lower 8 bits of runetype[] contain the digit value of the rune.
type X_RuneEntry = struct {
	X__min      X__darwin_rune_t
	X__max      X__darwin_rune_t
	X__map      X__darwin_rune_t
	__ccgo_pad1 [4]byte
	X__types    uintptr
} /* runetype.h:65:3 */

type X_RuneRange = struct {
	X__nranges  int32
	__ccgo_pad1 [4]byte
	X__ranges   uintptr
} /* runetype.h:70:3 */

type X_RuneCharClass = struct {
	X__name     [14]int8
	__ccgo_pad1 [2]byte
	X__mask     X__uint32_t
} /* runetype.h:75:3 */

type X_RuneLocale = struct {
	X__magic        [8]int8
	X__encoding     [32]int8
	X__sgetrune     uintptr
	X__sputrune     uintptr
	X__invalid_rune X__darwin_rune_t
	X__runetype     [256]X__uint32_t
	X__maplower     [256]X__darwin_rune_t
	X__mapupper     [256]X__darwin_rune_t
	__ccgo_pad1     [4]byte
	X__runetype_ext X_RuneRange
	X__maplower_ext X_RuneRange
	X__mapupper_ext X_RuneRange
	X__variable     uintptr
	X__variable_len int32
	X__ncharclasses int32
	X__charclasses  uintptr
} /* runetype.h:106:3 */

// #define DEBUG_ANALYZE_QUERY
// #define LOG(...) fprintf(stderr, __VA_ARGS__)

// Stream - A sequence of unicode characters derived from a UTF8 string.
// This struct is used in parsing queries from S-expressions.
type Stream = struct {
	Input       uintptr
	Start       uintptr
	End         uintptr
	Next        Int32_t
	Next_size   Uint8_t
	__ccgo_pad1 [3]byte
} /* query.c:29:3 */

// QueryStep - A step in the process of matching a query. Each node within
// a query S-expression corresponds to one of these steps. An entire pattern
// is represented as a sequence of these steps. The basic properties of a
// node are represented by these fields:
// - `symbol` - The grammar symbol to match. A zero value represents the
//    wildcard symbol, '_'.
// - `field` - The field name to match. A zero value means that a field name
//    was not specified.
// - `capture_ids` - An array of integers representing the names of captures
//    associated with this node in the pattern, terminated by a `NONE` value.
// - `depth` - The depth where this node occurs in the pattern. The root node
//    of the pattern has depth zero.
//
// For simple patterns, steps are matched in sequential order. But in order to
// handle alternative/repeated/optional sub-patterns, query steps are not always
// structured as a linear sequence; they sometimes need to split and merge. This
// is done using the following fields:
//  - `alternative_index` - The index of a different query step that serves as
//    an alternative to this step. A `NONE` value represents no alternative.
//    When a query state reaches a step with an alternative index, the state
//    is duplicated, with one copy remaining at the original step, and one copy
//    moving to the alternative step. The alternative may have its own alternative
//    step, so this splitting is an iterative process.
// - `is_dead_end` - Indication that this state cannot be passed directly, and
//    exists only in order to redirect to an alternative index, with no splitting.
// - `is_pass_through` - Indication that state has no matching logic of its own,
//    and exists only to split a state. One copy of the state advances immediately
//    to the next step, and one moves to the alternative step.
//
// Steps have some additional fields in order to handle the `.` (or "anchor") operator,
// which forbids additional child nodes:
// - `is_immediate` - Indication that the node matching this step cannot be preceded
//   by other sibling nodes that weren't specified in the pattern.
// - `is_last_child` - Indicates that the node matching this step cannot have any
//   subsequent named siblings.
type QueryStep = struct {
	Symbol                TSSymbol
	Supertype_symbol      TSSymbol
	Field                 TSFieldId
	Capture_ids           [3]Uint16_t
	Depth                 Uint16_t
	Alternative_index     Uint16_t
	Negated_field_list_id Uint16_t
	Contains_captures     uint8 /* _Bool contains_captures: 1, _Bool is_immediate: 1, _Bool is_last_child: 1, _Bool is_pass_through: 1, _Bool is_dead_end: 1, _Bool alternative_is_immediate: 1, _Bool is_definite: 1 */
	__ccgo_pad1           [1]byte
} /* query.c:83:3 */

// Slice - A slice of an external array. Within a query, capture names,
// literal string values, and predicate step informations are stored in three
// contiguous arrays. Individual captures, string values, and predicates are
// represented as slices of these three arrays.
type Slice = struct {
	Offset Uint32_t
	Length Uint32_t
} /* query.c:94:3 */

// SymbolTable - a two-way mapping of strings to ids.
type SymbolTable = struct {
	Characters struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Slices struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
} /* query.c:102:3 */

// PatternEntry - Information about the starting point for matching a particular
// pattern. These entries are stored in a 'pattern map' - a sorted array that
// makes it possible to efficiently lookup patterns based on the symbol for their
// first step. The entry consists of the following fields:
// - `pattern_index` - the index of the pattern within the query
// - `step_index` - the index of the pattern's first step in the shared `steps` array
// - `is_rooted` - whether or not the pattern has a single root node. This property
//   affects decisions about whether or not to start the pattern for nodes outside
//   of a QueryCursor's range restriction.
type PatternEntry = struct {
	Step_index    Uint16_t
	Pattern_index Uint16_t
	Is_rooted     uint8
	__ccgo_pad1   [1]byte
} /* query.c:119:3 */

type QueryPattern = struct {
	Steps           Slice
	Predicate_steps Slice
	Start_byte      Uint32_t
} /* query.c:125:3 */

type StepOffset = struct {
	Byte_offset Uint32_t
	Step_index  Uint16_t
	__ccgo_pad1 [2]byte
} /* query.c:130:3 */

// QueryState - The state of an in-progress match of a particular pattern
// in a query. While executing, a `TSQueryCursor` must keep track of a number
// of possible in-progress matches. Each of those possible matches is
// represented as one of these states. Fields:
// - `id` - A numeric id that is exposed to the public API. This allows the
//    caller to remove a given match, preventing any more of its captures
//    from being returned.
// - `start_depth` - The depth in the tree where the first step of the state's
//    pattern was matched.
// - `pattern_index` - The pattern that the state is matching.
// - `consumed_capture_count` - The number of captures from this match that
//    have already been returned.
// - `capture_list_id` - A numeric id that can be used to retrieve the state's
//    list of captures from the `CaptureListPool`.
// - `seeking_immediate_match` - A flag that indicates that the state's next
//    step must be matched by the very next sibling. This is used when
//    processing repetitions.
// - `has_in_progress_alternatives` - A flag that indicates that there is are
//    other states that have the same captures as this state, but are at
//    different steps in their pattern. This means that in order to obey the
//    'longest-match' rule, this state should not be returned as a match until
//    it is clear that there can be no other alternative match with more captures.
type QueryState = struct {
	Id                     Uint32_t
	Capture_list_id        Uint32_t
	Start_depth            Uint16_t
	Step_index             Uint16_t
	Pattern_index          Uint16_t
	Consumed_capture_count uint16 /* uint16_t consumed_capture_count: 12 */ /* _Bool seeking_immediate_match: 1, _Bool has_in_progress_alternatives: 1, _Bool dead: 1, _Bool needs_parent: 1 */
} /* query.c:167:3 */

type CaptureList = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* query.c:169:31 */

// CaptureListPool - A collection of *lists* of captures. Each query state needs
// to maintain its own list of captures. To avoid repeated allocations, this struct
// maintains a fixed set of capture lists, and keeps track of which ones are
// currently in use by a query state.
type CaptureListPool = struct {
	List struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Empty_list              CaptureList
	Max_capture_list_count  Uint32_t
	Free_capture_list_count Uint32_t
} /* query.c:189:3 */

// AnalysisState - The state needed for walking the parse table when analyzing
// a query pattern, to determine at which steps the pattern might fail to match.
type AnalysisStateEntry = struct {
	Parse_state   TSStateId
	Parent_symbol TSSymbol
	Child_index   Uint16_t
	Field_id      uint16 /* TSFieldId field_id: 15 */ /* _Bool done: 1 */
} /* query.c:201:3 */

type AnalysisState = struct {
	Stack      [12]AnalysisStateEntry
	Depth      Uint16_t
	Step_index Uint16_t
} /* query.c:207:3 */

type AnalysisStateSet = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* query.c:209:30 */

// AnalysisSubgraph - A subset of the states in the parse table that are used
// in constructing nodes with a certain symbol. Each state is accompanied by
// some information about the possible node that could be produced in
// downstream states.
type AnalysisSubgraphNode = struct {
	State         TSStateId
	Production_id Uint8_t
	Child_index   uint8 /* uint8_t child_index: 7, _Bool done: 1 */
} /* query.c:222:3 */

type AnalysisSubgraph = struct {
	Symbol       TSSymbol
	__ccgo_pad1  [6]byte
	Start_states struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
	Nodes struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}
} /* query.c:228:3 */

// StatePredecessorMap - A map that stores the predecessors of each parse state.
// This is used during query analysis to determine which parse states can lead
// to which reduce actions.
type StatePredecessorMap = struct{ Contents uintptr } /* query.c:237:3 */

var sPARENT_DONE TSQueryError = libc.Uint32FromInt32(-1)         /* query.c:278:27 */
var sPATTERN_DONE_MARKER Uint16_t = Uint16_t(UINT16_MAX)         /* query.c:279:23 */
var sNONE Uint16_t = Uint16_t(UINT16_MAX)                        /* query.c:280:23 */
var sWILDCARD_SYMBOL TSSymbol = TSSymbol(0)                      /* query.c:281:23 */
var sNAMED_WILDCARD_SYMBOL TSSymbol = (TSSymbol(UINT16_MAX - 1)) /* query.c:282:23 */

// *********
//
// Stream
//

// Advance to the next unicode code point in the stream.
func stream_advance(tls *libc.TLS, self uintptr) uint8 { /* query.c:289:13: */
	*(*uintptr)(unsafe.Pointer(self /* &.input */)) += (uintptr((*Stream)(unsafe.Pointer(self)).Next_size))
	if (*Stream)(unsafe.Pointer(self)).Input < (*Stream)(unsafe.Pointer(self)).End {
		var size Uint32_t = ts_decode_utf8(tls,
			(*Stream)(unsafe.Pointer(self)).Input,
			(uint32((int64((*Stream)(unsafe.Pointer(self)).End) - int64((*Stream)(unsafe.Pointer(self)).Input)) / 1)),
			(self + 24 /* &.next */))
		if size > Uint32_t(0) {
			(*Stream)(unsafe.Pointer(self)).Next_size = Uint8_t(size)
			return uint8(True)
		}
	} else {
		(*Stream)(unsafe.Pointer(self)).Next_size = Uint8_t(0)
		(*Stream)(unsafe.Pointer(self)).Next = 0
	}
	return uint8(False)
}

// Reset the stream to the given input position, represented as a pointer
// into the input string.
func stream_reset(tls *libc.TLS, self uintptr, input uintptr) { /* query.c:310:13: */
	(*Stream)(unsafe.Pointer(self)).Input = input
	(*Stream)(unsafe.Pointer(self)).Next_size = Uint8_t(0)
	stream_advance(tls, self)
}

func stream_new(tls *libc.TLS, string uintptr, length Uint32_t) Stream { /* query.c:316:15: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*Stream)(unsafe.Pointer(bp /* self */)) = Stream{Input: string, Start: string, End: (string + uintptr(length))}
	stream_advance(tls, bp /* &self */)
	return *(*Stream)(unsafe.Pointer(bp /* self */))
}

func stream_skip_whitespace(tls *libc.TLS, self uintptr) { /* query.c:327:13: */
	for {
		if libc.Xiswspace(tls, (*Stream)(unsafe.Pointer(self)).Next) != 0 {
			stream_advance(tls, self)
		} else if (*Stream)(unsafe.Pointer(self)).Next == ';' {
			// skip over comments
			stream_advance(tls, self)
			for ((*Stream)(unsafe.Pointer(self)).Next != 0) && ((*Stream)(unsafe.Pointer(self)).Next != '\n') {
				if !(stream_advance(tls, self) != 0) {
					break
				}
			}
		} else {
			break
		}
	}
}

func stream_is_ident_start(tls *libc.TLS, self uintptr) uint8 { /* query.c:343:13: */
	return (uint8(libc.Bool32(((libc.Xiswalnum(tls, (*Stream)(unsafe.Pointer(self)).Next) != 0) || ((*Stream)(unsafe.Pointer(self)).Next == '_')) || ((*Stream)(unsafe.Pointer(self)).Next == '-'))))
}

func stream_scan_identifier(tls *libc.TLS, stream uintptr) { /* query.c:347:13: */
	for ok := true; ok; ok = ((((((libc.Xiswalnum(tls, (*Stream)(unsafe.Pointer(stream)).Next) != 0) || ((*Stream)(unsafe.Pointer(stream)).Next == '_')) || ((*Stream)(unsafe.Pointer(stream)).Next == '-')) || ((*Stream)(unsafe.Pointer(stream)).Next == '.')) || ((*Stream)(unsafe.Pointer(stream)).Next == '?')) || ((*Stream)(unsafe.Pointer(stream)).Next == '!')) {
		stream_advance(tls, stream)
	}
}

func stream_offset(tls *libc.TLS, self uintptr) Uint32_t { /* query.c:360:17: */
	return (Uint32_t((int64((*Stream)(unsafe.Pointer(self)).Input) - int64((*Stream)(unsafe.Pointer(self)).Start)) / 1))
}

// *****************
//
// CaptureListPool
//

func capture_list_pool_new(tls *libc.TLS) CaptureListPool { /* query.c:368:24: */
	return CaptureListPool{Max_capture_list_count: UINT32_MAX}
}

func capture_list_pool_reset(tls *libc.TLS, self uintptr) { /* query.c:377:13: */
	{
		var i Uint16_t = Uint16_t(0)
	__1:
		if !(Uint32_t(i) < (*CaptureListPool)(unsafe.Pointer(self)).List.Size) {
			goto __3
		}
		{
			// This invalid size means that the list is not in use.
			(*CaptureList)(unsafe.Pointer((*CaptureListPool)(unsafe.Pointer(self)).List.Contents + uintptr(i)*16)).Size = UINT32_MAX

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	(*CaptureListPool)(unsafe.Pointer(self)).Free_capture_list_count = (*CaptureListPool)(unsafe.Pointer(self)).List.Size
}

func capture_list_pool_delete(tls *libc.TLS, self uintptr) { /* query.c:385:13: */
	{
		var i Uint16_t = Uint16_t(0)
	__1:
		if !(Uint32_t(i) < (*CaptureListPool)(unsafe.Pointer(self)).List.Size) {
			goto __3
		}
		{
			array__delete(tls, ((*CaptureListPool)(unsafe.Pointer(self)).List.Contents + uintptr(i)*16))

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	array__delete(tls, (self /* &.list */))
}

func capture_list_pool_get(tls *libc.TLS, self uintptr, id Uint16_t) uintptr { /* query.c:392:26: */
	if Uint32_t(id) >= (*CaptureListPool)(unsafe.Pointer(self)).List.Size {
		return (self + 16 /* &.empty_list */)
	}
	return ((*CaptureListPool)(unsafe.Pointer(self)).List.Contents + uintptr(id)*16)
}

func capture_list_pool_get_mut(tls *libc.TLS, self uintptr, id Uint16_t) uintptr { /* query.c:397:20: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(Uint32_t(id) < (*CaptureListPool)(unsafe.Pointer(self)).List.Size)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__76)), ts+2293 /* "upstream/tree-si..." */, 398, ts+2330 /* "id < self->list...." */)
	} else {
	}
	return ((*CaptureListPool)(unsafe.Pointer(self)).List.Contents + uintptr(id)*16)
}

var __func__76 = *(*[26]int8)(unsafe.Pointer(ts + 2351 /* "capture_list_poo..." */)) /* query.c:397:83 */

func capture_list_pool_is_empty(tls *libc.TLS, self uintptr) uint8 { /* query.c:402:13: */
	// The capture list pool is empty if all allocated lists are in use, and we
	// have reached the maximum allowed number of allocated lists.
	return (uint8(libc.Bool32(((*CaptureListPool)(unsafe.Pointer(self)).Free_capture_list_count == Uint32_t(0)) && ((*CaptureListPool)(unsafe.Pointer(self)).List.Size >= (*CaptureListPool)(unsafe.Pointer(self)).Max_capture_list_count))))
}

func capture_list_pool_acquire(tls *libc.TLS, self uintptr) Uint16_t { /* query.c:408:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// First see if any already allocated capture list is currently unused.
	if (*CaptureListPool)(unsafe.Pointer(self)).Free_capture_list_count > Uint32_t(0) {
		{
			var i Uint16_t = Uint16_t(0)
		__1:
			if !(Uint32_t(i) < (*CaptureListPool)(unsafe.Pointer(self)).List.Size) {
				goto __3
			}
			{
				if (*CaptureList)(unsafe.Pointer((*CaptureListPool)(unsafe.Pointer(self)).List.Contents+uintptr(i)*16)).Size == UINT32_MAX {
					(*CaptureList)(unsafe.Pointer(((*CaptureListPool)(unsafe.Pointer(self)).List.Contents + uintptr(i)*16))).Size = Uint32_t(0)
					(*CaptureListPool)(unsafe.Pointer(self)).Free_capture_list_count--
					return i
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	// Otherwise allocate and initialize a new capture list, as long as that
	// doesn't put us over the requested maximum.
	var i Uint32_t = (*CaptureListPool)(unsafe.Pointer(self)).List.Size
	if i >= (*CaptureListPool)(unsafe.Pointer(self)).Max_capture_list_count {
		return sNONE
	}
	// var list CaptureList at bp, 16

	(*CaptureList)(unsafe.Pointer(bp /* &list */)).Size = Uint32_t(0)
	(*CaptureList)(unsafe.Pointer(bp /* &list */)).Capacity = Uint32_t(0)
	(*CaptureList)(unsafe.Pointer(bp /* &list */)).Contents = uintptr(0)
	array__grow(tls, (self /* &.list */), uint64(1), uint64(unsafe.Sizeof(CaptureList{})))
	*(*CaptureList)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.list */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.list */))).Size, 1))*16)) = *(*CaptureList)(unsafe.Pointer(bp /* list */))
	return Uint16_t(i)
}

func capture_list_pool_release(tls *libc.TLS, self uintptr, id Uint16_t) { /* query.c:432:13: */
	if Uint32_t(id) >= (*CaptureListPool)(unsafe.Pointer(self)).List.Size {
		return
	}
	(*CaptureList)(unsafe.Pointer((*CaptureListPool)(unsafe.Pointer(self)).List.Contents + uintptr(id)*16)).Size = UINT32_MAX
	(*CaptureListPool)(unsafe.Pointer(self)).Free_capture_list_count++
}

// *************
//
// SymbolTable
//

func symbol_table_new(tls *libc.TLS) SymbolTable { /* query.c:442:20: */
	return SymbolTable{}
}

func symbol_table_delete(tls *libc.TLS, self uintptr) { /* query.c:449:13: */
	array__delete(tls, (self /* &.characters */))
	array__delete(tls, (self + 16 /* &.slices */))
}

func symbol_table_id_for_name(tls *libc.TLS, self uintptr, name uintptr, length Uint32_t) int32 { /* query.c:454:12: */
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*SymbolTable)(unsafe.Pointer(self)).Slices.Size) {
			goto __3
		}
		{
			var slice = *(*Slice)(unsafe.Pointer((*SymbolTable)(unsafe.Pointer(self)).Slices.Contents + uintptr(i)*8))
			if (slice.Length == length) && !(libc.Xstrncmp(tls, ((*SymbolTable)(unsafe.Pointer(self)).Characters.Contents+uintptr(slice.Offset)), name, uint64(length)) != 0) {
				return int32(i)
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return -1
}

func symbol_table_name_for_id(tls *libc.TLS, self uintptr, id Uint16_t, length uintptr) uintptr { /* query.c:469:19: */
	var slice = *(*Slice)(unsafe.Pointer((*SymbolTable)(unsafe.Pointer(self)).Slices.Contents + uintptr(id)*8))
	*(*Uint32_t)(unsafe.Pointer(length)) = slice.Length
	return ((*SymbolTable)(unsafe.Pointer(self)).Characters.Contents + uintptr(slice.Offset))
}

func symbol_table_insert_name(tls *libc.TLS, self uintptr, name uintptr, length Uint32_t) Uint16_t { /* query.c:479:17: */
	var id int32 = symbol_table_id_for_name(tls, self, name, length)
	if id >= 0 {
		return Uint16_t(id)
	}
	var slice = Slice{Offset: (*SymbolTable)(unsafe.Pointer(self)).Characters.Size, Length: length}
	array__grow(tls, (self /* &.characters */), (uint64(length + Uint32_t(1))), uint64(unsafe.Sizeof(int8(0))))
	libc.X__builtin___memset_chk(tls, ((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.characters */))).Contents + uintptr((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.characters */))).Size)), 0, ((uint64(length + Uint32_t(1))) * uint64(unsafe.Sizeof(int8(0)))), libc.X__builtin_object_size(tls, ((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.characters */))).Contents+uintptr((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.characters */))).Size)), 0))
	*(*Uint32_t)(unsafe.Pointer((self /* &.characters */) + 8 /* &.size */)) += (length + Uint32_t(1))
	libc.X__builtin___memcpy_chk(tls, ((*SymbolTable)(unsafe.Pointer(self)).Characters.Contents + uintptr(slice.Offset)), name, uint64(length), libc.X__builtin_object_size(tls, ((*SymbolTable)(unsafe.Pointer(self)).Characters.Contents+uintptr(slice.Offset)), 0))
	*(*int8)(unsafe.Pointer((*SymbolTable)(unsafe.Pointer(self)).Characters.Contents + uintptr(((*SymbolTable)(unsafe.Pointer(self)).Characters.Size - Uint32_t(1))))) = int8(0)
	array__grow(tls, (self + 16 /* &.slices */), uint64(1), uint64(unsafe.Sizeof(Slice{})))
	*(*Slice)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 16 /* &.slices */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self+16 /* &.slices */))).Size, 1))*8)) = slice
	return (Uint16_t((*SymbolTable)(unsafe.Pointer(self)).Slices.Size - Uint32_t(1)))
}

// ***********
//
// QueryStep
//

func query_step__new(tls *libc.TLS, symbol TSSymbol, depth Uint16_t, is_immediate uint8) QueryStep { /* query.c:501:18: */
	return QueryStep{Symbol: symbol, Capture_ids: [3]Uint16_t{sNONE, sNONE, sNONE}, Depth: depth, Alternative_index: sNONE, Contains_captures: uint8(is_immediate) & 0x1 << 1}
}

func query_step__add_capture(tls *libc.TLS, self uintptr, capture_id Uint16_t) { /* query.c:523:13: */
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < uint32(MAX_STEP_CAPTURE_COUNT)) {
			goto __3
		}
		{
			if int32(*(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr(i)*2))) == int32(sNONE) {
				*(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr(i)*2)) = capture_id
				goto __3
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
}

func query_step__remove_capture(tls *libc.TLS, self uintptr, capture_id Uint16_t) { /* query.c:532:13: */
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < uint32(MAX_STEP_CAPTURE_COUNT)) {
			goto __3
		}
		{
			if int32(*(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr(i)*2))) == int32(capture_id) {
				*(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr(i)*2)) = sNONE
				for (i + uint32(1)) < uint32(MAX_STEP_CAPTURE_COUNT) {
					if int32(*(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr((i+uint32(1)))*2))) == int32(sNONE) {
						break
					}
					*(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr(i)*2)) = *(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr((i+uint32(1)))*2))
					*(*Uint16_t)(unsafe.Pointer((self + 6 /* &.capture_ids */) + uintptr((i+uint32(1)))*2)) = sNONE
					i++
				}
				goto __3
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
}

// *********************
//
// StatePredecessorMap
//

func state_predecessor_map_new(tls *libc.TLS, language uintptr) StatePredecessorMap { /* query.c:551:35: */
	return StatePredecessorMap{Contents: ts_calloc_default(tls, (uint64((*TSLanguage)(unsafe.Pointer(language)).State_count * (Uint32_t(MAX_STATE_PREDECESSOR_COUNT + 1)))), uint64(unsafe.Sizeof(TSStateId(0))))}
}

func state_predecessor_map_delete(tls *libc.TLS, self uintptr) { /* query.c:557:20: */
	ts_free_default(tls, (*StatePredecessorMap)(unsafe.Pointer(self)).Contents)
}

func state_predecessor_map_add(tls *libc.TLS, self uintptr, state TSStateId, predecessor TSStateId) { /* query.c:561:20: */
	var index uint32 = (uint32(int32(state) * (MAX_STATE_PREDECESSOR_COUNT + 1)))
	var count uintptr = ((*StatePredecessorMap)(unsafe.Pointer(self)).Contents + uintptr(index)*2)
	if (int32(*(*TSStateId)(unsafe.Pointer(count))) == 0) || ((int32(*(*TSStateId)(unsafe.Pointer(count))) < MAX_STATE_PREDECESSOR_COUNT) && (int32(*(*TSStateId)(unsafe.Pointer((*StatePredecessorMap)(unsafe.Pointer(self)).Contents + uintptr((index+uint32(*(*TSStateId)(unsafe.Pointer(count)))))*2))) != int32(predecessor))) {
		(*(*TSStateId)(unsafe.Pointer(count)))++
		*(*TSStateId)(unsafe.Pointer((*StatePredecessorMap)(unsafe.Pointer(self)).Contents + uintptr((index+uint32(*(*TSStateId)(unsafe.Pointer(count)))))*2)) = predecessor
	}
}

func state_predecessor_map_get(tls *libc.TLS, self uintptr, state TSStateId, count uintptr) uintptr { /* query.c:574:31: */
	var index uint32 = (uint32(int32(state) * (MAX_STATE_PREDECESSOR_COUNT + 1)))
	*(*uint32)(unsafe.Pointer(count)) = uint32(*(*TSStateId)(unsafe.Pointer((*StatePredecessorMap)(unsafe.Pointer(self)).Contents + uintptr(index)*2)))
	return ((*StatePredecessorMap)(unsafe.Pointer(self)).Contents + uintptr((index+uint32(1)))*2)
}

// ***************
//
// AnalysisState
//

func analysis_state__recursion_depth(tls *libc.TLS, self uintptr) uint32 { /* query.c:588:17: */
	var result uint32 = uint32(0)
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < uint32((*AnalysisState)(unsafe.Pointer(self)).Depth)) {
			goto __3
		}
		{
			var symbol TSSymbol = (*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */) + uintptr(i)*8)).Parent_symbol
			{
				var j uint32 = uint32(0)
			__4:
				if !(j < i) {
					goto __6
				}
				{
					if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(j)*8)).Parent_symbol) == int32(symbol) {
						result++
						goto __6
					}

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
				;
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return result
}

func analysis_state__compare_position(tls *libc.TLS, self uintptr, other uintptr) int32 { /* query.c:602:19: */
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < uint32((*AnalysisState)(unsafe.Pointer(self)).Depth)) {
			goto __3
		}
		{
			if i >= uint32((*AnalysisState)(unsafe.Pointer(other)).Depth) {
				return -1
			}
			if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(i)*8)).Child_index) < int32((*AnalysisStateEntry)(unsafe.Pointer((other /* &.stack */)+uintptr(i)*8)).Child_index) {
				return -1
			}
			if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(i)*8)).Child_index) > int32((*AnalysisStateEntry)(unsafe.Pointer((other /* &.stack */)+uintptr(i)*8)).Child_index) {
				return 1
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	if int32((*AnalysisState)(unsafe.Pointer(self)).Depth) < int32((*AnalysisState)(unsafe.Pointer(other)).Depth) {
		return 1
	}
	return 0
}

func analysis_state__compare(tls *libc.TLS, self uintptr, other uintptr) int32 { /* query.c:615:19: */
	var result int32 = analysis_state__compare_position(tls, self, other)
	if result != 0 {
		return result
	}
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < uint32((*AnalysisState)(unsafe.Pointer(self)).Depth)) {
			goto __3
		}
		{
			if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(i)*8)).Parent_symbol) < int32((*AnalysisStateEntry)(unsafe.Pointer((other /* &.stack */)+uintptr(i)*8)).Parent_symbol) {
				return -1
			}
			if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(i)*8)).Parent_symbol) > int32((*AnalysisStateEntry)(unsafe.Pointer((other /* &.stack */)+uintptr(i)*8)).Parent_symbol) {
				return 1
			}
			if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(i)*8)).Parse_state) < int32((*AnalysisStateEntry)(unsafe.Pointer((other /* &.stack */)+uintptr(i)*8)).Parse_state) {
				return -1
			}
			if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(i)*8)).Parse_state) > int32((*AnalysisStateEntry)(unsafe.Pointer((other /* &.stack */)+uintptr(i)*8)).Parse_state) {
				return 1
			}
			if (int32(*(*uint16)(unsafe.Pointer(((self /* &.stack */) + uintptr(i)*8) + 6 /* &.field_id */)) & 0x7fff >> 0)) < (int32(*(*uint16)(unsafe.Pointer(((other /* &.stack */) + uintptr(i)*8) + 6 /* &.field_id */)) & 0x7fff >> 0)) {
				return -1
			}
			if (int32(*(*uint16)(unsafe.Pointer(((self /* &.stack */) + uintptr(i)*8) + 6 /* &.field_id */)) & 0x7fff >> 0)) > (int32(*(*uint16)(unsafe.Pointer(((other /* &.stack */) + uintptr(i)*8) + 6 /* &.field_id */)) & 0x7fff >> 0)) {
				return 1
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	if int32((*AnalysisState)(unsafe.Pointer(self)).Step_index) < int32((*AnalysisState)(unsafe.Pointer(other)).Step_index) {
		return -1
	}
	if int32((*AnalysisState)(unsafe.Pointer(self)).Step_index) > int32((*AnalysisState)(unsafe.Pointer(other)).Step_index) {
		return 1
	}
	return 0
}

func analysis_state__top(tls *libc.TLS, self uintptr) uintptr { /* query.c:634:34: */
	return ((self /* &.stack */) + uintptr((int32((*AnalysisState)(unsafe.Pointer(self)).Depth)-1))*8)
}

func analysis_state__has_supertype(tls *libc.TLS, self uintptr, symbol TSSymbol) uint8 { /* query.c:638:20: */
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < uint32((*AnalysisState)(unsafe.Pointer(self)).Depth)) {
			goto __3
		}
		{
			if int32((*AnalysisStateEntry)(unsafe.Pointer((self /* &.stack */)+uintptr(i)*8)).Parent_symbol) == int32(symbol) {
				return uint8(True)
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return uint8(False)
}

// **********************
//
// AnalysisSubgraphNode
//

func analysis_subgraph_node__compare(tls *libc.TLS, self uintptr, other uintptr) int32 { /* query.c:649:19: */
	if int32((*AnalysisSubgraphNode)(unsafe.Pointer(self)).State) < int32((*AnalysisSubgraphNode)(unsafe.Pointer(other)).State) {
		return -1
	}
	if int32((*AnalysisSubgraphNode)(unsafe.Pointer(self)).State) > int32((*AnalysisSubgraphNode)(unsafe.Pointer(other)).State) {
		return 1
	}
	if (int32(*(*uint8)(unsafe.Pointer(self + 3 /* &.child_index */)) & 0x7f >> 0)) < (int32(*(*uint8)(unsafe.Pointer(other + 3 /* &.child_index */)) & 0x7f >> 0)) {
		return -1
	}
	if (int32(*(*uint8)(unsafe.Pointer(self + 3 /* &.child_index */)) & 0x7f >> 0)) > (int32(*(*uint8)(unsafe.Pointer(other + 3 /* &.child_index */)) & 0x7f >> 0)) {
		return 1
	}
	if (int32(*(*uint8)(unsafe.Pointer(self + 3 /* &.done */)) & 0x80 >> 7)) < (int32(*(*uint8)(unsafe.Pointer(other + 3 /* &.done */)) & 0x80 >> 7)) {
		return -1
	}
	if (int32(*(*uint8)(unsafe.Pointer(self + 3 /* &.done */)) & 0x80 >> 7)) > (int32(*(*uint8)(unsafe.Pointer(other + 3 /* &.done */)) & 0x80 >> 7)) {
		return 1
	}
	if int32((*AnalysisSubgraphNode)(unsafe.Pointer(self)).Production_id) < int32((*AnalysisSubgraphNode)(unsafe.Pointer(other)).Production_id) {
		return -1
	}
	if int32((*AnalysisSubgraphNode)(unsafe.Pointer(self)).Production_id) > int32((*AnalysisSubgraphNode)(unsafe.Pointer(other)).Production_id) {
		return 1
	}
	return 0
}

// ********
//
// Query
//

// The `pattern_map` contains a mapping from TSSymbol values to indices in the
// `steps` array. For a given syntax node, the `pattern_map` makes it possible
// to quickly find the starting steps of all of the patterns whose root matches
// that node. Each entry has two fields: a `pattern_index`, which identifies one
// of the patterns in the query, and a `step_index`, which indicates the start
// offset of that pattern's steps within the `steps` array.
//
// The entries are sorted by the patterns' root symbols, and lookups use a
// binary search. This ensures that the cost of this initial lookup step
// scales logarithmically with the number of patterns in the query.
//
// This returns `true` if the symbol is present and `false` otherwise.
// If the symbol is not present `*result` is set to the index where the
// symbol should be inserted.
func ts_query__pattern_map_search(tls *libc.TLS, self uintptr, needle TSSymbol, result uintptr) uint8 { /* query.c:679:20: */
	var base_index Uint32_t = Uint32_t((*TSQuery)(unsafe.Pointer(self)).Wildcard_root_pattern_count)
	var size Uint32_t = ((*TSQuery)(unsafe.Pointer(self)).Pattern_map.Size - base_index)
	if size == Uint32_t(0) {
		*(*Uint32_t)(unsafe.Pointer(result)) = base_index
		return uint8(False)
	}
	for size > Uint32_t(1) {
		var half_size Uint32_t = (size / Uint32_t(2))
		var mid_index Uint32_t = (base_index + half_size)
		var mid_symbol TSSymbol = (*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*PatternEntry)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Pattern_map.Contents+uintptr(mid_index)*6)).Step_index)*20)).Symbol
		if int32(needle) > int32(mid_symbol) {
			base_index = mid_index
		}
		size = size - (half_size)
	}

	var symbol TSSymbol = (*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*PatternEntry)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Pattern_map.Contents+uintptr(base_index)*6)).Step_index)*20)).Symbol

	if int32(needle) > int32(symbol) {
		base_index++
		if base_index < (*TSQuery)(unsafe.Pointer(self)).Pattern_map.Size {
			symbol = (*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*PatternEntry)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Pattern_map.Contents+uintptr(base_index)*6)).Step_index)*20)).Symbol
		}
	}

	*(*Uint32_t)(unsafe.Pointer(result)) = base_index
	return (uint8(libc.Bool32(int32(needle) == int32(symbol))))
}

// Insert a new pattern's start index into the pattern map, maintaining
// the pattern map's ordering invariant.
func ts_query__pattern_map_insert(tls *libc.TLS, self uintptr, symbol TSSymbol, new_entry PatternEntry) { /* query.c:719:20: */
	bp := tls.Alloc(10)
	defer tls.Free(10)
	*(*PatternEntry)(unsafe.Pointer(bp + 4)) = new_entry

	// var index Uint32_t at bp, 4

	ts_query__pattern_map_search(tls, self, symbol, bp /* &index */)

	// Ensure that the entries are sorted not only by symbol, but also
	// by pattern_index. This way, states for earlier patterns will be
	// initiated first, which allows the ordering of the states array
	// to be maintained more efficiently.
	for *(*Uint32_t)(unsafe.Pointer(bp /* index */)) < (*TSQuery)(unsafe.Pointer(self)).Pattern_map.Size {
		var entry uintptr = ((*TSQuery)(unsafe.Pointer(self)).Pattern_map.Contents + uintptr(*(*Uint32_t)(unsafe.Pointer(bp /* index */)))*6)
		if (int32((*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents+uintptr((*PatternEntry)(unsafe.Pointer(entry)).Step_index)*20)).Symbol) == int32(symbol)) && (int32((*PatternEntry)(unsafe.Pointer(entry)).Pattern_index) < int32((*PatternEntry)(unsafe.Pointer(bp+4 /* &new_entry */)).Pattern_index)) {
			*(*Uint32_t)(unsafe.Pointer(bp /* index */))++
		} else {
			break
		}
	}

	array__splice(tls, (self + 80 /* &.pattern_map */), uint64(unsafe.Sizeof(PatternEntry{})), *(*Uint32_t)(unsafe.Pointer(bp /* index */)), uint32(0), uint32(1), bp+4 /* &new_entry */)
}

func ts_query__analyze_patterns(tls *libc.TLS, self uintptr, error_offset uintptr) uint8 { /* query.c:746:13: */
	bp := tls.Alloc(616)
	defer tls.Free(616)

	// Identify all of the patterns in the query that have child patterns, both at the
	// top level and nested within other larger patterns. Record the step index where
	// each pattern starts.
	*(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp /* parent_step_indices */)) = struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}{}
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
			goto __3
		}
		{
			var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(i)*20)
			if (i + uint32(1)) < (*TSQuery)(unsafe.Pointer(self)).Steps.Size {
				var next_step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((i+uint32(1)))*20)
				if (((int32((*QueryStep)(unsafe.Pointer(step)).Symbol) != int32(sWILDCARD_SYMBOL)) && (int32((*QueryStep)(unsafe.Pointer(step)).Symbol) != int32(sNAMED_WILDCARD_SYMBOL))) && (int32((*QueryStep)(unsafe.Pointer(next_step)).Depth) > int32((*QueryStep)(unsafe.Pointer(step)).Depth))) && (int32((*QueryStep)(unsafe.Pointer(next_step)).Depth) != int32(sPATTERN_DONE_MARKER)) {
					array__grow(tls, bp /* &parent_step_indices */, uint64(1), uint64(unsafe.Sizeof(Uint32_t(0))))
					*(*Uint32_t)(unsafe.Pointer((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp /* &parent_step_indices */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer(bp /* &parent_step_indices */)).Size, 1))*4)) = i
				}
			}
			if int32((*QueryStep)(unsafe.Pointer(step)).Depth) > 0 {
				libc.SetBitFieldPtr8Uint8(step+18 /* &.is_definite */, uint8(True), 6, 0x40)
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	// For every parent symbol in the query, initialize an 'analysis subgraph'.
	// This subgraph lists all of the states in the parse table that are directly
	// involved in building subtrees for this symbol.
	//
	// In addition to the parent symbols in the query, construct subgraphs for all
	// of the hidden symbols in the grammar, because these might occur within
	// one of the parent nodes, such that their children appear to belong to the
	// parent.
	*(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp + 24 /* subgraphs */)) = struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}{}
	{
		var i1 uint32 = uint32(0)
	__4:
		if !(i1 < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer(bp /* &parent_step_indices */)).Size) {
			goto __6
		}
		{
			var parent_step_index Uint32_t = *(*Uint32_t)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp /* &parent_step_indices */)).Contents + uintptr(i1)*4))
			var parent_symbol TSSymbol = (*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(parent_step_index)*20)).Symbol
			*(*AnalysisSubgraph)(unsafe.Pointer(bp + 40 /* subgraph */)) = AnalysisSubgraph{Symbol: parent_symbol}
			for ok := true; ok; ok = 0 != 0 {
				// var index uint32 at bp+16, 4

				// var exists uint32 at bp+20, 4
				for ok1 := true; ok1; ok1 = 0 != 0 {
					*(*uint32)(unsafe.Pointer(bp + 16 /* &index */)) = uint32(0)
					*(*uint32)(unsafe.Pointer(bp + 20 /* &exists */)) = uint32(False)
					var size Uint32_t = ((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Size - *(*uint32)(unsafe.Pointer(bp + 16 /* &index */)))
					if size == Uint32_t(0) {
						break
					}
					var comparison int32
					for size > Uint32_t(1) {
						var half_size Uint32_t = (size / Uint32_t(2))
						var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 16 /* &index */)) + half_size)
						comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(mid_index)*40 /* &.symbol */)))) - (int32((*AnalysisSubgraph)(unsafe.Pointer(bp + 40 /* &subgraph */)).Symbol)))
						if comparison <= 0 {
							*(*uint32)(unsafe.Pointer(bp + 16 /* &index */)) = mid_index
						}
						size = size - (half_size)
					}
					comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 16 /* &index */)))*40 /* &.symbol */)))) - (int32((*AnalysisSubgraph)(unsafe.Pointer(bp + 40 /* &subgraph */)).Symbol)))
					if comparison == 0 {
						*(*uint32)(unsafe.Pointer(bp + 20 /* &exists */)) = uint32(True)
					} else if comparison < 0 {
						*(*uint32)(unsafe.Pointer(bp + 16 /* &index */)) += (uint32(1))
					}
				}
				if !(*(*uint32)(unsafe.Pointer(bp + 20 /* exists */)) != 0) {
					array__splice(tls, bp+24 /* &subgraphs */, uint64(unsafe.Sizeof(AnalysisSubgraph{})), *(*uint32)(unsafe.Pointer(bp + 16 /* index */)), uint32(0), uint32(1), bp+40 /* &subgraph */)
				}
			}

		}
		goto __5
	__5:
		i1++
		goto __4
		goto __6
	__6:
		;
	}
	{
		var sym TSSymbol = TSSymbol((*TSLanguage)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Language)).Token_count)
	__7:
		if !(Uint32_t(sym) < (*TSLanguage)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Language)).Symbol_count) {
			goto __9
		}
		{
			if !(int32(Xts_language_symbol_metadata(tls, (*TSQuery)(unsafe.Pointer(self)).Language, sym).Visible) != 0) {
				*(*AnalysisSubgraph)(unsafe.Pointer(bp + 88 /* subgraph */)) = AnalysisSubgraph{Symbol: sym}
				for ok2 := true; ok2; ok2 = 0 != 0 {
					// var index uint32 at bp+80, 4

					// var exists uint32 at bp+84, 4
					for ok3 := true; ok3; ok3 = 0 != 0 {
						*(*uint32)(unsafe.Pointer(bp + 80 /* &index */)) = uint32(0)
						*(*uint32)(unsafe.Pointer(bp + 84 /* &exists */)) = uint32(False)
						var size Uint32_t = ((*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Size - *(*uint32)(unsafe.Pointer(bp + 80 /* &index */)))
						if size == Uint32_t(0) {
							break
						}
						var comparison int32
						for size > Uint32_t(1) {
							var half_size Uint32_t = (size / Uint32_t(2))
							var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 80 /* &index */)) + half_size)
							comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(mid_index)*40 /* &.symbol */)))) - (int32((*AnalysisSubgraph)(unsafe.Pointer(bp + 88 /* &subgraph */)).Symbol)))
							if comparison <= 0 {
								*(*uint32)(unsafe.Pointer(bp + 80 /* &index */)) = mid_index
							}
							size = size - (half_size)
						}
						comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 80 /* &index */)))*40 /* &.symbol */)))) - (int32((*AnalysisSubgraph)(unsafe.Pointer(bp + 88 /* &subgraph */)).Symbol)))
						if comparison == 0 {
							*(*uint32)(unsafe.Pointer(bp + 84 /* &exists */)) = uint32(True)
						} else if comparison < 0 {
							*(*uint32)(unsafe.Pointer(bp + 80 /* &index */)) += (uint32(1))
						}
					}
					if !(*(*uint32)(unsafe.Pointer(bp + 84 /* exists */)) != 0) {
						array__splice(tls, bp+24 /* &subgraphs */, uint64(unsafe.Sizeof(AnalysisSubgraph{})), *(*uint32)(unsafe.Pointer(bp + 80 /* index */)), uint32(0), uint32(1), bp+88 /* &subgraph */)
					}
				}
			}

		}
		goto __8
	__8:
		sym++
		goto __7
		goto __9
	__9:
		;
	}

	// Scan the parse table to find the data needed to populate these subgraphs.
	// Collect three things during this scan:
	//   1) All of the parse states where one of these symbols can start.
	//   2) All of the parse states where one of these symbols can end, along
	//      with information about the node that would be created.
	//   3) A list of predecessor states for each state.
	*(*StatePredecessorMap)(unsafe.Pointer(bp + 208 /* predecessor_map */)) = state_predecessor_map_new(tls, (*TSQuery)(unsafe.Pointer(self)).Language)
	{
		var state TSStateId = TSStateId(1)
	__10:
		if !(Uint32_t(state) < (*TSLanguage)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Language)).State_count) {
			goto __12
		}
		{
			// var subgraph_index uint32 at bp+200, 4

			// var exists uint32 at bp+204, 4

			*(*LookaheadIterator)(unsafe.Pointer(bp + 128 /* lookahead_iterator */)) = ts_language_lookaheads(tls, (*TSQuery)(unsafe.Pointer(self)).Language, state)
			for ts_lookahead_iterator_next(tls, bp+128 /* &lookahead_iterator */) != 0 {
				if (*LookaheadIterator)(unsafe.Pointer(bp+128 /* &lookahead_iterator */)).Action_count != 0 {
					{
						var i uint32 = uint32(0)
					__13:
						if !(i < uint32((*LookaheadIterator)(unsafe.Pointer(bp+128 /* &lookahead_iterator */)).Action_count)) {
							goto __15
						}
						{
							var action uintptr = ((*LookaheadIterator)(unsafe.Pointer(bp+128 /* &lookahead_iterator */)).Actions + uintptr(i)*8)
							if int32(*(*Uint8_t)(unsafe.Pointer(action /* .Type */))) == TSParseActionTypeReduce {
								// var aliases uintptr at bp+184, 8

								// var aliases_end uintptr at bp+192, 8

								ts_language_aliases_for_symbol(tls,
									(*TSQuery)(unsafe.Pointer(self)).Language,
									*(*TSSymbol)(unsafe.Pointer(action /* &.reduce */ + 2 /* &.symbol */)),
									bp+184, /* &aliases */
									bp+192 /* &aliases_end */)
								{
									var symbol uintptr = *(*uintptr)(unsafe.Pointer(bp + 184 /* aliases */))
								__16:
									if !(symbol < *(*uintptr)(unsafe.Pointer(bp + 192 /* aliases_end */))) {
										goto __18
									}
									{
										for ok4 := true; ok4; ok4 = 0 != 0 {
											*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) = uint32(0)
											*(*uint32)(unsafe.Pointer(bp + 204 /* &exists */)) = uint32(False)
											var size Uint32_t = ((*struct {
												Contents uintptr
												Size     Uint32_t
												Capacity Uint32_t
											})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Size - *(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)))
											if size == Uint32_t(0) {
												break
											}
											var comparison int32
											for size > Uint32_t(1) {
												var half_size Uint32_t = (size / Uint32_t(2))
												var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) + half_size)
												comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
													Contents uintptr
													Size     Uint32_t
													Capacity Uint32_t
												})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(mid_index)*40 /* &.symbol */)))) - (int32(*(*TSSymbol)(unsafe.Pointer(symbol)))))
												if comparison <= 0 {
													*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) = mid_index
												}
												size = size - (half_size)
											}
											comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
												Contents uintptr
												Size     Uint32_t
												Capacity Uint32_t
											})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)))*40 /* &.symbol */)))) - (int32(*(*TSSymbol)(unsafe.Pointer(symbol)))))
											if comparison == 0 {
												*(*uint32)(unsafe.Pointer(bp + 204 /* &exists */)) = uint32(True)
											} else if comparison < 0 {
												*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) += (uint32(1))
											}
										}
										if *(*uint32)(unsafe.Pointer(bp + 204 /* exists */)) != 0 {
											var subgraph uintptr = ((*struct {
												Contents uintptr
												Size     Uint32_t
												Capacity Uint32_t
											})(unsafe.Pointer(bp+24 /* &subgraphs */)).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 200 /* subgraph_index */)))*40)
											if ((*AnalysisSubgraph)(unsafe.Pointer(subgraph)).Nodes.Size == Uint32_t(0)) || (int32((*AnalysisSubgraphNode)(unsafe.Pointer((func() uintptr {
												if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
													Contents uintptr
													Size     Uint32_t
													Capacity Uint32_t
												})(unsafe.Pointer((subgraph+24 /* &.nodes */))).Size-Uint32_t(1)) < (*struct {
													Contents uintptr
													Size     Uint32_t
													Capacity Uint32_t
												})(unsafe.Pointer((subgraph+24 /* &.nodes */))).Size)), int64(0)) != 0 {
													libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__77)), ts+2293 /* "upstream/tree-si..." */, 823, ts+2377 /* "(uint32_t)(&subg..." */)
												} else {
												}
												return ((*struct {
													Contents uintptr
													Size     Uint32_t
													Capacity Uint32_t
												})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Contents + uintptr(((*struct {
													Contents uintptr
													Size     Uint32_t
													Capacity Uint32_t
												})(unsafe.Pointer((subgraph+24 /* &.nodes */))).Size-Uint32_t(1)))*4)
											}()))).State) != int32(state)) {
												array__grow(tls, (subgraph + 24 /* &.nodes */), uint64(1), uint64(unsafe.Sizeof(AnalysisSubgraphNode{})))
												*(*AnalysisSubgraphNode)(unsafe.Pointer((*struct {
													Contents uintptr
													Size     Uint32_t
													Capacity Uint32_t
												})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
													Contents uintptr
													Size     Uint32_t
													Capacity Uint32_t
												})(unsafe.Pointer((subgraph+24 /* &.nodes */))).Size, 1))*4)) = AnalysisSubgraphNode{State: state, Production_id: Uint8_t(*(*Uint16_t)(unsafe.Pointer(action /* &.reduce */ + 6 /* &.production_id */))), Child_index: *(*Uint8_t)(unsafe.Pointer(action /* &.reduce */ + 1 /* &.child_count */))&0x7f | uint8(True)&0x1<<7}
											}
										}

									}
									goto __17
								__17:
									symbol += 2
									goto __16
									goto __18
								__18:
									;
								}
							} else if (int32(*(*Uint8_t)(unsafe.Pointer(action /* .Type */))) == TSParseActionTypeShift) && !(int32(*(*uint8)(unsafe.Pointer(action /* &.shift */ + 4 /* &.extra */))) != 0) {
								var next_state TSStateId = *(*TSStateId)(unsafe.Pointer(action /* &.shift */ + 2 /* &.state */))
								state_predecessor_map_add(tls, bp+208 /* &predecessor_map */, next_state, state)
							}

						}
						goto __14
					__14:
						i++
						goto __13
						goto __15
					__15:
						;
					}
				} else if int32((*LookaheadIterator)(unsafe.Pointer(bp+128 /* &lookahead_iterator */)).Next_state) != 0 {
					if int32((*LookaheadIterator)(unsafe.Pointer(bp+128 /* &lookahead_iterator */)).Next_state) != int32(state) {
						state_predecessor_map_add(tls, bp+208 /* &predecessor_map */, (*LookaheadIterator)(unsafe.Pointer(bp+128 /* &lookahead_iterator */)).Next_state, state)
					}
					// var aliases uintptr at bp+216, 8

					// var aliases_end uintptr at bp+224, 8

					ts_language_aliases_for_symbol(tls,
						(*TSQuery)(unsafe.Pointer(self)).Language,
						(*LookaheadIterator)(unsafe.Pointer(bp+128 /* &lookahead_iterator */)).Symbol,
						bp+216, /* &aliases */
						bp+224 /* &aliases_end */)
					{
						var symbol uintptr = *(*uintptr)(unsafe.Pointer(bp + 216 /* aliases */))
					__19:
						if !(symbol < *(*uintptr)(unsafe.Pointer(bp + 224 /* aliases_end */))) {
							goto __21
						}
						{
							for ok5 := true; ok5; ok5 = 0 != 0 {
								*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) = uint32(0)
								*(*uint32)(unsafe.Pointer(bp + 204 /* &exists */)) = uint32(False)
								var size Uint32_t = ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Size - *(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)))
								if size == Uint32_t(0) {
									break
								}
								var comparison int32
								for size > Uint32_t(1) {
									var half_size Uint32_t = (size / Uint32_t(2))
									var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) + half_size)
									comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(mid_index)*40 /* &.symbol */)))) - (int32(*(*TSSymbol)(unsafe.Pointer(symbol)))))
									if comparison <= 0 {
										*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) = mid_index
									}
									size = size - (half_size)
								}
								comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)))*40 /* &.symbol */)))) - (int32(*(*TSSymbol)(unsafe.Pointer(symbol)))))
								if comparison == 0 {
									*(*uint32)(unsafe.Pointer(bp + 204 /* &exists */)) = uint32(True)
								} else if comparison < 0 {
									*(*uint32)(unsafe.Pointer(bp + 200 /* &subgraph_index */)) += (uint32(1))
								}
							}
							if *(*uint32)(unsafe.Pointer(bp + 204 /* exists */)) != 0 {
								var subgraph uintptr = ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer(bp+24 /* &subgraphs */)).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 200 /* subgraph_index */)))*40)
								if ((*AnalysisSubgraph)(unsafe.Pointer(subgraph)).Start_states.Size == Uint32_t(0)) || (int32(*(*TSStateId)(unsafe.Pointer(func() uintptr {
									if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph+8 /* &.start_states */))).Size-Uint32_t(1)) < (*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph+8 /* &.start_states */))).Size)), int64(0)) != 0 {
										libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__77)), ts+2293 /* "upstream/tree-si..." */, 861, ts+2443 /* "(uint32_t)(&subg..." */)
									} else {
									}
									return ((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph + 8 /* &.start_states */))).Contents + uintptr(((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph+8 /* &.start_states */))).Size-Uint32_t(1)))*2)
								}()))) != int32(state)) {
									array__grow(tls, (subgraph + 8 /* &.start_states */), uint64(1), uint64(unsafe.Sizeof(TSStateId(0))))
									*(*TSStateId)(unsafe.Pointer((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph + 8 /* &.start_states */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph+8 /* &.start_states */))).Size, 1))*2)) = state
								}
							}

						}
						goto __20
					__20:
						symbol += 2
						goto __19
						goto __21
					__21:
						;
					}
				}
			}

		}
		goto __11
	__11:
		state++
		goto __10
		goto __12
	__12:
		;
	}

	// For each subgraph, compute the preceding states by walking backward
	// from the end states using the predecessor map.
	*(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp + 232 /* next_nodes */)) = struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}{}
	{
		var i2 uint32 = uint32(0)
	__22:
		if !(i2 < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer(bp+24 /* &subgraphs */)).Size) {
			goto __24
		}
		{
			var subgraph uintptr = ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp+24 /* &subgraphs */)).Contents + uintptr(i2)*40)
			if (*AnalysisSubgraph)(unsafe.Pointer(subgraph)).Nodes.Size == Uint32_t(0) {
				array__delete(tls, (subgraph + 8 /* &.start_states */))
				array__erase(tls, bp+24 /* &subgraphs */, uint64(unsafe.Sizeof(AnalysisSubgraph{})), i2)
				i2--
				goto __23
			}
			array__assign(tls, bp+232 /* &next_nodes */, (subgraph + 24 /* &.nodes */), uint64(unsafe.Sizeof(AnalysisSubgraphNode{})))
			for (*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp+232 /* &next_nodes */)).Size > Uint32_t(0) {
				*(*AnalysisSubgraphNode)(unsafe.Pointer(bp + 248 /* node */)) = *(*AnalysisSubgraphNode)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((bp + 232 /* &next_nodes */))).Contents + uintptr(libc.PreDecUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer(bp+232 /* &next_nodes */)).Size, 1))*4))
				if (int32(*(*uint8)(unsafe.Pointer(bp + 248 /* &node */ + 3 /* &.child_index */)) & 0x7f >> 0)) > 1 {
					// var predecessor_count uint32 at bp+252, 4

					var predecessors uintptr = state_predecessor_map_get(tls,
						bp+208, /* &predecessor_map */
						(*AnalysisSubgraphNode)(unsafe.Pointer(bp+248 /* &node */)).State,
						bp+252 /* &predecessor_count */)
					{
						var j uint32 = uint32(0)
					__25:
						if !(j < *(*uint32)(unsafe.Pointer(bp + 252 /* predecessor_count */))) {
							goto __27
						}
						{
							*(*AnalysisSubgraphNode)(unsafe.Pointer(bp + 264 /* predecessor_node */)) = AnalysisSubgraphNode{State: *(*TSStateId)(unsafe.Pointer(predecessors + uintptr(j)*2)), Production_id: (*AnalysisSubgraphNode)(unsafe.Pointer(bp + 248 /* &node */)).Production_id, Child_index: (uint8(((int32(*(*uint8)(unsafe.Pointer(bp + 248 /* &node */ + 3 /* &.child_index */)) & 0x7f >> 0)) - 1) & 0x7f << 25 >> 25)) & 0x7f}
							// var index uint32 at bp+256, 4

							// var exists uint32 at bp+260, 4

							for ok6 := true; ok6; ok6 = 0 != 0 {
								*(*uint32)(unsafe.Pointer(bp + 256 /* &index */)) = uint32(0)
								*(*uint32)(unsafe.Pointer(bp + 260 /* &exists */)) = uint32(False)
								var size Uint32_t = ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Size - *(*uint32)(unsafe.Pointer(bp + 256 /* &index */)))
								if size == Uint32_t(0) {
									break
								}
								var comparison int32
								for size > Uint32_t(1) {
									var half_size Uint32_t = (size / Uint32_t(2))
									var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 256 /* &index */)) + half_size)
									comparison = analysis_subgraph_node__compare(tls, ((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Contents + uintptr(mid_index)*4), bp+264 /* &predecessor_node */)
									if comparison <= 0 {
										*(*uint32)(unsafe.Pointer(bp + 256 /* &index */)) = mid_index
									}
									size = size - (half_size)
								}
								comparison = analysis_subgraph_node__compare(tls, ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 256 /* &index */)))*4), bp+264 /* &predecessor_node */)
								if comparison == 0 {
									*(*uint32)(unsafe.Pointer(bp + 260 /* &exists */)) = uint32(True)
								} else if comparison < 0 {
									*(*uint32)(unsafe.Pointer(bp + 256 /* &index */)) += (uint32(1))
								}
							}
							if !(*(*uint32)(unsafe.Pointer(bp + 260 /* exists */)) != 0) {
								array__splice(tls, (subgraph + 24 /* &.nodes */), uint64(unsafe.Sizeof(AnalysisSubgraphNode{})), *(*uint32)(unsafe.Pointer(bp + 256 /* index */)), uint32(0), uint32(1), bp+264 /* &predecessor_node */)
								array__grow(tls, bp+232 /* &next_nodes */, uint64(1), uint64(unsafe.Sizeof(AnalysisSubgraphNode{})))
								*(*AnalysisSubgraphNode)(unsafe.Pointer((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 232 /* &next_nodes */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer(bp+232 /* &next_nodes */)).Size, 1))*4)) = *(*AnalysisSubgraphNode)(unsafe.Pointer(bp + 264 /* predecessor_node */))
							}

						}
						goto __26
					__26:
						j++
						goto __25
						goto __27
					__27:
						;
					}
				}
			}

		}
		goto __23
	__23:
		i2++
		goto __22
		goto __24
	__24:
		;
	}

	// For each non-terminal pattern, determine if the pattern can successfully match,
	// and identify all of the possible children within the pattern where matching could fail.
	var all_patterns_are_valid uint8 = uint8(True)
	*(*AnalysisStateSet)(unsafe.Pointer(bp + 288 /* states */)) = AnalysisStateSet{}
	*(*AnalysisStateSet)(unsafe.Pointer(bp + 336 /* next_states */)) = AnalysisStateSet{}
	*(*AnalysisStateSet)(unsafe.Pointer(bp + 304 /* deeper_states */)) = AnalysisStateSet{}
	*(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp + 320 /* final_step_indices */)) = struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}{}
	{
		var i3 uint32 = uint32(0)
	__28:
		if !(i3 < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer(bp /* &parent_step_indices */)).Size) {
			goto __30
		}
		{
			var parent_step_index Uint16_t = Uint16_t(*(*Uint32_t)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp /* &parent_step_indices */)).Contents + uintptr(i3)*4)))
			var parent_depth Uint16_t = (*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(parent_step_index)*20)).Depth
			var parent_symbol TSSymbol = (*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(parent_step_index)*20)).Symbol
			if int32(parent_symbol) == (int32(libc.Uint16FromInt32(-1))) {
				goto __29
			}

			// Find the subgraph that corresponds to this pattern's root symbol. If the pattern's
			// root symbols is not a non-terminal, then return an error.
			// var subgraph_index uint32 at bp+268, 4

			// var exists uint32 at bp+272, 4

			for ok7 := true; ok7; ok7 = 0 != 0 {
				*(*uint32)(unsafe.Pointer(bp + 268 /* &subgraph_index */)) = uint32(0)
				*(*uint32)(unsafe.Pointer(bp + 272 /* &exists */)) = uint32(False)
				var size Uint32_t = ((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Size - *(*uint32)(unsafe.Pointer(bp + 268 /* &subgraph_index */)))
				if size == Uint32_t(0) {
					break
				}
				var comparison int32
				for size > Uint32_t(1) {
					var half_size Uint32_t = (size / Uint32_t(2))
					var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 268 /* &subgraph_index */)) + half_size)
					comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(mid_index)*40 /* &.symbol */)))) - (int32(parent_symbol)))
					if comparison <= 0 {
						*(*uint32)(unsafe.Pointer(bp + 268 /* &subgraph_index */)) = mid_index
					}
					size = size - (half_size)
				}
				comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 268 /* &subgraph_index */)))*40 /* &.symbol */)))) - (int32(parent_symbol)))
				if comparison == 0 {
					*(*uint32)(unsafe.Pointer(bp + 272 /* &exists */)) = uint32(True)
				} else if comparison < 0 {
					*(*uint32)(unsafe.Pointer(bp + 268 /* &subgraph_index */)) += (uint32(1))
				}
			}
			if !(*(*uint32)(unsafe.Pointer(bp + 272 /* exists */)) != 0) {
				var first_child_step_index uint32 = (uint32(int32(parent_step_index) + 1))
				// var i Uint32_t at bp+276, 4

				// var exists Uint32_t at bp+280, 4

				for ok8 := true; ok8; ok8 = 0 != 0 {
					*(*Uint32_t)(unsafe.Pointer(bp + 276 /* &i */)) = Uint32_t(0)
					*(*Uint32_t)(unsafe.Pointer(bp + 280 /* &exists */)) = Uint32_t(False)
					var size Uint32_t = ((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Size - *(*Uint32_t)(unsafe.Pointer(bp + 276 /* &i */)))
					if size == Uint32_t(0) {
						break
					}
					var comparison int32
					for size > Uint32_t(1) {
						var half_size Uint32_t = (size / Uint32_t(2))
						var mid_index Uint32_t = (*(*Uint32_t)(unsafe.Pointer(bp + 276 /* &i */)) + half_size)
						comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Contents + uintptr(mid_index)*8 + 4 /* &.step_index */)))) - (int32(first_child_step_index)))
						if comparison <= 0 {
							*(*Uint32_t)(unsafe.Pointer(bp + 276 /* &i */)) = mid_index
						}
						size = size - (half_size)
					}
					comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Contents + uintptr(*(*Uint32_t)(unsafe.Pointer(bp + 276 /* &i */)))*8 + 4 /* &.step_index */)))) - (int32(first_child_step_index)))
					if comparison == 0 {
						*(*Uint32_t)(unsafe.Pointer(bp + 280 /* &exists */)) = Uint32_t(True)
					} else if comparison < 0 {
						*(*Uint32_t)(unsafe.Pointer(bp + 276 /* &i */)) += (Uint32_t(1))
					}
				}
				if libc.X__builtin_expect(tls, libc.BoolInt64(!(*(*Uint32_t)(unsafe.Pointer(bp + 280 /* exists */)) != 0)), int64(0)) != 0 {
					libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__77)), ts+2293 /* "upstream/tree-si..." */, 955, ts+2523 /* "exists" */)
				} else {
				}
				*(*uint32)(unsafe.Pointer(error_offset)) = (*StepOffset)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Step_offsets.Contents + uintptr(*(*Uint32_t)(unsafe.Pointer(bp + 276 /* i */)))*8)).Byte_offset
				all_patterns_are_valid = uint8(False)
				goto __30
			}

			// Initialize an analysis state at every parse state in the table where
			// this parent symbol can occur.
			var subgraph uintptr = ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp+24 /* &subgraphs */)).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 268 /* subgraph_index */)))*40)
			(*AnalysisStateSet)(unsafe.Pointer(bp + 288 /* &states */)).Size = Uint32_t(0)
			(*AnalysisStateSet)(unsafe.Pointer(bp + 304 /* &deeper_states */)).Size = Uint32_t(0)
			{
				var j uint32 = uint32(0)
			__31:
				if !(j < (*AnalysisSubgraph)(unsafe.Pointer(subgraph)).Start_states.Size) {
					goto __33
				}
				{
					var parse_state TSStateId = *(*TSStateId)(unsafe.Pointer((*AnalysisSubgraph)(unsafe.Pointer(subgraph)).Start_states.Contents + uintptr(j)*2))
					array__grow(tls, bp+288 /* &states */, uint64(1), uint64(unsafe.Sizeof(AnalysisState{})))
					*(*AnalysisState)(unsafe.Pointer((*AnalysisStateSet)(unsafe.Pointer((bp + 288 /* &states */))).Contents + uintptr(libc.PostIncUint32(&(*AnalysisStateSet)(unsafe.Pointer(bp+288 /* &states */)).Size, 1))*100)) = AnalysisState{Stack: [12]AnalysisStateEntry{0: {Parse_state: parse_state, Parent_symbol: parent_symbol}}, Depth: Uint16_t(1), Step_index: (Uint16_t(int32(parent_step_index) + 1))}

				}
				goto __32
			__32:
				j++
				goto __31
				goto __33
			__33:
				;
			}

			// Walk the subgraph for this non-terminal, tracking all of the possible
			// sequences of progress within the pattern.
			var can_finish_pattern uint8 = uint8(False)
			var did_exceed_max_depth uint8 = uint8(False)
			var recursion_depth_limit uint32 = uint32(0)
			var prev_final_step_count uint32 = uint32(0)
			(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp + 320 /* &final_step_indices */)).Size = Uint32_t(0)
			for {

				// If no further progress can be made within the current recursion depth limit, then
				// bump the depth limit by one, and continue to process the states the exceeded the
				// limit. But only allow this if progress has been made since the last time the depth
				// limit was increased.
				if (*AnalysisStateSet)(unsafe.Pointer(bp+288 /* &states */)).Size == Uint32_t(0) {
					if ((*AnalysisStateSet)(unsafe.Pointer(bp+304 /* &deeper_states */)).Size > Uint32_t(0)) && ((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer(bp+320 /* &final_step_indices */)).Size > prev_final_step_count) {

						prev_final_step_count = (*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer(bp + 320 /* &final_step_indices */)).Size
						recursion_depth_limit++
						var _states = *(*AnalysisStateSet)(unsafe.Pointer(bp + 288 /* states */))
						*(*AnalysisStateSet)(unsafe.Pointer(bp + 288 /* states */)) = *(*AnalysisStateSet)(unsafe.Pointer(bp + 304 /* deeper_states */))
						*(*AnalysisStateSet)(unsafe.Pointer(bp + 304 /* deeper_states */)) = _states
						continue
					}

					break
				}

				(*AnalysisStateSet)(unsafe.Pointer(bp + 336 /* &next_states */)).Size = Uint32_t(0)
				{
					var j uint32 = uint32(0)
				__34:
					if !(j < (*AnalysisStateSet)(unsafe.Pointer(bp+288 /* &states */)).Size) {
						goto __36
					}
					{
						var state uintptr = ((*AnalysisStateSet)(unsafe.Pointer(bp+288 /* &states */)).Contents + uintptr(j)*100)

						// For efficiency, it's important to avoid processing the same analysis state more
						// than once. To achieve this, keep the states in order of ascending position within
						// their hypothetical syntax trees. In each iteration of this loop, start by advancing
						// the states that have made the least progress. Avoid advancing states that have already
						// made more progress.
						if (*AnalysisStateSet)(unsafe.Pointer(bp+336 /* &next_states */)).Size > Uint32_t(0) {
							var comparison int32 = analysis_state__compare_position(tls, state, func() uintptr {
								if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*AnalysisStateSet)(unsafe.Pointer((bp+336 /* &next_states */))).Size-Uint32_t(1)) < (*AnalysisStateSet)(unsafe.Pointer((bp+336 /* &next_states */))).Size)), int64(0)) != 0 {
									libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__77)), ts+2293 /* "upstream/tree-si..." */, 1046, ts+2530 /* "(uint32_t)(&next..." */)
								} else {
								}
								return ((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Contents + uintptr(((*AnalysisStateSet)(unsafe.Pointer((bp+336 /* &next_states */))).Size-Uint32_t(1)))*100)
							}())
							if comparison == 0 {
								for ok9 := true; ok9; ok9 = 0 != 0 {
									// var index uint32 at bp+352, 4

									// var exists uint32 at bp+356, 4
									for ok10 := true; ok10; ok10 = 0 != 0 {
										*(*uint32)(unsafe.Pointer(bp + 352 /* &index */)) = uint32(0)
										*(*uint32)(unsafe.Pointer(bp + 356 /* &exists */)) = uint32(False)
										var size Uint32_t = ((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Size - *(*uint32)(unsafe.Pointer(bp + 352 /* &index */)))
										if size == Uint32_t(0) {
											break
										}
										var comparison int32
										for size > Uint32_t(1) {
											var half_size Uint32_t = (size / Uint32_t(2))
											var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 352 /* &index */)) + half_size)
											comparison = analysis_state__compare(tls, ((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Contents + uintptr(mid_index)*100), state)
											if comparison <= 0 {
												*(*uint32)(unsafe.Pointer(bp + 352 /* &index */)) = mid_index
											}
											size = size - (half_size)
										}
										comparison = analysis_state__compare(tls, ((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 352 /* &index */)))*100), state)
										if comparison == 0 {
											*(*uint32)(unsafe.Pointer(bp + 356 /* &exists */)) = uint32(True)
										} else if comparison < 0 {
											*(*uint32)(unsafe.Pointer(bp + 352 /* &index */)) += (uint32(1))
										}
									}
									if !(*(*uint32)(unsafe.Pointer(bp + 356 /* exists */)) != 0) {
										array__splice(tls, bp+336 /* &next_states */, uint64(unsafe.Sizeof(AnalysisState{})), *(*uint32)(unsafe.Pointer(bp + 352 /* index */)), uint32(0), uint32(1), state)
									}
								}
								goto __35
							} else if comparison > 0 {
								for j < (*AnalysisStateSet)(unsafe.Pointer(bp+288 /* &states */)).Size {
									array__grow(tls, bp+336 /* &next_states */, uint64(1), uint64(unsafe.Sizeof(AnalysisState{})))
									*(*AnalysisState)(unsafe.Pointer((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Contents + uintptr(libc.PostIncUint32(&(*AnalysisStateSet)(unsafe.Pointer(bp+336 /* &next_states */)).Size, 1))*100)) = *(*AnalysisState)(unsafe.Pointer((*AnalysisStateSet)(unsafe.Pointer(bp+288 /* &states */)).Contents + uintptr(j)*100))
									j++
								}
								goto __36
							}
						}

						var parse_state TSStateId = (*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, state))).Parse_state
						var parent_symbol TSSymbol = (*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, state))).Parent_symbol
						var parent_field_id TSFieldId = (TSFieldId(int32(*(*uint16)(unsafe.Pointer(analysis_state__top(tls, state) + 6 /* &.field_id */)) & 0x7fff >> 0)))
						var child_index uint32 = uint32((*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, state))).Child_index)
						var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*AnalysisState)(unsafe.Pointer(state)).Step_index)*20)
						// var subgraph_index uint32 at bp+360, 4

						// var exists uint32 at bp+364, 4

						for ok11 := true; ok11; ok11 = 0 != 0 {
							*(*uint32)(unsafe.Pointer(bp + 360 /* &subgraph_index */)) = uint32(0)
							*(*uint32)(unsafe.Pointer(bp + 364 /* &exists */)) = uint32(False)
							var size Uint32_t = ((*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Size - *(*uint32)(unsafe.Pointer(bp + 360 /* &subgraph_index */)))
							if size == Uint32_t(0) {
								break
							}
							var comparison int32
							for size > Uint32_t(1) {
								var half_size Uint32_t = (size / Uint32_t(2))
								var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 360 /* &subgraph_index */)) + half_size)
								comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(mid_index)*40 /* &.symbol */)))) - (int32(parent_symbol)))
								if comparison <= 0 {
									*(*uint32)(unsafe.Pointer(bp + 360 /* &subgraph_index */)) = mid_index
								}
								size = size - (half_size)
							}
							comparison = (int32(*(*TSSymbol)(unsafe.Pointer(((*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((bp + 24 /* &subgraphs */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 360 /* &subgraph_index */)))*40 /* &.symbol */)))) - (int32(parent_symbol)))
							if comparison == 0 {
								*(*uint32)(unsafe.Pointer(bp + 364 /* &exists */)) = uint32(True)
							} else if comparison < 0 {
								*(*uint32)(unsafe.Pointer(bp + 360 /* &subgraph_index */)) += (uint32(1))
							}
						}
						if !(*(*uint32)(unsafe.Pointer(bp + 364 /* exists */)) != 0) {
							goto __35
						}
						var subgraph uintptr = ((*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer(bp+24 /* &subgraphs */)).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 360 /* subgraph_index */)))*40)

						// Follow every possible path in the parse table, but only visit states that
						// are part of the subgraph for the current symbol.
						*(*LookaheadIterator)(unsafe.Pointer(bp + 368 /* lookahead_iterator */)) = ts_language_lookaheads(tls, (*TSQuery)(unsafe.Pointer(self)).Language, parse_state)
						for ts_lookahead_iterator_next(tls, bp+368 /* &lookahead_iterator */) != 0 {
							var sym TSSymbol = (*LookaheadIterator)(unsafe.Pointer(bp + 368 /* &lookahead_iterator */)).Symbol
							var next_parse_state TSStateId
							if (*LookaheadIterator)(unsafe.Pointer(bp+368 /* &lookahead_iterator */)).Action_count != 0 {
								var action uintptr = ((*LookaheadIterator)(unsafe.Pointer(bp+368 /* &lookahead_iterator */)).Actions + uintptr((int32((*LookaheadIterator)(unsafe.Pointer(bp+368 /* &lookahead_iterator */)).Action_count)-1))*8)
								if int32(*(*Uint8_t)(unsafe.Pointer(action /* .Type */))) == TSParseActionTypeShift {
									if *(*uint8)(unsafe.Pointer(action /* &.shift */ + 4 /* &.extra */)) != 0 {
										next_parse_state = parse_state
									} else {
										next_parse_state = *(*TSStateId)(unsafe.Pointer(action /* &.shift */ + 2 /* &.state */))
									}
								} else {
									continue
								}
							} else if int32((*LookaheadIterator)(unsafe.Pointer(bp+368 /* &lookahead_iterator */)).Next_state) != 0 {
								next_parse_state = (*LookaheadIterator)(unsafe.Pointer(bp + 368 /* &lookahead_iterator */)).Next_state
							} else {
								continue
							}

							*(*AnalysisSubgraphNode)(unsafe.Pointer(bp + 428 /* successor */)) = AnalysisSubgraphNode{State: next_parse_state, Child_index: (uint8(child_index + uint32(1))) & 0x7f}
							// var node_index uint32 at bp+424, 4

							for ok12 := true; ok12; ok12 = 0 != 0 {
								*(*uint32)(unsafe.Pointer(bp + 424 /* &node_index */)) = uint32(0)
								*(*uint32)(unsafe.Pointer(bp + 364 /* &exists */)) = uint32(False)
								var size Uint32_t = ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Size - *(*uint32)(unsafe.Pointer(bp + 424 /* &node_index */)))
								if size == Uint32_t(0) {
									break
								}
								var comparison int32
								for size > Uint32_t(1) {
									var half_size Uint32_t = (size / Uint32_t(2))
									var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 424 /* &node_index */)) + half_size)
									comparison = analysis_subgraph_node__compare(tls, ((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Contents + uintptr(mid_index)*4), bp+428 /* &successor */)
									if comparison <= 0 {
										*(*uint32)(unsafe.Pointer(bp + 424 /* &node_index */)) = mid_index
									}
									size = size - (half_size)
								}
								comparison = analysis_subgraph_node__compare(tls, ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((subgraph + 24 /* &.nodes */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 424 /* &node_index */)))*4), bp+428 /* &successor */)
								if comparison == 0 {
									*(*uint32)(unsafe.Pointer(bp + 364 /* &exists */)) = uint32(True)
								} else if comparison < 0 {
									*(*uint32)(unsafe.Pointer(bp + 424 /* &node_index */)) += (uint32(1))
								}
							}
							for *(*uint32)(unsafe.Pointer(bp + 424 /* node_index */)) < (*AnalysisSubgraph)(unsafe.Pointer(subgraph)).Nodes.Size {
								var node uintptr = ((*AnalysisSubgraph)(unsafe.Pointer(subgraph)).Nodes.Contents + uintptr(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(bp + 424 /* node_index */)), 1))*4)
								if (int32((*AnalysisSubgraphNode)(unsafe.Pointer(node)).State) != int32((*AnalysisSubgraphNode)(unsafe.Pointer(bp+428 /* &successor */)).State)) || ((int32(*(*uint8)(unsafe.Pointer(node + 3 /* &.child_index */)) & 0x7f >> 0)) != (int32(*(*uint8)(unsafe.Pointer(bp + 428 /* &successor */ + 3 /* &.child_index */)) & 0x7f >> 0))) {
									break
								}

								// Use the subgraph to determine what alias and field will eventually be applied
								// to this child node.
								var alias TSSymbol = ts_language_alias_at(tls, (*TSQuery)(unsafe.Pointer(self)).Language, uint32((*AnalysisSubgraphNode)(unsafe.Pointer(node)).Production_id), child_index)
								var visible_symbol TSSymbol
								if alias != 0 {
									visible_symbol = alias
								} else {
									if (*TSSymbolMetadata)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Language)).Symbol_metadata+uintptr(sym)*3)).Visible != 0 {
										visible_symbol = *(*TSSymbol)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Language)).Public_symbol_map + uintptr(sym)*2))
									} else {
										visible_symbol = uint16(0)
									}
								}
								var field_id TSFieldId = parent_field_id
								if !(field_id != 0) {
									// var field_map uintptr at bp+432, 8

									// var field_map_end uintptr at bp+440, 8

									ts_language_field_map(tls, (*TSQuery)(unsafe.Pointer(self)).Language, uint32((*AnalysisSubgraphNode)(unsafe.Pointer(node)).Production_id), bp+432 /* &field_map */, bp+440 /* &field_map_end */)
									for ; *(*uintptr)(unsafe.Pointer(bp + 432 /* field_map */)) != *(*uintptr)(unsafe.Pointer(bp + 440 /* field_map_end */)); *(*uintptr)(unsafe.Pointer(bp + 432 /* field_map */)) += 4 {
										if !(int32((*TSFieldMapEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 432 /* field_map */)))).Inherited) != 0) && (uint32((*TSFieldMapEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 432 /* field_map */)))).Child_index) == child_index) {
											field_id = (*TSFieldMapEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 432 /* field_map */)))).Field_id
											break
										}
									}
								}

								// Create a new state that has advanced past this hypothetical subtree.
								*(*AnalysisState)(unsafe.Pointer(bp + 448 /* next_state */)) = *(*AnalysisState)(unsafe.Pointer(state))
								(*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, bp+448 /* &next_state */))).Child_index++
								(*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, bp+448 /* &next_state */))).Parse_state = (*AnalysisSubgraphNode)(unsafe.Pointer(bp + 428 /* &successor */)).State
								if (uint8(int32(*(*uint8)(unsafe.Pointer(node + 3 /* &.done */)) & 0x80 >> 7))) != 0 {
									libc.SetBitFieldPtr8Uint8(analysis_state__top(tls, bp+448 /* &next_state */)+7 /* &.done */, uint8(True), 7, 0x80)
								}

								// Determine if this hypothetical child node would match the current step
								// of the query pattern.
								var does_match uint8 = uint8(False)
								if visible_symbol != 0 {
									does_match = uint8(True)
									if int32((*QueryStep)(unsafe.Pointer(step)).Symbol) == int32(sNAMED_WILDCARD_SYMBOL) {
										if !(int32((*TSSymbolMetadata)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Language)).Symbol_metadata+uintptr(visible_symbol)*3)).Named) != 0) {
											does_match = uint8(False)
										}
									} else if int32((*QueryStep)(unsafe.Pointer(step)).Symbol) != int32(sWILDCARD_SYMBOL) {
										if int32((*QueryStep)(unsafe.Pointer(step)).Symbol) != int32(visible_symbol) {
											does_match = uint8(False)
										}
									}
									if ((*QueryStep)(unsafe.Pointer(step)).Field != 0) && (int32((*QueryStep)(unsafe.Pointer(step)).Field) != int32(field_id)) {
										does_match = uint8(False)
									}
									if ((*QueryStep)(unsafe.Pointer(step)).Supertype_symbol != 0) && !(analysis_state__has_supertype(tls, state, (*QueryStep)(unsafe.Pointer(step)).Supertype_symbol) != 0) {
										does_match = uint8(False)
									}
								} else if Uint32_t(sym) >= (*TSLanguage)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Language)).Token_count {
									if (int32((*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Depth) + 1) >= MAX_ANALYSIS_STATE_DEPTH {
										did_exceed_max_depth = uint8(True)
										continue
									}

									(*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Depth++
									(*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, bp+448 /* &next_state */))).Parse_state = parse_state
									(*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, bp+448 /* &next_state */))).Child_index = Uint16_t(0)
									(*AnalysisStateEntry)(unsafe.Pointer(analysis_state__top(tls, bp+448 /* &next_state */))).Parent_symbol = sym
									libc.SetBitFieldPtr16Uint16(analysis_state__top(tls, bp+448 /* &next_state */)+6 /* &.field_id */, field_id, 0, 0x7fff)
									libc.SetBitFieldPtr8Uint8(analysis_state__top(tls, bp+448 /* &next_state */)+7 /* &.done */, uint8(False), 7, 0x80)

									if analysis_state__recursion_depth(tls, bp+448 /* &next_state */) > recursion_depth_limit {
										for ok13 := true; ok13; ok13 = 0 != 0 {
											// var index uint32 at bp+548, 4

											// var exists uint32 at bp+552, 4
											for ok14 := true; ok14; ok14 = 0 != 0 {
												*(*uint32)(unsafe.Pointer(bp + 548 /* &index */)) = uint32(0)
												*(*uint32)(unsafe.Pointer(bp + 552 /* &exists */)) = uint32(False)
												var size Uint32_t = ((*AnalysisStateSet)(unsafe.Pointer((bp + 304 /* &deeper_states */))).Size - *(*uint32)(unsafe.Pointer(bp + 548 /* &index */)))
												if size == Uint32_t(0) {
													break
												}
												var comparison int32
												for size > Uint32_t(1) {
													var half_size Uint32_t = (size / Uint32_t(2))
													var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 548 /* &index */)) + half_size)
													comparison = analysis_state__compare(tls, ((*AnalysisStateSet)(unsafe.Pointer((bp + 304 /* &deeper_states */))).Contents + uintptr(mid_index)*100), bp+448 /* &next_state */)
													if comparison <= 0 {
														*(*uint32)(unsafe.Pointer(bp + 548 /* &index */)) = mid_index
													}
													size = size - (half_size)
												}
												comparison = analysis_state__compare(tls, ((*AnalysisStateSet)(unsafe.Pointer((bp + 304 /* &deeper_states */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 548 /* &index */)))*100), bp+448 /* &next_state */)
												if comparison == 0 {
													*(*uint32)(unsafe.Pointer(bp + 552 /* &exists */)) = uint32(True)
												} else if comparison < 0 {
													*(*uint32)(unsafe.Pointer(bp + 548 /* &index */)) += (uint32(1))
												}
											}
											if !(*(*uint32)(unsafe.Pointer(bp + 552 /* exists */)) != 0) {
												array__splice(tls, bp+304 /* &deeper_states */, uint64(unsafe.Sizeof(AnalysisState{})), *(*uint32)(unsafe.Pointer(bp + 548 /* index */)), uint32(0), uint32(1), bp+448 /* &next_state */)
											}
										}
										continue
									}
								}

								// Pop from the stack when this state reached the end of its current syntax node.
								for (int32((*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Depth) > 0) && ((uint8(int32(*(*uint8)(unsafe.Pointer(analysis_state__top(tls, bp+448 /* &next_state */) + 7 /* &.done */)) & 0x80 >> 7))) != 0) {
									(*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Depth--
								}

								// If this hypothetical child did match the current step of the query pattern,
								// then advance to the next step at the current depth. This involves skipping
								// over any descendant steps of the current child.
								var next_step uintptr = step
								if does_match != 0 {
									for {
										(*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Step_index++
										next_step = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Step_index)*20)
										if (int32((*QueryStep)(unsafe.Pointer(next_step)).Depth) == int32(sPATTERN_DONE_MARKER)) || (int32((*QueryStep)(unsafe.Pointer(next_step)).Depth) <= (int32(parent_depth) + 1)) {
											break
										}
									}
								} else if int32(next_parse_state) == int32(parse_state) {
									continue
								}

								for {
									// Skip pass-through states. Although these states have alternatives, they are only
									// used to implement repetitions, and query analysis does not need to process
									// repetitions in order to determine whether steps are possible and definite.
									if (uint8(int32(*(*uint8)(unsafe.Pointer(next_step + 18 /* &.is_pass_through */)) & 0x8 >> 3))) != 0 {
										(*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Step_index++
										next_step += 20
										continue
									}

									// If the pattern is finished or hypothetical parent node is complete, then
									// record that matching can terminate at this step of the pattern. Otherwise,
									// add this state to the list of states to process on the next iteration.
									if !((int32(*(*uint8)(unsafe.Pointer(next_step + 18 /* &.is_dead_end */)) & 0x10 >> 4)) != 0) {
										var did_finish_pattern uint8 = (uint8(libc.Bool32(int32((*QueryStep)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents+uintptr((*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Step_index)*20)).Depth) != (int32(parent_depth) + 1))))
										if did_finish_pattern != 0 {
											can_finish_pattern = uint8(True)
										}
										if (did_finish_pattern != 0) || (int32((*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Depth) == 0) {
											for ok15 := true; ok15; ok15 = 0 != 0 {
												// var index uint32 at bp+556, 4

												// var exists uint32 at bp+560, 4
												for ok16 := true; ok16; ok16 = 0 != 0 {
													*(*uint32)(unsafe.Pointer(bp + 556 /* &index */)) = uint32(0)
													*(*uint32)(unsafe.Pointer(bp + 560 /* &exists */)) = uint32(False)
													var size Uint32_t = ((*struct {
														Contents uintptr
														Size     Uint32_t
														Capacity Uint32_t
													})(unsafe.Pointer((bp + 320 /* &final_step_indices */))).Size - *(*uint32)(unsafe.Pointer(bp + 556 /* &index */)))
													if size == Uint32_t(0) {
														break
													}
													var comparison int32
													for size > Uint32_t(1) {
														var half_size Uint32_t = (size / Uint32_t(2))
														var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 556 /* &index */)) + half_size)
														comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
															Contents uintptr
															Size     Uint32_t
															Capacity Uint32_t
														})(unsafe.Pointer((bp + 320 /* &final_step_indices */))).Contents + uintptr(mid_index)*2)))) - (int32((*AnalysisState)(unsafe.Pointer(bp + 448 /* &next_state */)).Step_index)))
														if comparison <= 0 {
															*(*uint32)(unsafe.Pointer(bp + 556 /* &index */)) = mid_index
														}
														size = size - (half_size)
													}
													comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
														Contents uintptr
														Size     Uint32_t
														Capacity Uint32_t
													})(unsafe.Pointer((bp + 320 /* &final_step_indices */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 556 /* &index */)))*2)))) - (int32((*AnalysisState)(unsafe.Pointer(bp + 448 /* &next_state */)).Step_index)))
													if comparison == 0 {
														*(*uint32)(unsafe.Pointer(bp + 560 /* &exists */)) = uint32(True)
													} else if comparison < 0 {
														*(*uint32)(unsafe.Pointer(bp + 556 /* &index */)) += (uint32(1))
													}
												}
												if !(*(*uint32)(unsafe.Pointer(bp + 560 /* exists */)) != 0) {
													array__splice(tls, bp+320 /* &final_step_indices */, uint64(unsafe.Sizeof(Uint16_t(0))), *(*uint32)(unsafe.Pointer(bp + 556 /* index */)), uint32(0), uint32(1), (bp + 448 /* &next_state */ + 98 /* &.step_index */))
												}
											}
										} else {
											for ok17 := true; ok17; ok17 = 0 != 0 {
												// var index uint32 at bp+564, 4

												// var exists uint32 at bp+568, 4
												for ok18 := true; ok18; ok18 = 0 != 0 {
													*(*uint32)(unsafe.Pointer(bp + 564 /* &index */)) = uint32(0)
													*(*uint32)(unsafe.Pointer(bp + 568 /* &exists */)) = uint32(False)
													var size Uint32_t = ((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Size - *(*uint32)(unsafe.Pointer(bp + 564 /* &index */)))
													if size == Uint32_t(0) {
														break
													}
													var comparison int32
													for size > Uint32_t(1) {
														var half_size Uint32_t = (size / Uint32_t(2))
														var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 564 /* &index */)) + half_size)
														comparison = analysis_state__compare(tls, ((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Contents + uintptr(mid_index)*100), bp+448 /* &next_state */)
														if comparison <= 0 {
															*(*uint32)(unsafe.Pointer(bp + 564 /* &index */)) = mid_index
														}
														size = size - (half_size)
													}
													comparison = analysis_state__compare(tls, ((*AnalysisStateSet)(unsafe.Pointer((bp + 336 /* &next_states */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 564 /* &index */)))*100), bp+448 /* &next_state */)
													if comparison == 0 {
														*(*uint32)(unsafe.Pointer(bp + 568 /* &exists */)) = uint32(True)
													} else if comparison < 0 {
														*(*uint32)(unsafe.Pointer(bp + 564 /* &index */)) += (uint32(1))
													}
												}
												if !(*(*uint32)(unsafe.Pointer(bp + 568 /* exists */)) != 0) {
													array__splice(tls, bp+336 /* &next_states */, uint64(unsafe.Sizeof(AnalysisState{})), *(*uint32)(unsafe.Pointer(bp + 564 /* index */)), uint32(0), uint32(1), bp+448 /* &next_state */)
												}
											}
										}
									}

									// If the state has advanced to a step with an alternative step, then add another state
									// at that alternative step. This process is simpler than the process of actually matching a
									// pattern during query exection, because for the purposes of query analysis, there is no
									// need to process repetitions.
									if ((does_match != 0) && (int32((*QueryStep)(unsafe.Pointer(next_step)).Alternative_index) != int32(sNONE))) && (int32((*QueryStep)(unsafe.Pointer(next_step)).Alternative_index) > int32((*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Step_index)) {
										(*AnalysisState)(unsafe.Pointer(bp + 448 /* &next_state */)).Step_index = (*QueryStep)(unsafe.Pointer(next_step)).Alternative_index
										next_step = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*AnalysisState)(unsafe.Pointer(bp+448 /* &next_state */)).Step_index)*20)
									} else {
										break
									}
								}
							}
						}

					}
					goto __35
				__35:
					j++
					goto __34
					goto __36
				__36:
					;
				}

				var _states = *(*AnalysisStateSet)(unsafe.Pointer(bp + 288 /* states */))
				*(*AnalysisStateSet)(unsafe.Pointer(bp + 288 /* states */)) = *(*AnalysisStateSet)(unsafe.Pointer(bp + 336 /* next_states */))
				*(*AnalysisStateSet)(unsafe.Pointer(bp + 336 /* next_states */)) = _states
			}

			// Mark as indefinite any step where a match terminated.
			// Later, this property will be propagated to all of the step's predecessors.
			{
				var j1 uint32 = uint32(0)
			__37:
				if !(j1 < (*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer(bp+320 /* &final_step_indices */)).Size) {
					goto __39
				}
				{
					var final_step_index Uint32_t = Uint32_t(*(*Uint16_t)(unsafe.Pointer((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer(bp+320 /* &final_step_indices */)).Contents + uintptr(j1)*2)))
					var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(final_step_index)*20)
					if ((int32((*QueryStep)(unsafe.Pointer(step)).Depth) != int32(sPATTERN_DONE_MARKER)) && (int32((*QueryStep)(unsafe.Pointer(step)).Depth) > int32(parent_depth))) && !((int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_dead_end */)) & 0x10 >> 4)) != 0) {
						libc.SetBitFieldPtr8Uint8(step+18 /* &.is_definite */, uint8(False), 6, 0x40)
					}

				}
				goto __38
			__38:
				j1++
				goto __37
				goto __39
			__39:
				;
			}

			if did_exceed_max_depth != 0 {
				{
					var j uint32 = (uint32(int32(parent_step_index) + 1))
				__40:
					if !(j < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
						goto __42
					}
					{
						var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(j)*20)
						if (int32((*QueryStep)(unsafe.Pointer(step)).Depth) <= int32(parent_depth)) || (int32((*QueryStep)(unsafe.Pointer(step)).Depth) == int32(sPATTERN_DONE_MARKER)) {
							goto __42
						}
						if !((int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_dead_end */)) & 0x10 >> 4)) != 0) {
							libc.SetBitFieldPtr8Uint8(step+18 /* &.is_definite */, uint8(False), 6, 0x40)
						}

					}
					goto __41
				__41:
					j++
					goto __40
					goto __42
				__42:
					;
				}
			}

			// If this pattern cannot match, store the pattern index so that it can be
			// returned to the caller.
			if ((all_patterns_are_valid != 0) && !(can_finish_pattern != 0)) && !(did_exceed_max_depth != 0) {
				if libc.X__builtin_expect(tls, libc.BoolInt64(!((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer(bp+320 /* &final_step_indices */)).Size > Uint32_t(0))), int64(0)) != 0 {
					libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__77)), ts+2293 /* "upstream/tree-si..." */, 1269, ts+2588 /* "final_step_indic..." */)
				} else {
				}
				var impossible_step_index Uint16_t = *(*Uint16_t)(unsafe.Pointer(func() uintptr {
					if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp+320 /* &final_step_indices */))).Size-Uint32_t(1)) < (*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp+320 /* &final_step_indices */))).Size)), int64(0)) != 0 {
						libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__77)), ts+2293 /* "upstream/tree-si..." */, 1270, ts+2616 /* "(uint32_t)(&fina..." */)
					} else {
					}
					return ((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp + 320 /* &final_step_indices */))).Contents + uintptr(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((bp+320 /* &final_step_indices */))).Size-Uint32_t(1)))*2)
				}()))
				// var i Uint32_t at bp+572, 4

				// var exists Uint32_t at bp+576, 4

				for ok19 := true; ok19; ok19 = 0 != 0 {
					*(*Uint32_t)(unsafe.Pointer(bp + 572 /* &i */)) = Uint32_t(0)
					*(*Uint32_t)(unsafe.Pointer(bp + 576 /* &exists */)) = Uint32_t(False)
					var size Uint32_t = ((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Size - *(*Uint32_t)(unsafe.Pointer(bp + 572 /* &i */)))
					if size == Uint32_t(0) {
						break
					}
					var comparison int32
					for size > Uint32_t(1) {
						var half_size Uint32_t = (size / Uint32_t(2))
						var mid_index Uint32_t = (*(*Uint32_t)(unsafe.Pointer(bp + 572 /* &i */)) + half_size)
						comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Contents + uintptr(mid_index)*8 + 4 /* &.step_index */)))) - (int32(impossible_step_index)))
						if comparison <= 0 {
							*(*Uint32_t)(unsafe.Pointer(bp + 572 /* &i */)) = mid_index
						}
						size = size - (half_size)
					}
					comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Contents + uintptr(*(*Uint32_t)(unsafe.Pointer(bp + 572 /* &i */)))*8 + 4 /* &.step_index */)))) - (int32(impossible_step_index)))
					if comparison == 0 {
						*(*Uint32_t)(unsafe.Pointer(bp + 576 /* &exists */)) = Uint32_t(True)
					} else if comparison < 0 {
						*(*Uint32_t)(unsafe.Pointer(bp + 572 /* &i */)) += (Uint32_t(1))
					}
				}
				if *(*Uint32_t)(unsafe.Pointer(bp + 572 /* i */)) >= (*TSQuery)(unsafe.Pointer(self)).Step_offsets.Size {
					*(*Uint32_t)(unsafe.Pointer(bp + 572 /* i */)) = ((*TSQuery)(unsafe.Pointer(self)).Step_offsets.Size - Uint32_t(1))
				}
				*(*uint32)(unsafe.Pointer(error_offset)) = (*StepOffset)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Step_offsets.Contents + uintptr(*(*Uint32_t)(unsafe.Pointer(bp + 572 /* i */)))*8)).Byte_offset
				all_patterns_are_valid = uint8(False)
				goto __30
			}

		}
		goto __29
	__29:
		i3++
		goto __28
		goto __30
	__30:
		;
	}

	// Mark as indefinite any step with captures that are used in predicates.
	*(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp + 584 /* predicate_capture_ids */)) = struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}{}
	{
		var i4 uint32 = uint32(0)
	__43:
		if !(i4 < (*TSQuery)(unsafe.Pointer(self)).Patterns.Size) {
			goto __45
		}
		{
			var pattern uintptr = ((*TSQuery)(unsafe.Pointer(self)).Patterns.Contents + uintptr(i4)*20)

			// Gather all of the captures that are used in predicates for this pattern.
			(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp + 584 /* &predicate_capture_ids */)).Size = Uint32_t(0)
			{
				var start uint32 = (*QueryPattern)(unsafe.Pointer(pattern)).Predicate_steps.Offset
				var end uint32 = (start + (*QueryPattern)(unsafe.Pointer(pattern)).Predicate_steps.Length)
				var j uint32 = start
			__46:
				if !(j < end) {
					goto __48
				}
				{
					var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Predicate_steps.Contents + uintptr(j)*8)
					if (*TSQueryPredicateStep)(unsafe.Pointer(step)).Type == TSQueryPredicateStepTypeCapture {
						for ok20 := true; ok20; ok20 = 0 != 0 {
							// var index uint32 at bp+600, 4

							// var exists uint32 at bp+604, 4
							for ok21 := true; ok21; ok21 = 0 != 0 {
								*(*uint32)(unsafe.Pointer(bp + 600 /* &index */)) = uint32(0)
								*(*uint32)(unsafe.Pointer(bp + 604 /* &exists */)) = uint32(False)
								var size Uint32_t = ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 584 /* &predicate_capture_ids */))).Size - *(*uint32)(unsafe.Pointer(bp + 600 /* &index */)))
								if size == Uint32_t(0) {
									break
								}
								var comparison int32
								for size > Uint32_t(1) {
									var half_size Uint32_t = (size / Uint32_t(2))
									var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 600 /* &index */)) + half_size)
									comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((bp + 584 /* &predicate_capture_ids */))).Contents + uintptr(mid_index)*2)))) - (int32((*TSQueryPredicateStep)(unsafe.Pointer(step)).Value_id)))
									if comparison <= 0 {
										*(*uint32)(unsafe.Pointer(bp + 600 /* &index */)) = mid_index
									}
									size = size - (half_size)
								}
								comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 584 /* &predicate_capture_ids */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 600 /* &index */)))*2)))) - (int32((*TSQueryPredicateStep)(unsafe.Pointer(step)).Value_id)))
								if comparison == 0 {
									*(*uint32)(unsafe.Pointer(bp + 604 /* &exists */)) = uint32(True)
								} else if comparison < 0 {
									*(*uint32)(unsafe.Pointer(bp + 600 /* &index */)) += (uint32(1))
								}
							}
							if !(*(*uint32)(unsafe.Pointer(bp + 604 /* exists */)) != 0) {
								array__splice(tls, bp+584 /* &predicate_capture_ids */, uint64(unsafe.Sizeof(Uint16_t(0))), *(*uint32)(unsafe.Pointer(bp + 600 /* index */)), uint32(0), uint32(1), (step + 4 /* &.value_id */))
							}
						}
					}

				}
				goto __47
			__47:
				j++
				goto __46
				goto __48
			__48:
				;
			}

			// Find all of the steps that have these captures.
			{
				var start1 uint32 = (*QueryPattern)(unsafe.Pointer(pattern)).Steps.Offset
				var end1 uint32 = (start1 + (*QueryPattern)(unsafe.Pointer(pattern)).Steps.Length)
				var j1 uint32 = start1
			__49:
				if !(j1 < end1) {
					goto __51
				}
				{
					var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(j1)*20)
					{
						var k uint32 = uint32(0)
					__52:
						if !(k < uint32(MAX_STEP_CAPTURE_COUNT)) {
							goto __54
						}
						{
							var capture_id Uint16_t = *(*Uint16_t)(unsafe.Pointer((step + 6 /* &.capture_ids */) + uintptr(k)*2))
							if int32(capture_id) == int32(sNONE) {
								goto __54
							}
							// var index uint32 at bp+608, 4

							// var exists uint32 at bp+612, 4

							for ok22 := true; ok22; ok22 = 0 != 0 {
								*(*uint32)(unsafe.Pointer(bp + 608 /* &index */)) = uint32(0)
								*(*uint32)(unsafe.Pointer(bp + 612 /* &exists */)) = uint32(False)
								var size Uint32_t = ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 584 /* &predicate_capture_ids */))).Size - *(*uint32)(unsafe.Pointer(bp + 608 /* &index */)))
								if size == Uint32_t(0) {
									break
								}
								var comparison int32
								for size > Uint32_t(1) {
									var half_size Uint32_t = (size / Uint32_t(2))
									var mid_index Uint32_t = (*(*uint32)(unsafe.Pointer(bp + 608 /* &index */)) + half_size)
									comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
										Contents uintptr
										Size     Uint32_t
										Capacity Uint32_t
									})(unsafe.Pointer((bp + 584 /* &predicate_capture_ids */))).Contents + uintptr(mid_index)*2)))) - (int32(capture_id)))
									if comparison <= 0 {
										*(*uint32)(unsafe.Pointer(bp + 608 /* &index */)) = mid_index
									}
									size = size - (half_size)
								}
								comparison = (int32(*(*Uint16_t)(unsafe.Pointer(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((bp + 584 /* &predicate_capture_ids */))).Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 608 /* &index */)))*2)))) - (int32(capture_id)))
								if comparison == 0 {
									*(*uint32)(unsafe.Pointer(bp + 612 /* &exists */)) = uint32(True)
								} else if comparison < 0 {
									*(*uint32)(unsafe.Pointer(bp + 608 /* &index */)) += (uint32(1))
								}
							}
							if *(*uint32)(unsafe.Pointer(bp + 612 /* exists */)) != 0 {
								libc.SetBitFieldPtr8Uint8(step+18 /* &.is_definite */, uint8(False), 6, 0x40)
								goto __54
							}

						}
						goto __53
					__53:
						k++
						goto __52
						goto __54
					__54:
						;
					}

				}
				goto __50
			__50:
				j1++
				goto __49
				goto __51
			__51:
				;
			}

		}
		goto __44
	__44:
		i4++
		goto __43
		goto __45
	__45:
		;
	}

	// Propagate indefiniteness backwards.
	var done uint8 = (uint8(libc.Bool32((*TSQuery)(unsafe.Pointer(self)).Steps.Size == Uint32_t(0))))
	for !(done != 0) {
		done = uint8(True)
		{
			var i uint32 = ((*TSQuery)(unsafe.Pointer(self)).Steps.Size - Uint32_t(1))
		__55:
			if !(i > uint32(0)) {
				goto __57
			}
			{
				var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(i)*20)

				// Determine if this step is definite or has definite alternatives.
				var is_definite uint8 = uint8(False)
				for {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_definite */)) & 0x40 >> 6))) != 0 {
						is_definite = uint8(True)
						break
					}
					if (int32((*QueryStep)(unsafe.Pointer(step)).Alternative_index) == int32(sNONE)) || (uint32((*QueryStep)(unsafe.Pointer(step)).Alternative_index) < i) {
						break
					}
					step = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*QueryStep)(unsafe.Pointer(step)).Alternative_index)*20)
				}

				// If not, mark its predecessor as indefinite.
				if !(is_definite != 0) {
					var prev_step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((i-uint32(1)))*20)
					if (!((int32(*(*uint8)(unsafe.Pointer(prev_step + 18 /* &.is_dead_end */)) & 0x10 >> 4)) != 0) && (int32((*QueryStep)(unsafe.Pointer(prev_step)).Depth) != int32(sPATTERN_DONE_MARKER))) && ((uint8(int32(*(*uint8)(unsafe.Pointer(prev_step + 18 /* &.is_definite */)) & 0x40 >> 6))) != 0) {
						libc.SetBitFieldPtr8Uint8(prev_step+18 /* &.is_definite */, uint8(False), 6, 0x40)
						done = uint8(False)
					}
				}

			}
			goto __56
		__56:
			i--
			goto __55
			goto __57
		__57:
			;
		}
	}

	// Cleanup
	{
		var i5 uint32 = uint32(0)
	__58:
		if !(i5 < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer(bp+24 /* &subgraphs */)).Size) {
			goto __60
		}
		{
			array__delete(tls, ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp+24 /* &subgraphs */)).Contents + uintptr(i5)*40 + 8 /* &.start_states */))
			array__delete(tls, ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp+24 /* &subgraphs */)).Contents + uintptr(i5)*40 + 24 /* &.nodes */))

		}
		goto __59
	__59:
		i5++
		goto __58
		goto __60
	__60:
		;
	}
	array__delete(tls, bp+24 /* &subgraphs */)
	array__delete(tls, bp+232 /* &next_nodes */)
	array__delete(tls, bp+288 /* &states */)
	array__delete(tls, bp+336 /* &next_states */)
	array__delete(tls, bp+304 /* &deeper_states */)
	array__delete(tls, bp+320 /* &final_step_indices */)
	array__delete(tls, bp /* &parent_step_indices */)
	array__delete(tls, bp+584 /* &predicate_capture_ids */)
	state_predecessor_map_delete(tls, bp+208 /* &predecessor_map */)

	return all_patterns_are_valid
}

var __func__77 = *(*[27]int8)(unsafe.Pointer(ts + 2688 /* "ts_query__analyz..." */)) /* query.c:746:79 */

func ts_query__finalize_steps(tls *libc.TLS, self uintptr) { /* query.c:1391:13: */
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
			goto __3
		}
		{
			var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(i)*20)
			var depth Uint32_t = Uint32_t((*QueryStep)(unsafe.Pointer(step)).Depth)
			if int32(*(*Uint16_t)(unsafe.Pointer((step + 6 /* &.capture_ids */)))) != int32(sNONE) {
				libc.SetBitFieldPtr8Uint8(step+18 /* &.contains_captures */, uint8(True), 0, 0x1)
			} else {
				libc.SetBitFieldPtr8Uint8(step+18 /* &.contains_captures */, uint8(False), 0, 0x1)
				{
					var j uint32 = (i + uint32(1))
				__4:
					if !(j < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
						goto __6
					}
					{
						var s uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(j)*20)
						if (int32((*QueryStep)(unsafe.Pointer(s)).Depth) == int32(sPATTERN_DONE_MARKER)) || (Uint32_t((*QueryStep)(unsafe.Pointer(s)).Depth) <= depth) {
							goto __6
						}
						if int32(*(*Uint16_t)(unsafe.Pointer((s + 6 /* &.capture_ids */)))) != int32(sNONE) {
							libc.SetBitFieldPtr8Uint8(step+18 /* &.contains_captures */, uint8(True), 0, 0x1)
						}

					}
					goto __5
				__5:
					j++
					goto __4
					goto __6
				__6:
					;
				}
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
}

func ts_query__add_negated_fields(tls *libc.TLS, self uintptr, step_index Uint16_t, field_ids uintptr, field_count Uint16_t) { /* query.c:1408:13: */
	var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20)

	// The negated field array stores a list of field lists, separated by zeros.
	// Try to find the start index of an existing list that matches this new list.
	var failed_match uint8 = uint8(False)
	var match_count uint32 = uint32(0)
	var start_i uint32 = uint32(0)
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSQuery)(unsafe.Pointer(self)).Negated_fields.Size) {
			goto __3
		}
		{
			var existing_field_id TSFieldId = *(*TSFieldId)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Negated_fields.Contents + uintptr(i)*2))

			// At each zero value, terminate the match attempt. If we've exactly
			// matched the new field list, then reuse this index. Otherwise,
			// start over the matching process.
			if int32(existing_field_id) == 0 {
				if match_count == uint32(field_count) {
					(*QueryStep)(unsafe.Pointer(step)).Negated_field_list_id = Uint16_t(start_i)
					return
				} else {
					start_i = (i + uint32(1))
					match_count = uint32(0)
					failed_match = uint8(False)
				}
			} else if ((match_count < uint32(field_count)) && (int32(existing_field_id) == int32(*(*TSFieldId)(unsafe.Pointer(field_ids + uintptr(match_count)*2))))) && !(failed_match != 0) {
				match_count++
			} else {
				match_count = uint32(0)
				failed_match = uint8(True)
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	(*QueryStep)(unsafe.Pointer(step)).Negated_field_list_id = Uint16_t((*TSQuery)(unsafe.Pointer(self)).Negated_fields.Size)
	array__splice(tls, (self + 144 /* &.negated_fields */), uint64(unsafe.Sizeof(TSFieldId(0))), (*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 144 /* &.negated_fields */))).Size, uint32(0), uint32(field_count), field_ids)
	array__grow(tls, (self + 144 /* &.negated_fields */), uint64(1), uint64(unsafe.Sizeof(TSFieldId(0))))
	*(*TSFieldId)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 144 /* &.negated_fields */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self+144 /* &.negated_fields */))).Size, 1))*2)) = TSFieldId(0)
}

func ts_query__parse_string_literal(tls *libc.TLS, self uintptr, stream uintptr) TSQueryError { /* query.c:1460:21: */
	var string_start uintptr = (*Stream)(unsafe.Pointer(stream)).Input
	if (*Stream)(unsafe.Pointer(stream)).Next != '"' {
		return TSQueryErrorSyntax
	}
	stream_advance(tls, stream)
	var prev_position uintptr = (*Stream)(unsafe.Pointer(stream)).Input

	var is_escaped uint8 = uint8(False)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Size = Uint32_t(0)
	for {
		if is_escaped != 0 {
			is_escaped = uint8(False)
			switch (*Stream)(unsafe.Pointer(stream)).Next {
			case 'n':
				array__grow(tls, (self + 160 /* &.string_buffer */), uint64(1), uint64(unsafe.Sizeof(int8(0))))
				*(*int8)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+160 /* &.string_buffer */))).Size, 1)))) = int8('\n')
				break
				fallthrough
			case 'r':
				array__grow(tls, (self + 160 /* &.string_buffer */), uint64(1), uint64(unsafe.Sizeof(int8(0))))
				*(*int8)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+160 /* &.string_buffer */))).Size, 1)))) = int8('\r')
				break
				fallthrough
			case 't':
				array__grow(tls, (self + 160 /* &.string_buffer */), uint64(1), uint64(unsafe.Sizeof(int8(0))))
				*(*int8)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+160 /* &.string_buffer */))).Size, 1)))) = int8('\t')
				break
				fallthrough
			case '0':
				array__grow(tls, (self + 160 /* &.string_buffer */), uint64(1), uint64(unsafe.Sizeof(int8(0))))
				*(*int8)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+160 /* &.string_buffer */))).Size, 1)))) = int8(0)
				break
				fallthrough
			default:
				array__splice(tls, (self + 160 /* &.string_buffer */), uint64(unsafe.Sizeof(int8(0))), (*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Size, uint32(0), uint32((*Stream)(unsafe.Pointer(stream)).Next_size), (*Stream)(unsafe.Pointer(stream)).Input)
				break
			}
			prev_position = ((*Stream)(unsafe.Pointer(stream)).Input + uintptr((*Stream)(unsafe.Pointer(stream)).Next_size))
		} else {
			if (*Stream)(unsafe.Pointer(stream)).Next == '\\' {
				array__splice(tls, (self + 160 /* &.string_buffer */), uint64(unsafe.Sizeof(int8(0))), (*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Size, uint32(0), (uint32((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(prev_position)) / 1)), prev_position)
				prev_position = ((*Stream)(unsafe.Pointer(stream)).Input + uintptr(1))
				is_escaped = uint8(True)
			} else if (*Stream)(unsafe.Pointer(stream)).Next == '"' {
				array__splice(tls, (self + 160 /* &.string_buffer */), uint64(unsafe.Sizeof(int8(0))), (*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 160 /* &.string_buffer */))).Size, uint32(0), (uint32((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(prev_position)) / 1)), prev_position)
				stream_advance(tls, stream)
				return TSQueryErrorNone
			} else if (*Stream)(unsafe.Pointer(stream)).Next == '\n' {
				stream_reset(tls, stream, string_start)
				return TSQueryErrorSyntax
			}
		}
		if !(stream_advance(tls, stream) != 0) {
			stream_reset(tls, stream, string_start)
			return TSQueryErrorSyntax
		}
	}
	return TSQueryError(0)
}

// Parse a single predicate associated with a pattern, adding it to the
// query's internal `predicate_steps` array. Predicates are arbitrary
// S-expressions associated with a pattern which are meant to be handled at
// a higher level of abstraction, such as the Rust/JavaScript bindings. They
// can contain '@'-prefixed capture names, double-quoted strings, and bare
// symbols, which also represent strings.
func ts_query__parse_predicate(tls *libc.TLS, self uintptr, stream uintptr) TSQueryError { /* query.c:1519:21: */
	if !(stream_is_ident_start(tls, stream) != 0) {
		return TSQueryErrorSyntax
	}
	var predicate_name uintptr = (*Stream)(unsafe.Pointer(stream)).Input
	stream_scan_identifier(tls, stream)
	var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(predicate_name)) / 1))
	var id Uint16_t = symbol_table_insert_name(tls,
		(self + 32 /* &.predicate_values */),
		predicate_name,
		length)
	array__grow(tls, (self + 96 /* &.predicate_steps */), uint64(1), uint64(unsafe.Sizeof(TSQueryPredicateStep{})))
	*(*TSQueryPredicateStep)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 96 /* &.predicate_steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self+96 /* &.predicate_steps */))).Size, 1))*8)) = TSQueryPredicateStep{Type: TSQueryPredicateStepTypeString, Value_id: Uint32_t(id)}
	stream_skip_whitespace(tls, stream)

	for {
		if (*Stream)(unsafe.Pointer(stream)).Next == ')' {
			stream_advance(tls, stream)
			stream_skip_whitespace(tls, stream)
			array__grow(tls, (self + 96 /* &.predicate_steps */), uint64(1), uint64(unsafe.Sizeof(TSQueryPredicateStep{})))
			*(*TSQueryPredicateStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 96 /* &.predicate_steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+96 /* &.predicate_steps */))).Size, 1))*8)) = TSQueryPredicateStep{}
			break
		} else if (*Stream)(unsafe.Pointer(stream)).Next == '@' {
			stream_advance(tls, stream)

			// Parse the capture name
			if !(stream_is_ident_start(tls, stream) != 0) {
				return TSQueryErrorSyntax
			}
			var capture_name uintptr = (*Stream)(unsafe.Pointer(stream)).Input
			stream_scan_identifier(tls, stream)
			var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(capture_name)) / 1))

			// Add the capture id to the first step of the pattern
			var capture_id int32 = symbol_table_id_for_name(tls,
				(self /* &.captures */),
				capture_name,
				length)
			if capture_id == -1 {
				stream_reset(tls, stream, capture_name)
				return TSQueryErrorCapture
			}

			array__grow(tls, (self + 96 /* &.predicate_steps */), uint64(1), uint64(unsafe.Sizeof(TSQueryPredicateStep{})))
			*(*TSQueryPredicateStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 96 /* &.predicate_steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+96 /* &.predicate_steps */))).Size, 1))*8)) = TSQueryPredicateStep{Type: TSQueryPredicateStepTypeCapture, Value_id: Uint32_t(capture_id)}
		} else if (*Stream)(unsafe.Pointer(stream)).Next == '"' {
			var e TSQueryError = ts_query__parse_string_literal(tls, self, stream)
			if e != 0 {
				return e
			}
			var id Uint16_t = symbol_table_insert_name(tls,
				(self + 32 /* &.predicate_values */),
				(*TSQuery)(unsafe.Pointer(self)).String_buffer.Contents,
				(*TSQuery)(unsafe.Pointer(self)).String_buffer.Size)
			array__grow(tls, (self + 96 /* &.predicate_steps */), uint64(1), uint64(unsafe.Sizeof(TSQueryPredicateStep{})))
			*(*TSQueryPredicateStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 96 /* &.predicate_steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+96 /* &.predicate_steps */))).Size, 1))*8)) = TSQueryPredicateStep{Type: TSQueryPredicateStepTypeString, Value_id: Uint32_t(id)}
		} else if stream_is_ident_start(tls, stream) != 0 {
			var symbol_start uintptr = (*Stream)(unsafe.Pointer(stream)).Input
			stream_scan_identifier(tls, stream)
			var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(symbol_start)) / 1))
			var id Uint16_t = symbol_table_insert_name(tls,
				(self + 32 /* &.predicate_values */),
				symbol_start,
				length)
			array__grow(tls, (self + 96 /* &.predicate_steps */), uint64(1), uint64(unsafe.Sizeof(TSQueryPredicateStep{})))
			*(*TSQueryPredicateStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 96 /* &.predicate_steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+96 /* &.predicate_steps */))).Size, 1))*8)) = TSQueryPredicateStep{Type: TSQueryPredicateStepTypeString, Value_id: Uint32_t(id)}
		} else {
			return TSQueryErrorSyntax
		}

		stream_skip_whitespace(tls, stream)
	}

	return TSQueryError(0)
}

// Read one S-expression pattern from the stream, and incorporate it into
// the query's internal state machine representation. For nested patterns,
// this function calls itself recursively.
func ts_query__parse_pattern(tls *libc.TLS, self uintptr, stream uintptr, depth Uint32_t, is_immediate uint8) TSQueryError { /* query.c:1620:21: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	if (*Stream)(unsafe.Pointer(stream)).Next == 0 {
		return TSQueryErrorSyntax
	}
	if ((*Stream)(unsafe.Pointer(stream)).Next == ')') || ((*Stream)(unsafe.Pointer(stream)).Next == ']') {
		return sPARENT_DONE
	}

	var starting_step_index Uint32_t = (*TSQuery)(unsafe.Pointer(self)).Steps.Size

	// Store the byte offset of each step in the query.
	if ((*TSQuery)(unsafe.Pointer(self)).Step_offsets.Size == Uint32_t(0)) || (Uint32_t((*StepOffset)(unsafe.Pointer((func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+128 /* &.step_offsets */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+128 /* &.step_offsets */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__78)), ts+2293 /* "upstream/tree-si..." */, 1634, ts+2715 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+128 /* &.step_offsets */))).Size-Uint32_t(1)))*8)
	}()))).Step_index) != starting_step_index) {
		array__grow(tls, (self + 128 /* &.step_offsets */), uint64(1), uint64(unsafe.Sizeof(StepOffset{})))
		*(*StepOffset)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 128 /* &.step_offsets */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+128 /* &.step_offsets */))).Size, 1))*8)) = StepOffset{Byte_offset: stream_offset(tls, stream), Step_index: Uint16_t(starting_step_index)}
	}

	// An open bracket is the start of an alternation.
	if (*Stream)(unsafe.Pointer(stream)).Next == '[' {
		stream_advance(tls, stream)
		stream_skip_whitespace(tls, stream)

		// Parse each branch, and add a placeholder step in between the branches.
		*(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer(bp /* branch_step_indices */)) = struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		}{}
		for {
			var start_index Uint32_t = (*TSQuery)(unsafe.Pointer(self)).Steps.Size
			var e TSQueryError = ts_query__parse_pattern(tls,
				self,
				stream,
				depth,
				is_immediate)

			if ((e == sPARENT_DONE) && ((*Stream)(unsafe.Pointer(stream)).Next == ']')) && ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp /* &branch_step_indices */)).Size > Uint32_t(0)) {
				stream_advance(tls, stream)
				break
			} else if e != 0 {
				if e == sPARENT_DONE {
					e = TSQueryErrorSyntax
				}
				array__delete(tls, bp /* &branch_step_indices */)
				return e
			}

			array__grow(tls, bp /* &branch_step_indices */, uint64(1), uint64(unsafe.Sizeof(Uint32_t(0))))
			*(*Uint32_t)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((bp /* &branch_step_indices */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp /* &branch_step_indices */)).Size, 1))*4)) = start_index
			array__grow(tls, (self + 64 /* &.steps */), uint64(1), uint64(unsafe.Sizeof(QueryStep{})))
			*(*QueryStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20)) = query_step__new(tls, uint16(0), uint16(depth), uint8(False))
		}
		_ = *(*QueryStep)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PreDecUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20))

		// For all of the branches except for the last one, add the subsequent branch as an
		// alternative, and link the end of the branch to the current end of the steps.
		{
			var i uint32 = uint32(0)
		__1:
			if !(i < ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer(bp /* &branch_step_indices */)).Size - Uint32_t(1))) {
				goto __3
			}
			{
				var step_index Uint32_t = *(*Uint32_t)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer(bp /* &branch_step_indices */)).Contents + uintptr(i)*4))
				var next_step_index Uint32_t = *(*Uint32_t)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer(bp /* &branch_step_indices */)).Contents + uintptr((i+uint32(1)))*4))
				var start_step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20)
				var end_step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((next_step_index-Uint32_t(1)))*20)
				(*QueryStep)(unsafe.Pointer(start_step)).Alternative_index = Uint16_t(next_step_index)
				(*QueryStep)(unsafe.Pointer(end_step)).Alternative_index = Uint16_t((*TSQuery)(unsafe.Pointer(self)).Steps.Size)
				libc.SetBitFieldPtr8Uint8(end_step+18 /* &.is_dead_end */, uint8(True), 4, 0x10)

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}

		array__delete(tls, bp /* &branch_step_indices */)
	} else if (*Stream)(unsafe.Pointer(stream)).Next == '(' {
		stream_advance(tls, stream)
		stream_skip_whitespace(tls, stream)

		// If this parenthesis is followed by a node, then it represents a grouped sequence.
		if (((*Stream)(unsafe.Pointer(stream)).Next == '(') || ((*Stream)(unsafe.Pointer(stream)).Next == '"')) || ((*Stream)(unsafe.Pointer(stream)).Next == '[') {
			var child_is_immediate uint8 = uint8(False)
			for {
				if (*Stream)(unsafe.Pointer(stream)).Next == '.' {
					child_is_immediate = uint8(True)
					stream_advance(tls, stream)
					stream_skip_whitespace(tls, stream)
				}
				var e TSQueryError = ts_query__parse_pattern(tls,
					self,
					stream,
					depth,
					child_is_immediate)
				if (e == sPARENT_DONE) && ((*Stream)(unsafe.Pointer(stream)).Next == ')') {
					stream_advance(tls, stream)
					break
				} else if e != 0 {
					return e
				}

				child_is_immediate = uint8(False)
			}
		} else if ((*Stream)(unsafe.Pointer(stream)).Next == '.') || ((*Stream)(unsafe.Pointer(stream)).Next == '#') {
			stream_advance(tls, stream)
			return ts_query__parse_predicate(tls, self, stream)
		} else {
			var symbol TSSymbol

			// TODO - remove.
			// For temporary backward compatibility, handle '*' as a wildcard.
			if (*Stream)(unsafe.Pointer(stream)).Next == '*' {
				if depth > Uint32_t(0) {
					symbol = sNAMED_WILDCARD_SYMBOL
				} else {
					symbol = sWILDCARD_SYMBOL
				}
				stream_advance(tls, stream)
			} else if stream_is_ident_start(tls, stream) != 0 {
				var node_name uintptr = (*Stream)(unsafe.Pointer(stream)).Input
				stream_scan_identifier(tls, stream)
				var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(node_name)) / 1))

				// TODO - remove.
				// For temporary backward compatibility, handle predicates without the leading '#' sign.
				if (length > Uint32_t(0)) && ((int32(*(*int8)(unsafe.Pointer(node_name + uintptr((length - Uint32_t(1)))))) == '!') || (int32(*(*int8)(unsafe.Pointer(node_name + uintptr((length - Uint32_t(1)))))) == '?')) {
					stream_reset(tls, stream, node_name)
					return ts_query__parse_predicate(tls, self, stream)
				} else if (length == Uint32_t(1)) && (int32(*(*int8)(unsafe.Pointer(node_name))) == '_') {
					if depth > Uint32_t(0) {
						symbol = sNAMED_WILDCARD_SYMBOL
					} else {
						symbol = sWILDCARD_SYMBOL
					}
				} else {
					symbol = Xts_language_symbol_for_name(tls,
						(*TSQuery)(unsafe.Pointer(self)).Language,
						node_name,
						length,
						uint8(True))
					if !(symbol != 0) {
						stream_reset(tls, stream, node_name)
						return TSQueryErrorNodeType
					}
				}
			} else {
				return TSQueryErrorSyntax
			}

			// Add a step for the node.
			array__grow(tls, (self + 64 /* &.steps */), uint64(1), uint64(unsafe.Sizeof(QueryStep{})))
			*(*QueryStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20)) = query_step__new(tls, symbol, uint16(depth), is_immediate)
			if Xts_language_symbol_metadata(tls, (*TSQuery)(unsafe.Pointer(self)).Language, symbol).Supertype != 0 {
				var step uintptr = func() uintptr {
					if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+64 /* &.steps */))).Size-Uint32_t(1)) < (*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+64 /* &.steps */))).Size)), int64(0)) != 0 {
						libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__78)), ts+2293 /* "upstream/tree-si..." */, 1775, ts+2787 /* "(uint32_t)(&self..." */)
					} else {
					}
					return ((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+64 /* &.steps */))).Size-Uint32_t(1)))*20)
				}()
				(*QueryStep)(unsafe.Pointer(step)).Supertype_symbol = (*QueryStep)(unsafe.Pointer(step)).Symbol
				(*QueryStep)(unsafe.Pointer(step)).Symbol = sNAMED_WILDCARD_SYMBOL
			}

			stream_skip_whitespace(tls, stream)

			if (*Stream)(unsafe.Pointer(stream)).Next == '/' {
				stream_advance(tls, stream)
				if !(stream_is_ident_start(tls, stream) != 0) {
					return TSQueryErrorSyntax
				}

				var node_name uintptr = (*Stream)(unsafe.Pointer(stream)).Input
				stream_scan_identifier(tls, stream)
				var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(node_name)) / 1))

				var step uintptr = func() uintptr {
					if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+64 /* &.steps */))).Size-Uint32_t(1)) < (*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+64 /* &.steps */))).Size)), int64(0)) != 0 {
						libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__78)), ts+2293 /* "upstream/tree-si..." */, 1792, ts+2787 /* "(uint32_t)(&self..." */)
					} else {
					}
					return ((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+64 /* &.steps */))).Size-Uint32_t(1)))*20)
				}()
				(*QueryStep)(unsafe.Pointer(step)).Symbol = Xts_language_symbol_for_name(tls,
					(*TSQuery)(unsafe.Pointer(self)).Language,
					node_name,
					length,
					uint8(True))
				if !(int32((*QueryStep)(unsafe.Pointer(step)).Symbol) != 0) {
					stream_reset(tls, stream, node_name)
					return TSQueryErrorNodeType
				}

				stream_skip_whitespace(tls, stream)
			}

			// Parse the child patterns
			var child_is_immediate uint8 = uint8(False)
			var last_child_step_index Uint16_t = Uint16_t(0)
			var negated_field_count Uint16_t = Uint16_t(0)
			// var negated_field_ids [8]TSFieldId at bp+16, 16

			for {
				// Parse a negated field assertion
				if (*Stream)(unsafe.Pointer(stream)).Next == '!' {
					stream_advance(tls, stream)
					stream_skip_whitespace(tls, stream)
					if !(stream_is_ident_start(tls, stream) != 0) {
						return TSQueryErrorSyntax
					}
					var field_name uintptr = (*Stream)(unsafe.Pointer(stream)).Input
					stream_scan_identifier(tls, stream)
					var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(field_name)) / 1))
					stream_skip_whitespace(tls, stream)

					var field_id TSFieldId = Xts_language_field_id_for_name(tls,
						(*TSQuery)(unsafe.Pointer(self)).Language,
						field_name,
						length)
					if !(field_id != 0) {
						(*Stream)(unsafe.Pointer(stream)).Input = field_name
						return TSQueryErrorField
					}

					// Keep the field ids sorted.
					if int32(negated_field_count) < MAX_NEGATED_FIELD_COUNT {
						*(*TSFieldId)(unsafe.Pointer(bp + 16 /* &negated_field_ids[0] */ + uintptr(negated_field_count)*2)) = field_id
						negated_field_count++
					}

					continue
				}

				// Parse a sibling anchor
				if (*Stream)(unsafe.Pointer(stream)).Next == '.' {
					child_is_immediate = uint8(True)
					stream_advance(tls, stream)
					stream_skip_whitespace(tls, stream)
				}

				var step_index Uint16_t = Uint16_t((*TSQuery)(unsafe.Pointer(self)).Steps.Size)
				var e TSQueryError = ts_query__parse_pattern(tls,
					self,
					stream,
					(depth + Uint32_t(1)),
					child_is_immediate)
				if (e == sPARENT_DONE) && ((*Stream)(unsafe.Pointer(stream)).Next == ')') {
					if child_is_immediate != 0 {
						if int32(last_child_step_index) == 0 {
							return TSQueryErrorSyntax
						}
						libc.SetBitFieldPtr8Uint8((*TSQuery)(unsafe.Pointer(self)).Steps.Contents+uintptr(last_child_step_index)*20+18 /* &.is_last_child */, uint8(True), 2, 0x4)
					}

					if negated_field_count != 0 {
						ts_query__add_negated_fields(tls,
							self,
							uint16(starting_step_index),
							bp+16, /* &negated_field_ids[0] */
							negated_field_count)
					}

					stream_advance(tls, stream)
					break
				} else if e != 0 {
					return e
				}

				last_child_step_index = step_index
				child_is_immediate = uint8(False)
			}
		}
	} else if ((*Stream)(unsafe.Pointer(stream)).Next == '_') || ((*Stream)(unsafe.Pointer(stream)).Next == '*') {
		stream_advance(tls, stream)
		stream_skip_whitespace(tls, stream)

		// Add a step that matches any kind of node
		array__grow(tls, (self + 64 /* &.steps */), uint64(1), uint64(unsafe.Sizeof(QueryStep{})))
		*(*QueryStep)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20)) = query_step__new(tls, sWILDCARD_SYMBOL, uint16(depth), is_immediate)
	} else if (*Stream)(unsafe.Pointer(stream)).Next == '"' {
		var string_start uintptr = (*Stream)(unsafe.Pointer(stream)).Input
		var e TSQueryError = ts_query__parse_string_literal(tls, self, stream)
		if e != 0 {
			return e
		}

		// Add a step for the node
		var symbol TSSymbol = Xts_language_symbol_for_name(tls,
			(*TSQuery)(unsafe.Pointer(self)).Language,
			(*TSQuery)(unsafe.Pointer(self)).String_buffer.Contents,
			(*TSQuery)(unsafe.Pointer(self)).String_buffer.Size,
			uint8(False))
		if !(symbol != 0) {
			stream_reset(tls, stream, (string_start + uintptr(1)))
			return TSQueryErrorNodeType
		}
		array__grow(tls, (self + 64 /* &.steps */), uint64(1), uint64(unsafe.Sizeof(QueryStep{})))
		*(*QueryStep)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20)) = query_step__new(tls, symbol, uint16(depth), is_immediate)
	} else if stream_is_ident_start(tls, stream) != 0 {
		// Parse the field name
		var field_name uintptr = (*Stream)(unsafe.Pointer(stream)).Input
		stream_scan_identifier(tls, stream)
		var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(field_name)) / 1))
		stream_skip_whitespace(tls, stream)

		if (*Stream)(unsafe.Pointer(stream)).Next != ':' {
			stream_reset(tls, stream, field_name)
			return TSQueryErrorSyntax
		}
		stream_advance(tls, stream)
		stream_skip_whitespace(tls, stream)

		// Parse the pattern
		var e TSQueryError = ts_query__parse_pattern(tls,
			self,
			stream,
			depth,
			is_immediate)
		if e == sPARENT_DONE {
			return TSQueryErrorSyntax
		}
		if e != 0 {
			return e
		}

		// Add the field name to the first step of the pattern
		var field_id TSFieldId = Xts_language_field_id_for_name(tls,
			(*TSQuery)(unsafe.Pointer(self)).Language,
			field_name,
			length)
		if !(field_id != 0) {
			(*Stream)(unsafe.Pointer(stream)).Input = field_name
			return TSQueryErrorField
		}

		var step_index Uint32_t = starting_step_index
		var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20)
		for {
			(*QueryStep)(unsafe.Pointer(step)).Field = field_id
			if ((int32((*QueryStep)(unsafe.Pointer(step)).Alternative_index) != int32(sNONE)) && (Uint32_t((*QueryStep)(unsafe.Pointer(step)).Alternative_index) > step_index)) && (Uint32_t((*QueryStep)(unsafe.Pointer(step)).Alternative_index) < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
				step_index = Uint32_t((*QueryStep)(unsafe.Pointer(step)).Alternative_index)
				step = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20)
			} else {
				break
			}
		}
	} else {
		return TSQueryErrorSyntax
	}

	stream_skip_whitespace(tls, stream)

	// Parse suffixes modifiers for this pattern
	for {
		// Parse the one-or-more operator.
		if (*Stream)(unsafe.Pointer(stream)).Next == '+' {
			stream_advance(tls, stream)
			stream_skip_whitespace(tls, stream)

			*(*QueryStep)(unsafe.Pointer(bp + 32 /* repeat_step */)) = query_step__new(tls, sWILDCARD_SYMBOL, uint16(depth), uint8(False))
			(*QueryStep)(unsafe.Pointer(bp + 32 /* &repeat_step */)).Alternative_index = Uint16_t(starting_step_index)
			libc.SetBitFieldPtr8Uint8(bp+32 /* &repeat_step */ +18 /* &.is_pass_through */, uint8(True), 3, 0x8)
			libc.SetBitFieldPtr8Uint8(bp+32 /* &repeat_step */ +18 /* &.alternative_is_immediate */, uint8(True), 5, 0x20)
			array__grow(tls, (self + 64 /* &.steps */), uint64(1), uint64(unsafe.Sizeof(QueryStep{})))
			*(*QueryStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20)) = *(*QueryStep)(unsafe.Pointer(bp + 32 /* repeat_step */))
		} else if (*Stream)(unsafe.Pointer(stream)).Next == '*' {
			stream_advance(tls, stream)
			stream_skip_whitespace(tls, stream)

			*(*QueryStep)(unsafe.Pointer(bp + 52 /* repeat_step */)) = query_step__new(tls, sWILDCARD_SYMBOL, uint16(depth), uint8(False))
			(*QueryStep)(unsafe.Pointer(bp + 52 /* &repeat_step */)).Alternative_index = Uint16_t(starting_step_index)
			libc.SetBitFieldPtr8Uint8(bp+52 /* &repeat_step */ +18 /* &.is_pass_through */, uint8(True), 3, 0x8)
			libc.SetBitFieldPtr8Uint8(bp+52 /* &repeat_step */ +18 /* &.alternative_is_immediate */, uint8(True), 5, 0x20)
			array__grow(tls, (self + 64 /* &.steps */), uint64(1), uint64(unsafe.Sizeof(QueryStep{})))
			*(*QueryStep)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20)) = *(*QueryStep)(unsafe.Pointer(bp + 52 /* repeat_step */))

			var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(starting_step_index)*20)
			for int32((*QueryStep)(unsafe.Pointer(step)).Alternative_index) != int32(sNONE) {
				step = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*QueryStep)(unsafe.Pointer(step)).Alternative_index)*20)
			}
			(*QueryStep)(unsafe.Pointer(step)).Alternative_index = Uint16_t((*TSQuery)(unsafe.Pointer(self)).Steps.Size)
		} else if (*Stream)(unsafe.Pointer(stream)).Next == '?' {
			stream_advance(tls, stream)
			stream_skip_whitespace(tls, stream)

			var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(starting_step_index)*20)
			for int32((*QueryStep)(unsafe.Pointer(step)).Alternative_index) != int32(sNONE) {
				step = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((*QueryStep)(unsafe.Pointer(step)).Alternative_index)*20)
			}
			(*QueryStep)(unsafe.Pointer(step)).Alternative_index = Uint16_t((*TSQuery)(unsafe.Pointer(self)).Steps.Size)
		} else if (*Stream)(unsafe.Pointer(stream)).Next == '@' {
			stream_advance(tls, stream)
			if !(stream_is_ident_start(tls, stream) != 0) {
				return TSQueryErrorSyntax
			}
			var capture_name uintptr = (*Stream)(unsafe.Pointer(stream)).Input
			stream_scan_identifier(tls, stream)
			var length Uint32_t = (Uint32_t((int64((*Stream)(unsafe.Pointer(stream)).Input) - int64(capture_name)) / 1))
			stream_skip_whitespace(tls, stream)

			// Add the capture id to the first step of the pattern
			var capture_id Uint16_t = symbol_table_insert_name(tls,
				(self /* &.captures */),
				capture_name,
				length)

			var step_index Uint32_t = starting_step_index
			for {
				var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20)
				query_step__add_capture(tls, step, capture_id)
				if ((int32((*QueryStep)(unsafe.Pointer(step)).Alternative_index) != int32(sNONE)) && (Uint32_t((*QueryStep)(unsafe.Pointer(step)).Alternative_index) > step_index)) && (Uint32_t((*QueryStep)(unsafe.Pointer(step)).Alternative_index) < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
					step_index = Uint32_t((*QueryStep)(unsafe.Pointer(step)).Alternative_index)
					step = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20)
				} else {
					break
				}
			}
		} else {
			break
		}
	}

	return TSQueryError(0)
}

var __func__78 = *(*[24]int8)(unsafe.Pointer(ts + 2845 /* "ts_query__parse_..." */)) /* query.c:1625:3 */

func Xts_query_new(tls *libc.TLS, language uintptr, source uintptr, source_len Uint32_t, error_offset uintptr, error_type uintptr) uintptr { /* query.c:2065:9: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var self uintptr = ts_malloc_default(tls, uint64(unsafe.Sizeof(TSQuery{})))
	*(*TSQuery)(unsafe.Pointer(self)) = TSQuery{Captures: symbol_table_new(tls), Predicate_values: symbol_table_new(tls), Language: language}

	array__grow(tls, (self + 144 /* &.negated_fields */), uint64(1), uint64(unsafe.Sizeof(TSFieldId(0))))
	*(*TSFieldId)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 144 /* &.negated_fields */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self+144 /* &.negated_fields */))).Size, 1))*2)) = TSFieldId(0)

	// Parse all of the S-expressions in the given string.
	*(*Stream)(unsafe.Pointer(bp /* stream */)) = stream_new(tls, source, source_len)
	stream_skip_whitespace(tls, bp /* &stream */)
	for (*Stream)(unsafe.Pointer(bp /* &stream */)).Input < (*Stream)(unsafe.Pointer(bp /* &stream */)).End {
		var pattern_index Uint32_t = (*TSQuery)(unsafe.Pointer(self)).Patterns.Size
		var start_step_index Uint32_t = (*TSQuery)(unsafe.Pointer(self)).Steps.Size
		var start_predicate_step_index Uint32_t = (*TSQuery)(unsafe.Pointer(self)).Predicate_steps.Size
		array__grow(tls, (self + 112 /* &.patterns */), uint64(1), uint64(unsafe.Sizeof(QueryPattern{})))
		*(*QueryPattern)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 112 /* &.patterns */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+112 /* &.patterns */))).Size, 1))*20)) = QueryPattern{Steps: Slice{Offset: start_step_index}, Predicate_steps: Slice{Offset: start_predicate_step_index}, Start_byte: stream_offset(tls, bp /* &stream */)}
		*(*TSQueryError)(unsafe.Pointer(error_type)) = ts_query__parse_pattern(tls, self, bp /* &stream */, uint32(0), uint8(False))
		array__grow(tls, (self + 64 /* &.steps */), uint64(1), uint64(unsafe.Sizeof(QueryStep{})))
		*(*QueryStep)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 64 /* &.steps */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+64 /* &.steps */))).Size, 1))*20)) = query_step__new(tls, uint16(0), sPATTERN_DONE_MARKER, uint8(False))

		var pattern uintptr = func() uintptr {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+112 /* &.patterns */))).Size-Uint32_t(1)) < (*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+112 /* &.patterns */))).Size)), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__79)), ts+2293 /* "upstream/tree-si..." */, 2104, ts+2869 /* "(uint32_t)(&self..." */)
			} else {
			}
			return ((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 112 /* &.patterns */))).Contents + uintptr(((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+112 /* &.patterns */))).Size-Uint32_t(1)))*20)
		}()
		(*QueryPattern)(unsafe.Pointer(pattern)).Steps.Length = ((*TSQuery)(unsafe.Pointer(self)).Steps.Size - start_step_index)
		(*QueryPattern)(unsafe.Pointer(pattern)).Predicate_steps.Length = ((*TSQuery)(unsafe.Pointer(self)).Predicate_steps.Size - start_predicate_step_index)

		// If any pattern could not be parsed, then report the error information
		// and terminate.
		if *(*TSQueryError)(unsafe.Pointer(error_type)) != 0 {
			if *(*TSQueryError)(unsafe.Pointer(error_type)) == sPARENT_DONE {
				*(*TSQueryError)(unsafe.Pointer(error_type)) = TSQueryErrorSyntax
			}
			*(*Uint32_t)(unsafe.Pointer(error_offset)) = stream_offset(tls, bp /* &stream */)
			Xts_query_delete(tls, self)
			return uintptr(0)
		}

		// Maintain a map that can look up patterns for a given root symbol.
		var wildcard_root_alternative_index Uint16_t = sNONE
		for {
			var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(start_step_index)*20)

			// If a pattern has a wildcard at its root, but it has a non-wildcard child,
			// then optimize the matching process by skipping matching the wildcard.
			// Later, during the matching process, the query cursor will check that
			// there is a parent node, and capture it if necessary.
			if (int32((*QueryStep)(unsafe.Pointer(step)).Symbol) == int32(sWILDCARD_SYMBOL)) && (int32((*QueryStep)(unsafe.Pointer(step)).Depth) == 0) {
				var second_step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr((start_step_index+Uint32_t(1)))*20)
				if (int32((*QueryStep)(unsafe.Pointer(second_step)).Symbol) != int32(sWILDCARD_SYMBOL)) && (int32((*QueryStep)(unsafe.Pointer(second_step)).Depth) == 1) {
					wildcard_root_alternative_index = (*QueryStep)(unsafe.Pointer(step)).Alternative_index
					start_step_index = start_step_index + (Uint32_t(1))
					step = second_step
				}
			}

			// Determine whether the pattern has a single root node. This affects
			// decisions about whether or not to start matching the pattern when
			// a query cursor has a range restriction.
			var is_rooted uint8 = uint8(True)
			var start_depth Uint32_t = Uint32_t((*QueryStep)(unsafe.Pointer(step)).Depth)
			{
				var step_index Uint32_t = (start_step_index + Uint32_t(1))
			__1:
				if !(step_index < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
					goto __3
				}
				{
					var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20)
					if Uint32_t((*QueryStep)(unsafe.Pointer(step)).Depth) == start_depth {
						is_rooted = uint8(False)
						goto __3
					}

				}
				goto __2
			__2:
				step_index++
				goto __1
				goto __3
			__3:
				;
			}

			ts_query__pattern_map_insert(tls, self, (*QueryStep)(unsafe.Pointer(step)).Symbol, PatternEntry{Step_index: Uint16_t(start_step_index), Pattern_index: Uint16_t(pattern_index), Is_rooted: is_rooted})
			if int32((*QueryStep)(unsafe.Pointer(step)).Symbol) == int32(sWILDCARD_SYMBOL) {
				(*TSQuery)(unsafe.Pointer(self)).Wildcard_root_pattern_count++
			}

			// If there are alternatives or options at the root of the pattern,
			// then add multiple entries to the pattern map.
			if int32((*QueryStep)(unsafe.Pointer(step)).Alternative_index) != int32(sNONE) {
				start_step_index = Uint32_t((*QueryStep)(unsafe.Pointer(step)).Alternative_index)
				(*QueryStep)(unsafe.Pointer(step)).Alternative_index = sNONE
			} else if int32(wildcard_root_alternative_index) != int32(sNONE) {
				start_step_index = Uint32_t(wildcard_root_alternative_index)
				wildcard_root_alternative_index = sNONE
			} else {
				break
			}
		}
	}

	if !(ts_query__analyze_patterns(tls, self, error_offset) != 0) {
		*(*TSQueryError)(unsafe.Pointer(error_type)) = TSQueryErrorStructure
		Xts_query_delete(tls, self)
		return uintptr(0)
	}

	ts_query__finalize_steps(tls, self)
	array__delete(tls, (self + 160 /* &.string_buffer */))
	return self
}

var __func__79 = *(*[13]int8)(unsafe.Pointer(ts + 2933 /* "ts_query_new" */)) /* query.c:2071:3 */

func Xts_query_delete(tls *libc.TLS, self uintptr) { /* query.c:2182:6: */
	if self != 0 {
		array__delete(tls, (self + 64 /* &.steps */))
		array__delete(tls, (self + 80 /* &.pattern_map */))
		array__delete(tls, (self + 96 /* &.predicate_steps */))
		array__delete(tls, (self + 112 /* &.patterns */))
		array__delete(tls, (self + 128 /* &.step_offsets */))
		array__delete(tls, (self + 160 /* &.string_buffer */))
		array__delete(tls, (self + 144 /* &.negated_fields */))
		symbol_table_delete(tls, (self /* &.captures */))
		symbol_table_delete(tls, (self + 32 /* &.predicate_values */))
		ts_free_default(tls, self)
	}
}

func Xts_query_pattern_count(tls *libc.TLS, self uintptr) Uint32_t { /* query.c:2197:10: */
	return (*TSQuery)(unsafe.Pointer(self)).Patterns.Size
}

func Xts_query_capture_count(tls *libc.TLS, self uintptr) Uint32_t { /* query.c:2201:10: */
	return (*TSQuery)(unsafe.Pointer(self)).Captures.Slices.Size
}

func Xts_query_string_count(tls *libc.TLS, self uintptr) Uint32_t { /* query.c:2205:10: */
	return (*TSQuery)(unsafe.Pointer(self)).Predicate_values.Slices.Size
}

func Xts_query_capture_name_for_id(tls *libc.TLS, self uintptr, index Uint32_t, length uintptr) uintptr { /* query.c:2209:12: */
	return symbol_table_name_for_id(tls, (self /* &.captures */), uint16(index), length)
}

func Xts_query_string_value_for_id(tls *libc.TLS, self uintptr, index Uint32_t, length uintptr) uintptr { /* query.c:2217:12: */
	return symbol_table_name_for_id(tls, (self + 32 /* &.predicate_values */), uint16(index), length)
}

func Xts_query_predicates_for_pattern(tls *libc.TLS, self uintptr, pattern_index Uint32_t, step_count uintptr) uintptr { /* query.c:2225:28: */
	var slice = (*QueryPattern)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Patterns.Contents + uintptr(pattern_index)*20)).Predicate_steps
	*(*Uint32_t)(unsafe.Pointer(step_count)) = slice.Length
	if (*TSQuery)(unsafe.Pointer(self)).Predicate_steps.Contents == (uintptr(0)) {
		return uintptr(0)
	}
	return ((*TSQuery)(unsafe.Pointer(self)).Predicate_steps.Contents + uintptr(slice.Offset)*8)
}

func Xts_query_start_byte_for_pattern(tls *libc.TLS, self uintptr, pattern_index Uint32_t) Uint32_t { /* query.c:2238:10: */
	return (*QueryPattern)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Patterns.Contents + uintptr(pattern_index)*20)).Start_byte
}

func Xts_query_step_is_definite(tls *libc.TLS, self uintptr, byte_offset Uint32_t) uint8 { /* query.c:2245:6: */
	var step_index Uint32_t = UINT32_MAX
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSQuery)(unsafe.Pointer(self)).Step_offsets.Size) {
			goto __3
		}
		{
			var step_offset uintptr = ((*TSQuery)(unsafe.Pointer(self)).Step_offsets.Contents + uintptr(i)*8)
			if (*StepOffset)(unsafe.Pointer(step_offset)).Byte_offset > byte_offset {
				goto __3
			}
			step_index = Uint32_t((*StepOffset)(unsafe.Pointer(step_offset)).Step_index)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	if step_index < (*TSQuery)(unsafe.Pointer(self)).Steps.Size {
		return (uint8(int32(*(*uint8)(unsafe.Pointer((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(step_index)*20 + 18 /* &.is_definite */)) & 0x40 >> 6)))
	} else {
		return uint8(False)
	}
	return uint8(0)
}

func Xts_query_disable_capture(tls *libc.TLS, self uintptr, name uintptr, length Uint32_t) { /* query.c:2262:6: */
	// Remove capture information for any pattern step that previously
	// captured with the given name.
	var id int32 = symbol_table_id_for_name(tls, (self /* &.captures */), name, length)
	if id != -1 {
		{
			var i uint32 = uint32(0)
		__1:
			if !(i < (*TSQuery)(unsafe.Pointer(self)).Steps.Size) {
				goto __3
			}
			{
				var step uintptr = ((*TSQuery)(unsafe.Pointer(self)).Steps.Contents + uintptr(i)*20)
				query_step__remove_capture(tls, step, uint16(id))

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
		ts_query__finalize_steps(tls, self)
	}
}

func Xts_query_disable_pattern(tls *libc.TLS, self uintptr, pattern_index Uint32_t) { /* query.c:2279:6: */
	// Remove the given pattern from the pattern map. Its steps will still
	// be in the `steps` array, but they will never be read.
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSQuery)(unsafe.Pointer(self)).Pattern_map.Size) {
			goto __3
		}
		{
			var pattern uintptr = ((*TSQuery)(unsafe.Pointer(self)).Pattern_map.Contents + uintptr(i)*6)
			if Uint32_t((*PatternEntry)(unsafe.Pointer(pattern)).Pattern_index) == pattern_index {
				array__erase(tls, (self + 80 /* &.pattern_map */), uint64(unsafe.Sizeof(PatternEntry{})), i)
				i--
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
}

// **************
//
// QueryCursor
//

func Xts_query_cursor_new(tls *libc.TLS) uintptr { /* query.c:2298:15: */
	var self uintptr = ts_malloc_default(tls, uint64(unsafe.Sizeof(TSQueryCursor{})))
	*(*TSQueryCursor)(unsafe.Pointer(self)) = TSQueryCursor{Capture_list_pool: capture_list_pool_new(tls), End_byte: UINT32_MAX, End_point: TSPoint{Row: UINT32_MAX, Column: UINT32_MAX}}
	array__reserve(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), uint32(8))
	array__reserve(tls, (self + 48 /* &.finished_states */), uint64(unsafe.Sizeof(QueryState{})), uint32(8))
	return self
}

func Xts_query_cursor_delete(tls *libc.TLS, self uintptr) { /* query.c:2317:6: */
	array__delete(tls, (self + 32 /* &.states */))
	array__delete(tls, (self + 48 /* &.finished_states */))
	Xts_tree_cursor_delete(tls, (self + 8 /* &.cursor */))
	capture_list_pool_delete(tls, (self + 64 /* &.capture_list_pool */))
	ts_free_default(tls, self)
}

func Xts_query_cursor_did_exceed_match_limit(tls *libc.TLS, self uintptr) uint8 { /* query.c:2325:6: */
	return (*TSQueryCursor)(unsafe.Pointer(self)).Did_exceed_match_limit
}

func Xts_query_cursor_match_limit(tls *libc.TLS, self uintptr) Uint32_t { /* query.c:2329:10: */
	return (*TSQueryCursor)(unsafe.Pointer(self)).Capture_list_pool.Max_capture_list_count
}

func Xts_query_cursor_set_match_limit(tls *libc.TLS, self uintptr, limit Uint32_t) { /* query.c:2333:6: */
	(*TSQueryCursor)(unsafe.Pointer(self)).Capture_list_pool.Max_capture_list_count = limit
}

func Xts_query_cursor_exec(tls *libc.TLS, self uintptr, query uintptr, node TSNode) { /* query.c:2337:6: */
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 32 /* &.states */))).Size = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 48 /* &.finished_states */))).Size = Uint32_t(0)
	Xts_tree_cursor_reset(tls, (self + 8 /* &.cursor */), node)
	capture_list_pool_reset(tls, (self + 64 /* &.capture_list_pool */))
	(*TSQueryCursor)(unsafe.Pointer(self)).Next_state_id = Uint32_t(0)
	(*TSQueryCursor)(unsafe.Pointer(self)).Depth = Uint32_t(0)
	(*TSQueryCursor)(unsafe.Pointer(self)).Ascending = uint8(False)
	(*TSQueryCursor)(unsafe.Pointer(self)).Halted = uint8(False)
	(*TSQueryCursor)(unsafe.Pointer(self)).Query = query
	(*TSQueryCursor)(unsafe.Pointer(self)).Did_exceed_match_limit = uint8(False)
}

func Xts_query_cursor_set_byte_range(tls *libc.TLS, self uintptr, start_byte Uint32_t, end_byte Uint32_t) { /* query.c:2354:6: */
	if end_byte == Uint32_t(0) {
		end_byte = UINT32_MAX
	}
	(*TSQueryCursor)(unsafe.Pointer(self)).Start_byte = start_byte
	(*TSQueryCursor)(unsafe.Pointer(self)).End_byte = end_byte
}

func Xts_query_cursor_set_point_range(tls *libc.TLS, self uintptr, start_point TSPoint, end_point TSPoint) { /* query.c:2366:6: */
	if (end_point.Row == Uint32_t(0)) && (end_point.Column == Uint32_t(0)) {
		end_point = TSPoint{Row: UINT32_MAX, Column: UINT32_MAX}
	}
	(*TSQueryCursor)(unsafe.Pointer(self)).Start_point = start_point
	(*TSQueryCursor)(unsafe.Pointer(self)).End_point = end_point
}

// Search through all of the in-progress states, and find the captured
// node that occurs earliest in the document.
func ts_query_cursor__first_in_progress_capture(tls *libc.TLS, self uintptr, state_index uintptr, byte_offset uintptr, pattern_index uintptr, is_definite uintptr) uint8 { /* query.c:2380:13: */
	var result uint8 = uint8(False)
	*(*Uint32_t)(unsafe.Pointer(state_index)) = UINT32_MAX
	*(*Uint32_t)(unsafe.Pointer(byte_offset)) = UINT32_MAX
	*(*Uint32_t)(unsafe.Pointer(pattern_index)) = UINT32_MAX
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSQueryCursor)(unsafe.Pointer(self)).States.Size) {
			goto __3
		}
		{
			var state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(i)*16)
			if (uint8(int32(*(*uint8)(unsafe.Pointer(state + 15 /* &.dead */)) & 0x40 >> 6))) != 0 {
				goto __2
			}

			var captures uintptr = capture_list_pool_get(tls,
				(self + 64 /* &.capture_list_pool */),
				uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
			if (Uint32_t(int32(*(*uint16)(unsafe.Pointer(state + 14 /* &.consumed_capture_count */)) & 0xfff >> 0))) >= (*CaptureList)(unsafe.Pointer(captures)).Size {
				goto __2
			}

			var node = (*TSQueryCapture)(unsafe.Pointer((*CaptureList)(unsafe.Pointer(captures)).Contents + uintptr((Uint16_t(int32(*(*uint16)(unsafe.Pointer(state + 14 /* &.consumed_capture_count */))&0xfff>>0))))*40)).Node
			if (Xts_node_end_byte(tls, node) <= (*TSQueryCursor)(unsafe.Pointer(self)).Start_byte) || (point_lte(tls, Xts_node_end_point(tls, node), (*TSQueryCursor)(unsafe.Pointer(self)).Start_point) != 0) {
				libc.PostIncBitFieldPtr16Uint16(state+14 /* &.consumed_capture_count */, 1, 16, 0, 0xfff)
				i--
				goto __2
			}

			var node_start_byte Uint32_t = Xts_node_start_byte(tls, node)
			if (!(result != 0) || (node_start_byte < *(*Uint32_t)(unsafe.Pointer(byte_offset)))) || ((node_start_byte == *(*Uint32_t)(unsafe.Pointer(byte_offset))) && (Uint32_t((*QueryState)(unsafe.Pointer(state)).Pattern_index) < *(*Uint32_t)(unsafe.Pointer(pattern_index)))) {
				var step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*QueryState)(unsafe.Pointer(state)).Step_index)*20)
				if is_definite != 0 {
					*(*uint8)(unsafe.Pointer(is_definite)) = (uint8(int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_definite */)) & 0x40 >> 6)))
				} else if (uint8(int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_definite */)) & 0x40 >> 6))) != 0 {
					goto __2
				}

				result = uint8(True)
				*(*Uint32_t)(unsafe.Pointer(state_index)) = i
				*(*Uint32_t)(unsafe.Pointer(byte_offset)) = node_start_byte
				*(*Uint32_t)(unsafe.Pointer(pattern_index)) = Uint32_t((*QueryState)(unsafe.Pointer(state)).Pattern_index)
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return result
}

// Determine which node is first in a depth-first traversal
func Xts_query_cursor__compare_nodes(tls *libc.TLS, left TSNode, right TSNode) int32 { /* query.c:2436:5: */
	if left.Id != right.Id {
		var left_start Uint32_t = Xts_node_start_byte(tls, left)
		var right_start Uint32_t = Xts_node_start_byte(tls, right)
		if left_start < right_start {
			return -1
		}
		if left_start > right_start {
			return 1
		}
		var left_node_count Uint32_t = Xts_node_end_byte(tls, left)
		var right_node_count Uint32_t = Xts_node_end_byte(tls, right)
		if left_node_count > right_node_count {
			return -1
		}
		if left_node_count < right_node_count {
			return 1
		}
	}
	return 0
}

// Determine if either state contains a superset of the other state's captures.
func Xts_query_cursor__compare_captures(tls *libc.TLS, self uintptr, left_state uintptr, right_state uintptr, left_contains_right uintptr, right_contains_left uintptr) { /* query.c:2451:6: */
	var left_captures uintptr = capture_list_pool_get(tls,
		(self + 64 /* &.capture_list_pool */),
		uint16((*QueryState)(unsafe.Pointer(left_state)).Capture_list_id))
	var right_captures uintptr = capture_list_pool_get(tls,
		(self + 64 /* &.capture_list_pool */),
		uint16((*QueryState)(unsafe.Pointer(right_state)).Capture_list_id))
	*(*uint8)(unsafe.Pointer(left_contains_right)) = uint8(True)
	*(*uint8)(unsafe.Pointer(right_contains_left)) = uint8(True)
	var i uint32 = uint32(0)
	var j uint32 = uint32(0)
	for {
		if i < (*CaptureList)(unsafe.Pointer(left_captures)).Size {
			if j < (*CaptureList)(unsafe.Pointer(right_captures)).Size {
				var left uintptr = ((*CaptureList)(unsafe.Pointer(left_captures)).Contents + uintptr(i)*40)
				var right uintptr = ((*CaptureList)(unsafe.Pointer(right_captures)).Contents + uintptr(j)*40)
				if ((*TSQueryCapture)(unsafe.Pointer(left)).Node.Id == (*TSQueryCapture)(unsafe.Pointer(right)).Node.Id) && ((*TSQueryCapture)(unsafe.Pointer(left)).Index == (*TSQueryCapture)(unsafe.Pointer(right)).Index) {
					i++
					j++
				} else {
					switch Xts_query_cursor__compare_nodes(tls, (*TSQueryCapture)(unsafe.Pointer(left)).Node, (*TSQueryCapture)(unsafe.Pointer(right)).Node) {
					case -1:
						*(*uint8)(unsafe.Pointer(right_contains_left)) = uint8(False)
						i++
						break
						fallthrough
					case 1:
						*(*uint8)(unsafe.Pointer(left_contains_right)) = uint8(False)
						j++
						break
						fallthrough
					default:
						*(*uint8)(unsafe.Pointer(right_contains_left)) = uint8(False)
						*(*uint8)(unsafe.Pointer(left_contains_right)) = uint8(False)
						i++
						j++
						break
					}
				}
			} else {
				*(*uint8)(unsafe.Pointer(right_contains_left)) = uint8(False)
				break
			}
		} else {
			if j < (*CaptureList)(unsafe.Pointer(right_captures)).Size {
				*(*uint8)(unsafe.Pointer(left_contains_right)) = uint8(False)
			}
			break
		}
	}
}

func ts_query_cursor__add_state(tls *libc.TLS, self uintptr, pattern uintptr) { /* query.c:2508:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*PatternEntry)(unsafe.Pointer(pattern)).Step_index)*20)
	var start_depth Uint32_t = ((*TSQueryCursor)(unsafe.Pointer(self)).Depth - Uint32_t((*QueryStep)(unsafe.Pointer(step)).Depth))

	// Keep the states array in ascending order of start_depth and pattern_index,
	// so that it can be processed more efficiently elsewhere. Usually, there is
	// no work to do here because of two facts:
	// * States with lower start_depth are naturally added first due to the
	//   order in which nodes are visited.
	// * Earlier patterns are naturally added first because of the ordering of the
	//   pattern_map data structure that's used to initiate matches.
	//
	// This loop is only needed in cases where two conditions hold:
	// * A pattern consists of more than one sibling node, so that its states
	//   remain in progress after exiting the node that started the match.
	// * The first node in the pattern matches against multiple nodes at the
	//   same depth.
	//
	// An example of this is the pattern '((comment)* (function))'. If multiple
	// `comment` nodes appear in a row, then we may initiate a new state for this
	// pattern while another state for the same pattern is already in progress.
	// If there are multiple patterns like this in a query, then this loop will
	// need to execute in order to keep the states ordered by pattern_index.
	var index Uint32_t = (*TSQueryCursor)(unsafe.Pointer(self)).States.Size
	for index > Uint32_t(0) {
		var prev_state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr((index-Uint32_t(1)))*16)
		if Uint32_t((*QueryState)(unsafe.Pointer(prev_state)).Start_depth) < start_depth {
			break
		}
		if Uint32_t((*QueryState)(unsafe.Pointer(prev_state)).Start_depth) == start_depth {
			if int32((*QueryState)(unsafe.Pointer(prev_state)).Pattern_index) < int32((*PatternEntry)(unsafe.Pointer(pattern)).Pattern_index) {
				break
			}
			if int32((*QueryState)(unsafe.Pointer(prev_state)).Pattern_index) == int32((*PatternEntry)(unsafe.Pointer(pattern)).Pattern_index) {
				// Avoid inserting an unnecessary duplicate state, which would be
				// immediately pruned by the longest-match criteria.
				if int32((*QueryState)(unsafe.Pointer(prev_state)).Step_index) == int32((*PatternEntry)(unsafe.Pointer(pattern)).Step_index) {
					return
				}
			}
		}
		index--
	}

	array__splice(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), index, uint32(0), uint32(1), func() uintptr {
		*(*QueryState)(unsafe.Pointer(bp)) = QueryState{Capture_list_id: Uint32_t(sNONE), Start_depth: Uint16_t(start_depth), Step_index: (*PatternEntry)(unsafe.Pointer(pattern)).Step_index, Pattern_index: (*PatternEntry)(unsafe.Pointer(pattern)).Pattern_index, Consumed_capture_count: uint16(True)&0x1<<12 | (uint16(libc.Bool32(int32((*QueryStep)(unsafe.Pointer(step)).Depth) == 1)))&0x1<<15}
		return bp
	}())
}

// Acquire a capture list for this state. If there are no capture lists left in the
// pool, this will steal the capture list from another existing state, and mark that
// other state as 'dead'.
func ts_query_cursor__prepare_to_capture(tls *libc.TLS, self uintptr, state uintptr, state_index_to_preserve uint32) uintptr { /* query.c:2570:20: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	if (*QueryState)(unsafe.Pointer(state)).Capture_list_id == Uint32_t(sNONE) {
		(*QueryState)(unsafe.Pointer(state)).Capture_list_id = Uint32_t(capture_list_pool_acquire(tls, (self + 64 /* &.capture_list_pool */)))

		// If there are no capture lists left in the pool, then terminate whichever
		// state has captured the earliest node in the document, and steal its
		// capture list.
		if (*QueryState)(unsafe.Pointer(state)).Capture_list_id == Uint32_t(sNONE) {
			(*TSQueryCursor)(unsafe.Pointer(self)).Did_exceed_match_limit = uint8(True)
			// var state_index Uint32_t at bp, 4

			// var byte_offset Uint32_t at bp+4, 4

			// var pattern_index Uint32_t at bp+8, 4

			if (ts_query_cursor__first_in_progress_capture(tls,
				self,
				bp,   /* &state_index */
				bp+4, /* &byte_offset */
				bp+8, /* &pattern_index */
				uintptr(0)) != 0) && (*(*Uint32_t)(unsafe.Pointer(bp /* state_index */)) != state_index_to_preserve) {

				var other_state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(*(*Uint32_t)(unsafe.Pointer(bp /* state_index */)))*16)
				(*QueryState)(unsafe.Pointer(state)).Capture_list_id = (*QueryState)(unsafe.Pointer(other_state)).Capture_list_id
				(*QueryState)(unsafe.Pointer(other_state)).Capture_list_id = Uint32_t(sNONE)
				libc.SetBitFieldPtr8Uint8(other_state+15 /* &.dead */, uint8(True), 6, 0x40)
				var list uintptr = capture_list_pool_get_mut(tls,
					(self + 64 /* &.capture_list_pool */),
					uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
				(*CaptureList)(unsafe.Pointer(list)).Size = Uint32_t(0)
				return list
			} else {

				return uintptr(0)
			}
		}
	}
	return capture_list_pool_get_mut(tls, (self + 64 /* &.capture_list_pool */), uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
}

func ts_query_cursor__capture(tls *libc.TLS, self uintptr, state uintptr, step uintptr, node TSNode) { /* query.c:2617:13: */
	if (uint8(int32(*(*uint8)(unsafe.Pointer(state + 15 /* &.dead */)) & 0x40 >> 6))) != 0 {
		return
	}
	var capture_list uintptr = ts_query_cursor__prepare_to_capture(tls, self, state, UINT32_MAX)
	if !(capture_list != 0) {
		libc.SetBitFieldPtr8Uint8(state+15 /* &.dead */, uint8(True), 6, 0x40)
		return
	}

	{
		var j uint32 = uint32(0)
	__1:
		if !(j < uint32(MAX_STEP_CAPTURE_COUNT)) {
			goto __3
		}
		{
			var capture_id Uint16_t = *(*Uint16_t)(unsafe.Pointer((step + 6 /* &.capture_ids */) + uintptr(j)*2))
			if int32(*(*Uint16_t)(unsafe.Pointer((step + 6 /* &.capture_ids */) + uintptr(j)*2))) == int32(sNONE) {
				goto __3
			}
			array__grow(tls, capture_list, uint64(1), uint64(unsafe.Sizeof(TSQueryCapture{})))
			*(*TSQueryCapture)(unsafe.Pointer((*CaptureList)(unsafe.Pointer((capture_list))).Contents + uintptr(libc.PostIncUint32(&(*CaptureList)(unsafe.Pointer(capture_list)).Size, 1))*40)) = TSQueryCapture{Node: node, Index: Uint32_t(capture_id)}

		}
		goto __2
	__2:
		j++
		goto __1
		goto __3
	__3:
		;
	}
}

// Duplicate the given state and insert the newly-created state immediately after
// the given state in the `states` array. Ensures that the given state reference is
// still valid, even if the states array is reallocated.
func ts_query_cursor__copy_state(tls *libc.TLS, self uintptr, state_ref uintptr) uintptr { /* query.c:2647:19: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var state uintptr = *(*uintptr)(unsafe.Pointer(state_ref))
	var state_index Uint32_t = (Uint32_t((int64(state) - int64((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents)) / 16))
	*(*QueryState)(unsafe.Pointer(bp /* copy */)) = *(*QueryState)(unsafe.Pointer(state))
	(*QueryState)(unsafe.Pointer(bp /* &copy */)).Capture_list_id = Uint32_t(sNONE)

	// If the state has captures, copy its capture list.
	if (*QueryState)(unsafe.Pointer(state)).Capture_list_id != Uint32_t(sNONE) {
		var new_captures uintptr = ts_query_cursor__prepare_to_capture(tls, self, bp /* &copy */, state_index)
		if !(new_captures != 0) {
			return uintptr(0)
		}
		var old_captures uintptr = capture_list_pool_get(tls,
			(self + 64 /* &.capture_list_pool */),
			uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
		array__splice(tls, new_captures, uint64(unsafe.Sizeof(TSQueryCapture{})), (*CaptureList)(unsafe.Pointer(new_captures)).Size, uint32(0), (*CaptureList)(unsafe.Pointer(old_captures)).Size, (*CaptureList)(unsafe.Pointer(old_captures)).Contents)
	}

	array__splice(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), (state_index + Uint32_t(1)), uint32(0), uint32(1), bp /* &copy */)
	*(*uintptr)(unsafe.Pointer(state_ref)) = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(state_index)*16)
	return ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr((state_index+Uint32_t(1)))*16)
}

// Walk the tree, processing patterns until at least one pattern finishes,
// If one or more patterns finish, return `true` and store their states in the
// `finished_states` array. Multiple patterns can finish on the same node. If
// there are no more matches, return `false`.
func ts_query_cursor__advance(tls *libc.TLS, self uintptr, stop_on_definite_step uint8) uint8 { /* query.c:2676:20: */
	bp := tls.Alloc(50)
	defer tls.Free(50)

	var did_match uint8 = uint8(False)
	for {
		if (*TSQueryCursor)(unsafe.Pointer(self)).Halted != 0 {
			for (*TSQueryCursor)(unsafe.Pointer(self)).States.Size > Uint32_t(0) {
				var state = *(*QueryState)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 32 /* &.states */))).Contents + uintptr(libc.PreDecUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+32 /* &.states */))).Size, 1))*16))
				capture_list_pool_release(tls,
					(self + 64 /* &.capture_list_pool */),
					uint16(state.Capture_list_id))
			}
		}

		if (did_match != 0) || ((*TSQueryCursor)(unsafe.Pointer(self)).Halted != 0) {
			return did_match
		}

		// Exit the current node.
		if (*TSQueryCursor)(unsafe.Pointer(self)).Ascending != 0 {

			// Leave this node by stepping to its next sibling or to its parent.
			if Xts_tree_cursor_goto_next_sibling(tls, (self+8 /* &.cursor */)) != 0 {
				(*TSQueryCursor)(unsafe.Pointer(self)).Ascending = uint8(False)
			} else if Xts_tree_cursor_goto_parent(tls, (self+8 /* &.cursor */)) != 0 {
				(*TSQueryCursor)(unsafe.Pointer(self)).Depth--
			} else {

				(*TSQueryCursor)(unsafe.Pointer(self)).Halted = uint8(True)
			}

			// After leaving a node, remove any states that cannot make further progress.
			var deleted_count Uint32_t = Uint32_t(0)
			{
				var i uint32 = uint32(0)
				var n uint32 = (*TSQueryCursor)(unsafe.Pointer(self)).States.Size
			__1:
				if !(i < n) {
					goto __3
				}
				{
					var state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(i)*16)
					var step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*QueryState)(unsafe.Pointer(state)).Step_index)*20)

					// If a state completed its pattern inside of this node, but was deferred from finishing
					// in order to search for longer matches, mark it as finished.
					if int32((*QueryStep)(unsafe.Pointer(step)).Depth) == int32(sPATTERN_DONE_MARKER) {
						if (Uint32_t((*QueryState)(unsafe.Pointer(state)).Start_depth) > (*TSQueryCursor)(unsafe.Pointer(self)).Depth) || ((*TSQueryCursor)(unsafe.Pointer(self)).Halted != 0) {

							(*QueryState)(unsafe.Pointer(state)).Id = libc.PostIncUint32(&(*TSQueryCursor)(unsafe.Pointer(self)).Next_state_id, 1)
							array__grow(tls, (self + 48 /* &.finished_states */), uint64(1), uint64(unsafe.Sizeof(QueryState{})))
							*(*QueryState)(unsafe.Pointer((*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((self + 48 /* &.finished_states */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((self+48 /* &.finished_states */))).Size, 1))*16)) = *(*QueryState)(unsafe.Pointer(state))
							did_match = uint8(True)
							deleted_count++
							goto __2
						}
					} else if (Uint32_t((*QueryState)(unsafe.Pointer(state)).Start_depth) + Uint32_t((*QueryStep)(unsafe.Pointer(step)).Depth)) > (*TSQueryCursor)(unsafe.Pointer(self)).Depth {

						capture_list_pool_release(tls,
							(self + 64 /* &.capture_list_pool */),
							uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
						deleted_count++
						goto __2
					}

					if deleted_count > Uint32_t(0) {
						*(*QueryState)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr((i-deleted_count))*16)) = *(*QueryState)(unsafe.Pointer(state))
					}

				}
				goto __2
			__2:
				i++
				goto __1
				goto __3
			__3:
				;
			}
			*(*Uint32_t)(unsafe.Pointer(self + 32 /* &.states */ + 8 /* &.size */)) -= (deleted_count)
		} else {
			// Get the properties of the current node.
			var node = Xts_tree_cursor_current_node(tls, (self + 8 /* &.cursor */))
			var parent_node = Xts_tree_cursor_parent_node(tls, (self + 8 /* &.cursor */))
			var symbol TSSymbol = Xts_node_symbol(tls, node)
			var is_named uint8 = Xts_node_is_named(tls, node)
			// var has_later_siblings uint8 at bp+2, 1

			// var has_later_named_siblings uint8 at bp+3, 1

			// var can_have_later_siblings_with_this_field uint8 at bp+4, 1

			*(*TSFieldId)(unsafe.Pointer(bp /* field_id */)) = TSFieldId(0)
			*(*[8]TSSymbol)(unsafe.Pointer(bp + 6 /* supertypes */)) = [8]TSSymbol{0: TSSymbol(0)}
			*(*uint32)(unsafe.Pointer(bp + 24 /* supertype_count */)) = uint32(8)
			Xts_tree_cursor_current_status(tls,
				(self + 8 /* &.cursor */),
				bp,   /* &field_id */
				bp+2, /* &has_later_siblings */
				bp+3, /* &has_later_named_siblings */
				bp+4, /* &can_have_later_siblings_with_this_field */
				bp+6, /* &supertypes[0] */
				bp+24 /* &supertype_count */)

			var node_intersects_range uint8 = (uint8(libc.Bool32((((Xts_node_end_byte(tls, node) > (*TSQueryCursor)(unsafe.Pointer(self)).Start_byte) && (Xts_node_start_byte(tls, node) < (*TSQueryCursor)(unsafe.Pointer(self)).End_byte)) && (point_gt(tls, Xts_node_end_point(tls, node), (*TSQueryCursor)(unsafe.Pointer(self)).Start_point) != 0)) && (point_lt(tls, Xts_node_start_point(tls, node), (*TSQueryCursor)(unsafe.Pointer(self)).End_point) != 0))))

			var parent_intersects_range uint8 = (uint8(libc.Bool32((Xts_node_is_null(tls, parent_node) != 0) || ((((Xts_node_end_byte(tls, parent_node) > (*TSQueryCursor)(unsafe.Pointer(self)).Start_byte) && (Xts_node_start_byte(tls, parent_node) < (*TSQueryCursor)(unsafe.Pointer(self)).End_byte)) && (point_gt(tls, Xts_node_end_point(tls, parent_node), (*TSQueryCursor)(unsafe.Pointer(self)).Start_point) != 0)) && (point_lt(tls, Xts_node_start_point(tls, parent_node), (*TSQueryCursor)(unsafe.Pointer(self)).End_point) != 0)))))

			// Add new states for any patterns whose root node is a wildcard.
			{
				var i uint32 = uint32(0)
			__4:
				if !(i < uint32((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Wildcard_root_pattern_count)) {
					goto __6
				}
				{
					var pattern uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Pattern_map.Contents + uintptr(i)*6)

					// If this node matches the first step of the pattern, then add a new
					// state at the start of this pattern.
					var step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*PatternEntry)(unsafe.Pointer(pattern)).Step_index)*20)
					if (((node_intersects_range != 0) || (!(int32((*PatternEntry)(unsafe.Pointer(pattern)).Is_rooted) != 0) && (parent_intersects_range != 0))) && (!(int32((*QueryStep)(unsafe.Pointer(step)).Field) != 0) || (int32(*(*TSFieldId)(unsafe.Pointer(bp /* field_id */))) == int32((*QueryStep)(unsafe.Pointer(step)).Field)))) && (!(int32((*QueryStep)(unsafe.Pointer(step)).Supertype_symbol) != 0) || (*(*uint32)(unsafe.Pointer(bp + 24 /* supertype_count */)) > uint32(0))) {
						ts_query_cursor__add_state(tls, self, pattern)
					}

				}
				goto __5
			__5:
				i++
				goto __4
				goto __6
			__6:
				;
			}

			// Add new states for any patterns whose root node matches this node.
			// var i1 uint32 at bp+28, 4

			if ts_query__pattern_map_search(tls, (*TSQueryCursor)(unsafe.Pointer(self)).Query, symbol, bp+28 /* &i1 */) != 0 {
				var pattern uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Pattern_map.Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 28 /* i1 */)))*6)

				var step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*PatternEntry)(unsafe.Pointer(pattern)).Step_index)*20)
				for ok := true; ok; ok = (int32((*QueryStep)(unsafe.Pointer(step)).Symbol) == int32(symbol)) {
					// If this node matches the first step of the pattern, then add a new
					// state at the start of this pattern.
					if ((node_intersects_range != 0) || (!(int32((*PatternEntry)(unsafe.Pointer(pattern)).Is_rooted) != 0) && (parent_intersects_range != 0))) && (!(int32((*QueryStep)(unsafe.Pointer(step)).Field) != 0) || (int32(*(*TSFieldId)(unsafe.Pointer(bp /* field_id */))) == int32((*QueryStep)(unsafe.Pointer(step)).Field))) {
						ts_query_cursor__add_state(tls, self, pattern)
					}

					// Advance to the next pattern whose root node matches this node.
					*(*uint32)(unsafe.Pointer(bp + 28 /* i1 */))++
					if *(*uint32)(unsafe.Pointer(bp + 28 /* i1 */)) == (*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Pattern_map.Size {
						break
					}
					pattern = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Pattern_map.Contents + uintptr(*(*uint32)(unsafe.Pointer(bp + 28 /* i1 */)))*6)
					step = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*PatternEntry)(unsafe.Pointer(pattern)).Step_index)*20)
				}
			}

			// Update all of the in-progress states with current node.
			{
				var i2 uint32 = uint32(0)
				var copy_count uint32 = uint32(0)
			__7:
				if !(i2 < (*TSQueryCursor)(unsafe.Pointer(self)).States.Size) {
					goto __9
				}
				{
					*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)) = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(i2)*16)
					var step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)))).Step_index)*20)
					libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */))+15 /* &.has_in_progress_alternatives */, uint8(False), 5, 0x20)
					copy_count = uint32(0)

					// Check that the node matches all of the criteria for the next
					// step of the pattern.
					if (Uint32_t((*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)))).Start_depth) + Uint32_t((*QueryStep)(unsafe.Pointer(step)).Depth)) != (*TSQueryCursor)(unsafe.Pointer(self)).Depth {
						goto __8
					}

					// Determine if this node matches this step of the pattern, and also
					// if this node can have later siblings that match this step of the
					// pattern.
					var node_does_match uint8 = (uint8(libc.Bool32(((int32((*QueryStep)(unsafe.Pointer(step)).Symbol) == int32(symbol)) || (int32((*QueryStep)(unsafe.Pointer(step)).Symbol) == int32(sWILDCARD_SYMBOL))) || ((int32((*QueryStep)(unsafe.Pointer(step)).Symbol) == int32(sNAMED_WILDCARD_SYMBOL)) && (is_named != 0)))))
					var later_sibling_can_match uint8 = *(*uint8)(unsafe.Pointer(bp + 2 /* has_later_siblings */))
					if (((uint8(int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_immediate */)) & 0x2 >> 1))) != 0) && (is_named != 0)) || ((uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)) + 15 /* &.seeking_immediate_match */)) & 0x10 >> 4))) != 0) {
						later_sibling_can_match = uint8(False)
					}
					if ((uint8(int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_last_child */)) & 0x4 >> 2))) != 0) && (*(*uint8)(unsafe.Pointer(bp + 3 /* has_later_named_siblings */)) != 0) {
						node_does_match = uint8(False)
					}
					if (*QueryStep)(unsafe.Pointer(step)).Supertype_symbol != 0 {
						var has_supertype uint8 = uint8(False)
						{
							var j uint32 = uint32(0)
						__10:
							if !(j < *(*uint32)(unsafe.Pointer(bp + 24 /* supertype_count */))) {
								goto __12
							}
							{
								if int32(*(*TSSymbol)(unsafe.Pointer(bp + 6 /* &supertypes[0] */ + uintptr(j)*2))) == int32((*QueryStep)(unsafe.Pointer(step)).Supertype_symbol) {
									has_supertype = uint8(True)
									goto __12
								}

							}
							goto __11
						__11:
							j++
							goto __10
							goto __12
						__12:
							;
						}
						if !(has_supertype != 0) {
							node_does_match = uint8(False)
						}
					}
					if (*QueryStep)(unsafe.Pointer(step)).Field != 0 {
						if int32((*QueryStep)(unsafe.Pointer(step)).Field) == int32(*(*TSFieldId)(unsafe.Pointer(bp /* field_id */))) {
							if !(*(*uint8)(unsafe.Pointer(bp + 4 /* can_have_later_siblings_with_this_field */)) != 0) {
								later_sibling_can_match = uint8(False)
							}
						} else {
							node_does_match = uint8(False)
						}
					}

					if (*QueryStep)(unsafe.Pointer(step)).Negated_field_list_id != 0 {
						var negated_field_ids uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Negated_fields.Contents + uintptr((*QueryStep)(unsafe.Pointer(step)).Negated_field_list_id)*2)
						for {
							var negated_field_id TSFieldId = *(*TSFieldId)(unsafe.Pointer(negated_field_ids))
							if negated_field_id != 0 {
								negated_field_ids += 2
								if Xts_node_child_by_field_id(tls, node, negated_field_id).Id != 0 {
									node_does_match = uint8(False)
									break
								}
							} else {
								break
							}
						}
					}

					// Remove states immediately if it is ever clear that they cannot match.
					if !(node_does_match != 0) {
						if !(later_sibling_can_match != 0) {

							capture_list_pool_release(tls,
								(self + 64 /* &.capture_list_pool */),
								uint16((*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)))).Capture_list_id))
							array__erase(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), i2)
							i2--
						}
						goto __8
					}

					// Some patterns can match their root node in multiple ways, capturing different
					// children. If this pattern step could match later children within the same
					// parent, then this query state cannot simply be updated in place. It must be
					// split into two states: one that matches this node, and one which skips over
					// this node, to preserve the possibility of matching later siblings.
					if (later_sibling_can_match != 0) && (((uint8(int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.contains_captures */)) & 0x1 >> 0))) != 0) || !((int32(*(*uint8)(unsafe.Pointer(step + 18 /* &.is_definite */)) & 0x40 >> 6)) != 0)) {
						if ts_query_cursor__copy_state(tls, self, bp+32 /* &state */) != 0 {

							copy_count++
						}
					}

					// If this pattern started with a wildcard, such that the pattern map
					// actually points to the *second* step of the pattern, then check
					// that the node has a parent, and capture the parent node if necessary.
					if (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)) + 15 /* &.needs_parent */)) & 0x80 >> 7))) != 0 {
						var parent = Xts_tree_cursor_parent_node(tls, (self + 8 /* &.cursor */))
						if Xts_node_is_null(tls, parent) != 0 {

							libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */))+15 /* &.dead */, uint8(True), 6, 0x40)
						} else {
							libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */))+15 /* &.needs_parent */, uint8(False), 7, 0x80)
							var skipped_wildcard_step uintptr = step
							for ok1 := true; ok1; ok1 = ((((uint8(int32(*(*uint8)(unsafe.Pointer(skipped_wildcard_step + 18 /* &.is_dead_end */)) & 0x10 >> 4))) != 0) || ((uint8(int32(*(*uint8)(unsafe.Pointer(skipped_wildcard_step + 18 /* &.is_pass_through */)) & 0x8 >> 3))) != 0)) || (int32((*QueryStep)(unsafe.Pointer(skipped_wildcard_step)).Depth) > 0)) {
								skipped_wildcard_step -= 20
							}
							if int32(*(*Uint16_t)(unsafe.Pointer((skipped_wildcard_step + 6 /* &.capture_ids */)))) != int32(sNONE) {

								ts_query_cursor__capture(tls,
									self,
									*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)),
									skipped_wildcard_step,
									parent)
							}
						}
					}

					// If the current node is captured in this pattern, add it to the capture list.
					if int32(*(*Uint16_t)(unsafe.Pointer((step + 6 /* &.capture_ids */)))) != int32(sNONE) {
						ts_query_cursor__capture(tls, self, *(*uintptr)(unsafe.Pointer(bp + 32 /* state */)), step, node)
					}

					if (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)) + 15 /* &.dead */)) & 0x40 >> 6))) != 0 {
						array__erase(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), i2)
						i2--
						goto __8
					}

					// Advance this state to the next step of its pattern.
					(*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)))).Step_index++
					libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */))+15 /* &.seeking_immediate_match */, uint8(False), 4, 0x10)

					var next_step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* state */)))).Step_index)*20)
					if (stop_on_definite_step != 0) && ((uint8(int32(*(*uint8)(unsafe.Pointer(next_step + 18 /* &.is_definite */)) & 0x40 >> 6))) != 0) {
						did_match = uint8(True)
					}

					// If this state's next step has an alternative step, then copy the state in order
					// to pursue both alternatives. The alternative step itself may have an alternative,
					// so this is an interative process.
					var end_index uint32 = (i2 + uint32(1))
					{
						var j uint32 = i2
					__13:
						if !(j < end_index) {
							goto __15
						}
						{
							*(*uintptr)(unsafe.Pointer(bp + 40 /* state */)) = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(j)*16)
							var next_step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* state */)))).Step_index)*20)
							if int32((*QueryStep)(unsafe.Pointer(next_step)).Alternative_index) != int32(sNONE) {
								// A "dead-end" step exists only to add a non-sequential jump into the step sequence,
								// via its alternative index. When a state reaches a dead-end step, it jumps straight
								// to the step's alternative.
								if (uint8(int32(*(*uint8)(unsafe.Pointer(next_step + 18 /* &.is_dead_end */)) & 0x10 >> 4))) != 0 {
									(*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* state */)))).Step_index = (*QueryStep)(unsafe.Pointer(next_step)).Alternative_index
									j--
									goto __14
								}

								// A "pass-through" step exists only to add a branch into the step sequence,
								// via its alternative_index. When a state reaches a pass-through step, it splits
								// in order to process the alternative step, and then it advances to the next step.
								if (uint8(int32(*(*uint8)(unsafe.Pointer(next_step + 18 /* &.is_pass_through */)) & 0x8 >> 3))) != 0 {
									(*QueryState)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* state */)))).Step_index++
									j--
								}

								var copy uintptr = ts_query_cursor__copy_state(tls, self, bp+40 /* &state */)
								if copy != 0 {

									end_index++
									copy_count++
									(*QueryState)(unsafe.Pointer(copy)).Step_index = (*QueryStep)(unsafe.Pointer(next_step)).Alternative_index
									if (uint8(int32(*(*uint8)(unsafe.Pointer(next_step + 18 /* &.alternative_is_immediate */)) & 0x20 >> 5))) != 0 {
										libc.SetBitFieldPtr8Uint8(copy+15 /* &.seeking_immediate_match */, uint8(True), 4, 0x10)
									}
								}
							}

						}
						goto __14
					__14:
						j++
						goto __13
						goto __15
					__15:
						;
					}

				}
				goto __8
			__8:
				i2 = i2 + (uint32(1) + copy_count)
				goto __7
				goto __9
			__9:
				;
			}

			{
				var i3 uint32 = uint32(0)
			__16:
				if !(i3 < (*TSQueryCursor)(unsafe.Pointer(self)).States.Size) {
					goto __18
				}
				{
					var state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(i3)*16)
					if (uint8(int32(*(*uint8)(unsafe.Pointer(state + 15 /* &.dead */)) & 0x40 >> 6))) != 0 {
						array__erase(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), i3)
						i3--
						goto __17
					}

					// Enfore the longest-match criteria. When a query pattern contains optional or
					// repeated nodes, this is necessary to avoid multiple redundant states, where
					// one state has a strict subset of another state's captures.
					var did_remove uint8 = uint8(False)
					{
						var j uint32 = (i3 + uint32(1))
					__19:
						if !(j < (*TSQueryCursor)(unsafe.Pointer(self)).States.Size) {
							goto __21
						}
						{
							var other_state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(j)*16)

							// Query states are kept in ascending order of start_depth and pattern_index.
							// Since the longest-match criteria is only used for deduping matches of the same
							// pattern and root node, we only need to perform pairwise comparisons within a
							// small slice of the states array.
							if (int32((*QueryState)(unsafe.Pointer(other_state)).Start_depth) != int32((*QueryState)(unsafe.Pointer(state)).Start_depth)) || (int32((*QueryState)(unsafe.Pointer(other_state)).Pattern_index) != int32((*QueryState)(unsafe.Pointer(state)).Pattern_index)) {
								goto __21
							}
							// var left_contains_right uint8 at bp+48, 1

							// var right_contains_left uint8 at bp+49, 1

							Xts_query_cursor__compare_captures(tls,
								self,
								state,
								other_state,
								bp+48, /* &left_contains_right */
								bp+49 /* &right_contains_left */)
							if *(*uint8)(unsafe.Pointer(bp + 48 /* left_contains_right */)) != 0 {
								if int32((*QueryState)(unsafe.Pointer(state)).Step_index) == int32((*QueryState)(unsafe.Pointer(other_state)).Step_index) {

									capture_list_pool_release(tls, (self + 64 /* &.capture_list_pool */), uint16((*QueryState)(unsafe.Pointer(other_state)).Capture_list_id))
									array__erase(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), j)
									j--
									goto __20
								}
								libc.SetBitFieldPtr8Uint8(other_state+15 /* &.has_in_progress_alternatives */, uint8(True), 5, 0x20)
							}
							if *(*uint8)(unsafe.Pointer(bp + 49 /* right_contains_left */)) != 0 {
								if int32((*QueryState)(unsafe.Pointer(state)).Step_index) == int32((*QueryState)(unsafe.Pointer(other_state)).Step_index) {

									capture_list_pool_release(tls, (self + 64 /* &.capture_list_pool */), uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
									array__erase(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), i3)
									i3--
									did_remove = uint8(True)
									goto __21
								}
								libc.SetBitFieldPtr8Uint8(state+15 /* &.has_in_progress_alternatives */, uint8(True), 5, 0x20)
							}

						}
						goto __20
					__20:
						j++
						goto __19
						goto __21
					__21:
						;
					}

					// If there the state is at the end of its pattern, remove it from the list
					// of in-progress states and add it to the list of finished states.
					if !(did_remove != 0) {

						var next_step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*QueryState)(unsafe.Pointer(state)).Step_index)*20)
						if int32((*QueryStep)(unsafe.Pointer(next_step)).Depth) == int32(sPATTERN_DONE_MARKER) {
							if (uint8(int32(*(*uint8)(unsafe.Pointer(state + 15 /* &.has_in_progress_alternatives */)) & 0x20 >> 5))) != 0 {

							} else {

								(*QueryState)(unsafe.Pointer(state)).Id = libc.PostIncUint32(&(*TSQueryCursor)(unsafe.Pointer(self)).Next_state_id, 1)
								array__grow(tls, (self + 48 /* &.finished_states */), uint64(1), uint64(unsafe.Sizeof(QueryState{})))
								*(*QueryState)(unsafe.Pointer((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self + 48 /* &.finished_states */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self+48 /* &.finished_states */))).Size, 1))*16)) = *(*QueryState)(unsafe.Pointer(state))
								array__erase(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), (uint32((int64(state) - int64((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents)) / 16)))
								did_match = uint8(True)
								i3--
							}
						}
					}

				}
				goto __17
			__17:
				i3++
				goto __16
				goto __18
			__18:
				;
			}

			// When the current node ends prior to the desired start offset,
			// only descend for the purpose of continuing in-progress matches.
			var should_descend uint8 = node_intersects_range
			if !(should_descend != 0) {
				{
					var i uint32 = uint32(0)
				__22:
					if !(i < (*TSQueryCursor)(unsafe.Pointer(self)).States.Size) {
						goto __24
					}
					{
						var state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(i)*16)

						var next_step uintptr = ((*TSQuery)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).Query)).Steps.Contents + uintptr((*QueryState)(unsafe.Pointer(state)).Step_index)*20)
						if (int32((*QueryStep)(unsafe.Pointer(next_step)).Depth) != int32(sPATTERN_DONE_MARKER)) && ((Uint32_t(int32((*QueryState)(unsafe.Pointer(state)).Start_depth) + int32((*QueryStep)(unsafe.Pointer(next_step)).Depth))) > (*TSQueryCursor)(unsafe.Pointer(self)).Depth) {
							should_descend = uint8(True)
							goto __24
						}

					}
					goto __23
				__23:
					i++
					goto __22
					goto __24
				__24:
					;
				}
			}

			if !(should_descend != 0) {

			}

			if (should_descend != 0) && (Xts_tree_cursor_goto_first_child(tls, (self+8 /* &.cursor */)) != 0) {
				(*TSQueryCursor)(unsafe.Pointer(self)).Depth++
			} else {
				(*TSQueryCursor)(unsafe.Pointer(self)).Ascending = uint8(True)
			}
		}
	}
	return uint8(0)
}

func Xts_query_cursor_next_match(tls *libc.TLS, self uintptr, match uintptr) uint8 { /* query.c:3152:6: */
	if (*TSQueryCursor)(unsafe.Pointer(self)).Finished_states.Size == Uint32_t(0) {
		if !(ts_query_cursor__advance(tls, self, uint8(False)) != 0) {
			return uint8(False)
		}
	}

	var state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).Finished_states.Contents)
	(*TSQueryMatch)(unsafe.Pointer(match)).Id = (*QueryState)(unsafe.Pointer(state)).Id
	(*TSQueryMatch)(unsafe.Pointer(match)).Pattern_index = (*QueryState)(unsafe.Pointer(state)).Pattern_index
	var captures uintptr = capture_list_pool_get(tls,
		(self + 64 /* &.capture_list_pool */),
		uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
	(*TSQueryMatch)(unsafe.Pointer(match)).Captures = (*CaptureList)(unsafe.Pointer(captures)).Contents
	(*TSQueryMatch)(unsafe.Pointer(match)).Capture_count = Uint16_t((*CaptureList)(unsafe.Pointer(captures)).Size)
	capture_list_pool_release(tls, (self + 64 /* &.capture_list_pool */), uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
	array__erase(tls, (self + 48 /* &.finished_states */), uint64(unsafe.Sizeof(QueryState{})), uint32(0))
	return uint8(True)
}

func Xts_query_cursor_remove_match(tls *libc.TLS, self uintptr, match_id Uint32_t) { /* query.c:3176:6: */
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSQueryCursor)(unsafe.Pointer(self)).Finished_states.Size) {
			goto __3
		}
		{
			var state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).Finished_states.Contents + uintptr(i)*16)
			if (*QueryState)(unsafe.Pointer(state)).Id == match_id {
				capture_list_pool_release(tls,
					(self + 64 /* &.capture_list_pool */),
					uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
				array__erase(tls, (self + 48 /* &.finished_states */), uint64(unsafe.Sizeof(QueryState{})), i)
				return
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
}

func Xts_query_cursor_next_capture(tls *libc.TLS, self uintptr, match uintptr, capture_index uintptr) uint8 { /* query.c:3193:6: */
	bp := tls.Alloc(13)
	defer tls.Free(13)

	// The goal here is to return captures in order, even though they may not
	// be discovered in order, because patterns can overlap. Search for matches
	// until there is a finished capture that is before any unfinished capture.
	for {
		// First, find the earliest capture in an unfinished match.
		// var first_unfinished_capture_byte Uint32_t at bp+4, 4

		// var first_unfinished_pattern_index Uint32_t at bp+8, 4

		// var first_unfinished_state_index Uint32_t at bp, 4

		*(*uint8)(unsafe.Pointer(bp + 12 /* first_unfinished_state_is_definite */)) = uint8(False)
		ts_query_cursor__first_in_progress_capture(tls,
			self,
			bp,   /* &first_unfinished_state_index */
			bp+4, /* &first_unfinished_capture_byte */
			bp+8, /* &first_unfinished_pattern_index */
			bp+12 /* &first_unfinished_state_is_definite */)

		// Then find the earliest capture in a finished match. It must occur
		// before the first capture in an *unfinished* match.
		var first_finished_state uintptr = uintptr(0)
		var first_finished_capture_byte Uint32_t = *(*Uint32_t)(unsafe.Pointer(bp + 4 /* first_unfinished_capture_byte */))
		var first_finished_pattern_index Uint32_t = *(*Uint32_t)(unsafe.Pointer(bp + 8 /* first_unfinished_pattern_index */))
		{
			var i uint32 = uint32(0)
		__1:
			if !(i < (*TSQueryCursor)(unsafe.Pointer(self)).Finished_states.Size) {
				goto __3
			}
			{
				var state uintptr = ((*TSQueryCursor)(unsafe.Pointer(self)).Finished_states.Contents + uintptr(i)*16)
				var captures uintptr = capture_list_pool_get(tls,
					(self + 64 /* &.capture_list_pool */),
					uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))

				// Remove states whose captures are all consumed.
				if (Uint32_t(int32(*(*uint16)(unsafe.Pointer(state + 14 /* &.consumed_capture_count */)) & 0xfff >> 0))) >= (*CaptureList)(unsafe.Pointer(captures)).Size {
					capture_list_pool_release(tls,
						(self + 64 /* &.capture_list_pool */),
						uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
					array__erase(tls, (self + 48 /* &.finished_states */), uint64(unsafe.Sizeof(QueryState{})), i)
					goto __2
				}

				// Skip captures that precede the cursor's start byte.
				var node = (*TSQueryCapture)(unsafe.Pointer((*CaptureList)(unsafe.Pointer(captures)).Contents + uintptr((Uint16_t(int32(*(*uint16)(unsafe.Pointer(state + 14 /* &.consumed_capture_count */))&0xfff>>0))))*40)).Node
				if Xts_node_end_byte(tls, node) <= (*TSQueryCursor)(unsafe.Pointer(self)).Start_byte {
					libc.PostIncBitFieldPtr16Uint16(state+14 /* &.consumed_capture_count */, 1, 16, 0, 0xfff)
					goto __2
				}

				var node_start_byte Uint32_t = Xts_node_start_byte(tls, node)
				if (node_start_byte < first_finished_capture_byte) || ((node_start_byte == first_finished_capture_byte) && (Uint32_t((*QueryState)(unsafe.Pointer(state)).Pattern_index) < first_finished_pattern_index)) {
					first_finished_state = state
					first_finished_capture_byte = node_start_byte
					first_finished_pattern_index = Uint32_t((*QueryState)(unsafe.Pointer(state)).Pattern_index)
				}
				i++

			}
			goto __2
		__2:
			;
			goto __1
			goto __3
		__3:
			;
		}

		// If there is finished capture that is clearly before any unfinished
		// capture, then return its match, and its capture index. Internally
		// record the fact that the capture has been 'consumed'.
		var state uintptr
		if first_finished_state != 0 {
			state = first_finished_state
		} else if *(*uint8)(unsafe.Pointer(bp + 12 /* first_unfinished_state_is_definite */)) != 0 {
			state = ((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents + uintptr(*(*Uint32_t)(unsafe.Pointer(bp /* first_unfinished_state_index */)))*16)
		} else {
			state = uintptr(0)
		}

		if state != 0 {
			(*TSQueryMatch)(unsafe.Pointer(match)).Id = (*QueryState)(unsafe.Pointer(state)).Id
			(*TSQueryMatch)(unsafe.Pointer(match)).Pattern_index = (*QueryState)(unsafe.Pointer(state)).Pattern_index
			var captures uintptr = capture_list_pool_get(tls,
				(self + 64 /* &.capture_list_pool */),
				uint16((*QueryState)(unsafe.Pointer(state)).Capture_list_id))
			(*TSQueryMatch)(unsafe.Pointer(match)).Captures = (*CaptureList)(unsafe.Pointer(captures)).Contents
			(*TSQueryMatch)(unsafe.Pointer(match)).Capture_count = Uint16_t((*CaptureList)(unsafe.Pointer(captures)).Size)
			*(*Uint32_t)(unsafe.Pointer(capture_index)) = (Uint32_t(int32(*(*uint16)(unsafe.Pointer(state + 14 /* &.consumed_capture_count */)) & 0xfff >> 0)))
			libc.PostIncBitFieldPtr16Uint16(state+14 /* &.consumed_capture_count */, 1, 16, 0, 0xfff)
			return uint8(True)
		}

		if capture_list_pool_is_empty(tls, (self+64 /* &.capture_list_pool */)) != 0 {

			capture_list_pool_release(tls,
				(self + 64 /* &.capture_list_pool */),
				uint16((*QueryState)(unsafe.Pointer((*TSQueryCursor)(unsafe.Pointer(self)).States.Contents+uintptr(*(*Uint32_t)(unsafe.Pointer(bp /* first_unfinished_state_index */)))*16)).Capture_list_id))
			array__erase(tls, (self + 32 /* &.states */), uint64(unsafe.Sizeof(QueryState{})), *(*Uint32_t)(unsafe.Pointer(bp /* first_unfinished_state_index */)))
		}

		// If there are no finished matches that are ready to be returned, then
		// continue finding more matches.
		if !(ts_query_cursor__advance(tls, self, uint8(True)) != 0) && ((*TSQueryCursor)(unsafe.Pointer(self)).Finished_states.Size == Uint32_t(0)) {
			return uint8(False)
		}
	}
	return uint8(0)
}

// 8462256: modified __assert_rtn() replaces deprecated __eprintf()

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

type SStackNode = struct {
	State              TSStateId
	__ccgo_pad1        [2]byte
	Position           Length
	Links              [8]StackLink
	Link_count         uint16
	__ccgo_pad2        [2]byte
	Ref_count          Uint32_t
	Error_cost         uint32
	Node_count         uint32
	Dynamic_precedence int32
	__ccgo_pad3        [4]byte
} /* api.h:39:9 */

// 8462256: modified __assert_rtn() replaces deprecated __eprintf()

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

type StackNode = SStackNode /* stack.c:20:26 */

type StackLink = struct {
	Node        uintptr
	Subtree     Subtree
	Is_pending  uint8
	__ccgo_pad1 [7]byte
} /* stack.c:26:3 */

type StackIterator = struct {
	Node          uintptr
	Subtrees      SubtreeArray
	Subtree_count Uint32_t
	Is_pending    uint8
	__ccgo_pad1   [3]byte
} /* stack.c:44:3 */

type StackIterateSession = struct {
	Payload  uintptr
	Callback StackIterateCallback
} /* stack.c:49:3 */

type StackNodeArray = struct {
	Contents uintptr
	Size     Uint32_t
	Capacity Uint32_t
} /* stack.c:51:28 */

type StackStatus = uint32 /* stack.c:57:3 */

type StackHead = struct {
	Node                     uintptr
	Last_external_token      Subtree
	Summary                  uintptr
	Node_count_at_last_error uint32
	Lookahead_when_paused    TSSymbol
	__ccgo_pad1              [2]byte
	Status                   StackStatus
	__ccgo_pad2              [4]byte
} /* stack.c:66:3 */

type StackAction = uint32 /* stack.c:77:18 */

type StackCallback = uintptr /* stack.c:84:21 */

func stack_node_retain(tls *libc.TLS, self uintptr) { /* stack.c:86:13: */
	if !(self != 0) {
		return
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((*StackNode)(unsafe.Pointer(self)).Ref_count > Uint32_t(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__82)), ts+2946 /* "upstream/tree-si..." */, 89, ts+2983 /* "self->ref_count ..." */)
	} else {
	}
	(*StackNode)(unsafe.Pointer(self)).Ref_count++
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((*StackNode)(unsafe.Pointer(self)).Ref_count != Uint32_t(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__82)), ts+2946 /* "upstream/tree-si..." */, 91, ts+3003 /* "self->ref_count ..." */)
	} else {
	}
}

var __func__82 = *(*[18]int8)(unsafe.Pointer(ts + 3024 /* "stack_node_retai..." */)) /* stack.c:86:48 */

func stack_node_release(tls *libc.TLS, self uintptr, pool uintptr, subtree_pool uintptr) { /* stack.c:94:13: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var first_predecessor uintptr
	// var link StackLink at bp, 32

	var i uint32
	// var link1 StackLink at bp+32, 32

recur:
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((*StackNode)(unsafe.Pointer(self)).Ref_count != Uint32_t(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__83)), ts+2946 /* "upstream/tree-si..." */, 96, ts+3003 /* "self->ref_count ..." */)
	} else {
	}
	(*StackNode)(unsafe.Pointer(self)).Ref_count--
	if !((*StackNode)(unsafe.Pointer(self)).Ref_count > Uint32_t(0)) {
		goto __1
	}
	return
__1:
	;
	first_predecessor = uintptr(0)
	if !(int32((*StackNode)(unsafe.Pointer(self)).Link_count) > 0) {
		goto __2
	}
	{
		i = (uint32(int32((*StackNode)(unsafe.Pointer(self)).Link_count) - 1))
	__3:
		if !(i > uint32(0)) {
			goto __5
		}
		*(*StackLink)(unsafe.Pointer(bp /* link */)) = *(*StackLink)(unsafe.Pointer((self + 16 /* &.links */) + uintptr(i)*32))
		if !(*(*uintptr)(unsafe.Pointer(bp /* &link */ + 8 /* &.subtree */)) != 0) {
			goto __6
		}
		Xts_subtree_release(tls, subtree_pool, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree)
	__6:
		;
		stack_node_release(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Node, pool, subtree_pool)
		goto __4
	__4:
		i--
		goto __3
		goto __5
	__5:
		;
	}
	*(*StackLink)(unsafe.Pointer(bp + 32 /* link1 */)) = *(*StackLink)(unsafe.Pointer((self + 16 /* &.links */)))
	if !(*(*uintptr)(unsafe.Pointer(bp + 32 /* &link1 */ + 8 /* &.subtree */)) != 0) {
		goto __7
	}
	Xts_subtree_release(tls, subtree_pool, (*StackLink)(unsafe.Pointer(bp+32 /* &link1 */)).Subtree)
__7:
	;
	first_predecessor = (*StackLink)(unsafe.Pointer((self + 16 /* &.links */))).Node
__2:
	;

	if !((*StackNodeArray)(unsafe.Pointer(pool)).Size < Uint32_t(MAX_NODE_POOL_SIZE)) {
		goto __8
	}
	array__grow(tls, pool, uint64(1), uint64(unsafe.Sizeof(uintptr(0))))
	*(*uintptr)(unsafe.Pointer((*StackNodeArray)(unsafe.Pointer((pool))).Contents + uintptr(libc.PostIncUint32(&(*StackNodeArray)(unsafe.Pointer(pool)).Size, 1))*8)) = self
	goto __9
__8:
	ts_free_default(tls, self)
__9:
	;

	if !(first_predecessor != 0) {
		goto __10
	}
	self = first_predecessor
	goto recur
__10:
	;
}

var __func__83 = *(*[19]int8)(unsafe.Pointer(ts + 3042 /* "stack_node_relea..." */)) /* stack.c:94:98 */

func stack_node_new(tls *libc.TLS, previous_node uintptr, subtree Subtree, is_pending uint8, state TSStateId, pool uintptr) uintptr { /* stack.c:124:18: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = subtree

	var node uintptr
	if (*StackNodeArray)(unsafe.Pointer(pool)).Size > Uint32_t(0) {
		node = *(*uintptr)(unsafe.Pointer((*StackNodeArray)(unsafe.Pointer((pool))).Contents + uintptr(libc.PreDecUint32(&(*StackNodeArray)(unsafe.Pointer(pool)).Size, 1))*8))
	} else {
		node = ts_malloc_default(tls, uint64(unsafe.Sizeof(StackNode{})))
	}
	*(*StackNode)(unsafe.Pointer(node)) = StackNode{State: state, Ref_count: Uint32_t(1)}

	if previous_node != 0 {
		(*StackNode)(unsafe.Pointer(node)).Link_count = uint16(1)
		*(*StackLink)(unsafe.Pointer((node + 16 /* &.links */))) = StackLink{Node: previous_node, Subtree: *(*Subtree)(unsafe.Pointer(bp /* subtree */)), Is_pending: is_pending}

		(*StackNode)(unsafe.Pointer(node)).Position = (*StackNode)(unsafe.Pointer(previous_node)).Position
		(*StackNode)(unsafe.Pointer(node)).Error_cost = (*StackNode)(unsafe.Pointer(previous_node)).Error_cost
		(*StackNode)(unsafe.Pointer(node)).Dynamic_precedence = (*StackNode)(unsafe.Pointer(previous_node)).Dynamic_precedence
		(*StackNode)(unsafe.Pointer(node)).Node_count = (*StackNode)(unsafe.Pointer(previous_node)).Node_count

		if *(*uintptr)(unsafe.Pointer(bp /* &subtree */)) != 0 {
			*(*uint32)(unsafe.Pointer(node + 280 /* &.error_cost */)) += (ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp /* subtree */))))
			(*StackNode)(unsafe.Pointer(node)).Position = length_add(tls, (*StackNode)(unsafe.Pointer(node)).Position, ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(bp /* subtree */))))
			*(*uint32)(unsafe.Pointer(node + 284 /* &.node_count */)) += (ts_subtree_node_count(tls, *(*Subtree)(unsafe.Pointer(bp /* subtree */))))
			*(*int32)(unsafe.Pointer(node + 288 /* &.dynamic_precedence */)) += (ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp /* subtree */))))
		}
	} else {
		(*StackNode)(unsafe.Pointer(node)).Position = length_zero(tls)
		(*StackNode)(unsafe.Pointer(node)).Error_cost = uint32(0)
	}

	return node
}

func stack__subtree_is_equivalent(tls *libc.TLS, left Subtree, right Subtree) uint8 { /* stack.c:158:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*Subtree)(unsafe.Pointer(bp)) = left
	*(*Subtree)(unsafe.Pointer(bp + 16)) = right

	return (uint8(libc.Bool32((*(*uintptr)(unsafe.Pointer(bp /* &left */)) == *(*uintptr)(unsafe.Pointer(bp + 16 /* &right */))) || ((((*(*uintptr)(unsafe.Pointer(bp /* &left */)) != 0) && (*(*uintptr)(unsafe.Pointer(bp + 16 /* &right */)) != 0)) && (int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp /* left */)))) == int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */)))))) && (((ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp /* left */))) > Uint32_t(0)) && (ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))) > Uint32_t(0))) || (((((ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(bp /* left */))).Bytes == ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))).Bytes) && (ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(bp /* left */))).Bytes == ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))).Bytes)) && (ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* left */))) == ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))))) && (ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp /* left */))) == ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))))) && (Xts_subtree_external_scanner_state_eq(tls, *(*Subtree)(unsafe.Pointer(bp /* left */)), *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))) != 0)))))))
}

func stack_node_add_link(tls *libc.TLS, self uintptr, link StackLink, subtree_pool uintptr) { /* stack.c:171:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*StackLink)(unsafe.Pointer(bp)) = link

	if (*StackLink)(unsafe.Pointer(bp /* &link */)).Node == self {
		return
	}

	{
		var i int32 = 0
	__1:
		if !(i < int32((*StackNode)(unsafe.Pointer(self)).Link_count)) {
			goto __3
		}
		{
			var existing_link uintptr = ((self + 16 /* &.links */) + uintptr(i)*32)
			if stack__subtree_is_equivalent(tls, (*StackLink)(unsafe.Pointer(existing_link)).Subtree, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree) != 0 {
				// In general, we preserve ambiguities until they are removed from the stack
				// during a pop operation where multiple paths lead to the same node. But in
				// the special case where two links directly connect the same pair of nodes,
				// we can safely remove the ambiguity ahead of time without changing behavior.
				if (*StackLink)(unsafe.Pointer(existing_link)).Node == (*StackLink)(unsafe.Pointer(bp /* &link */)).Node {
					if ts_subtree_dynamic_precedence(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree) > ts_subtree_dynamic_precedence(tls, (*StackLink)(unsafe.Pointer(existing_link)).Subtree) {
						Xts_subtree_retain(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree)
						Xts_subtree_release(tls, subtree_pool, (*StackLink)(unsafe.Pointer(existing_link)).Subtree)
						(*StackLink)(unsafe.Pointer(existing_link)).Subtree = (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree
						(*StackNode)(unsafe.Pointer(self)).Dynamic_precedence = ((*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(bp /* &link */)).Node)).Dynamic_precedence + ts_subtree_dynamic_precedence(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree))
					}
					return
				}

				// If the previous nodes are mergeable, merge them recursively.
				if (int32((*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(existing_link)).Node)).State) == int32((*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(bp /* &link */)).Node)).State)) && ((*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(existing_link)).Node)).Position.Bytes == (*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(bp /* &link */)).Node)).Position.Bytes) {
					{
						var j int32 = 0
					__4:
						if !(j < int32((*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(bp /* &link */)).Node)).Link_count)) {
							goto __6
						}
						{
							stack_node_add_link(tls, (*StackLink)(unsafe.Pointer(existing_link)).Node, *(*StackLink)(unsafe.Pointer(((*StackLink)(unsafe.Pointer(bp /* &link */)).Node + 16 /* &.links */) + uintptr(j)*32)), subtree_pool)

						}
						goto __5
					__5:
						j++
						goto __4
						goto __6
					__6:
						;
					}
					var dynamic_precedence Int32_t = (*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(bp /* &link */)).Node)).Dynamic_precedence
					if *(*uintptr)(unsafe.Pointer(bp /* &link */ + 8 /* &.subtree */)) != 0 {
						dynamic_precedence = dynamic_precedence + (ts_subtree_dynamic_precedence(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree))
					}
					if dynamic_precedence > (*StackNode)(unsafe.Pointer(self)).Dynamic_precedence {
						(*StackNode)(unsafe.Pointer(self)).Dynamic_precedence = dynamic_precedence
					}
					return
				}
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	if int32((*StackNode)(unsafe.Pointer(self)).Link_count) == MAX_LINK_COUNT {
		return
	}

	stack_node_retain(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Node)
	var node_count uint32 = (*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(bp /* &link */)).Node)).Node_count
	var dynamic_precedence int32 = (*StackNode)(unsafe.Pointer((*StackLink)(unsafe.Pointer(bp /* &link */)).Node)).Dynamic_precedence
	*(*StackLink)(unsafe.Pointer((self + 16 /* &.links */) + uintptr(libc.PostIncUint16(&(*StackNode)(unsafe.Pointer(self)).Link_count, 1))*32)) = *(*StackLink)(unsafe.Pointer(bp /* link */))

	if *(*uintptr)(unsafe.Pointer(bp /* &link */ + 8 /* &.subtree */)) != 0 {
		Xts_subtree_retain(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree)
		node_count = node_count + (ts_subtree_node_count(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree))
		dynamic_precedence = dynamic_precedence + (ts_subtree_dynamic_precedence(tls, (*StackLink)(unsafe.Pointer(bp /* &link */)).Subtree))
	}

	if node_count > (*StackNode)(unsafe.Pointer(self)).Node_count {
		(*StackNode)(unsafe.Pointer(self)).Node_count = node_count
	}
	if dynamic_precedence > (*StackNode)(unsafe.Pointer(self)).Dynamic_precedence {
		(*StackNode)(unsafe.Pointer(self)).Dynamic_precedence = dynamic_precedence
	}
}

func stack_head_delete(tls *libc.TLS, self uintptr, pool uintptr, subtree_pool uintptr) { /* stack.c:230:13: */
	if (*StackHead)(unsafe.Pointer(self)).Node != 0 {
		if *(*uintptr)(unsafe.Pointer(self + 8 /* &.last_external_token */)) != 0 {
			Xts_subtree_release(tls, subtree_pool, (*StackHead)(unsafe.Pointer(self)).Last_external_token)
		}
		if (*StackHead)(unsafe.Pointer(self)).Summary != 0 {
			array__delete(tls, (*StackHead)(unsafe.Pointer(self)).Summary)
			ts_free_default(tls, (*StackHead)(unsafe.Pointer(self)).Summary)
		}
		stack_node_release(tls, (*StackHead)(unsafe.Pointer(self)).Node, pool, subtree_pool)
	}
}

func ts_stack__add_version(tls *libc.TLS, self uintptr, original_version StackVersion, node uintptr) StackVersion { /* stack.c:243:21: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*StackHead)(unsafe.Pointer(bp /* head */)) = StackHead{Node: node, Last_external_token: (*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(original_version)*48)).Last_external_token, Node_count_at_last_error: (*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(original_version)*48)).Node_count_at_last_error}
	array__grow(tls, (self /* &.heads */), uint64(1), uint64(unsafe.Sizeof(StackHead{})))
	*(*StackHead)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Size, 1))*48)) = *(*StackHead)(unsafe.Pointer(bp /* head */))
	stack_node_retain(tls, node)
	if *(*uintptr)(unsafe.Pointer(bp /* &head */ + 8 /* &.last_external_token */)) != 0 {
		Xts_subtree_retain(tls, (*StackHead)(unsafe.Pointer(bp /* &head */)).Last_external_token)
	}
	return ((*Stack)(unsafe.Pointer(self)).Heads.Size - Uint32_t(1))
}

func ts_stack__add_slice(tls *libc.TLS, self uintptr, original_version StackVersion, node uintptr, subtrees uintptr) { /* stack.c:258:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	{
		var i Uint32_t = ((*Stack)(unsafe.Pointer(self)).Slices.Size - Uint32_t(1))
	__1:
		if !((i + Uint32_t(1)) > Uint32_t(0)) {
			goto __3
		}
		{
			var version StackVersion = (*StackSlice)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Slices.Contents + uintptr(i)*24)).Version
			if (*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents+uintptr(version)*48)).Node == node {
				*(*StackSlice)(unsafe.Pointer(bp /* slice */)) = StackSlice{Subtrees: *(*SubtreeArray)(unsafe.Pointer(subtrees)), Version: version}
				array__splice(tls, (self + 16 /* &.slices */), uint64(unsafe.Sizeof(StackSlice{})), (i + Uint32_t(1)), uint32(0), uint32(1), bp /* &slice */)
				return
			}

		}
		goto __2
	__2:
		i--
		goto __1
		goto __3
	__3:
		;
	}

	var version StackVersion = ts_stack__add_version(tls, self, original_version, node)
	var slice = StackSlice{Subtrees: *(*SubtreeArray)(unsafe.Pointer(subtrees)), Version: version}
	array__grow(tls, (self + 16 /* &.slices */), uint64(1), uint64(unsafe.Sizeof(StackSlice{})))
	*(*StackSlice)(unsafe.Pointer((*StackSliceArray)(unsafe.Pointer((self + 16 /* &.slices */))).Contents + uintptr(libc.PostIncUint32(&(*StackSliceArray)(unsafe.Pointer((self+16 /* &.slices */))).Size, 1))*24)) = slice
}

func stack__iter(tls *libc.TLS, self uintptr, version StackVersion, callback StackCallback, payload uintptr, goal_subtree_count int32) StackSliceArray { /* stack.c:274:24: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	(*StackSliceArray)(unsafe.Pointer((self + 16 /* &.slices */))).Size = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 32 /* &.iterators */))).Size = Uint32_t(0)

	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__84)), ts+2946 /* "upstream/tree-si..." */, 280, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	*(*StackIterator)(unsafe.Pointer(bp /* iterator */)) = StackIterator{Node: (*StackHead)(unsafe.Pointer(head)).Node, Is_pending: uint8(True)}

	var include_subtrees uint8 = uint8(False)
	if goal_subtree_count >= 0 {
		include_subtrees = uint8(True)
		array__reserve(tls, (bp /* &iterator */ + 8 /* &.subtrees */), uint64(unsafe.Sizeof(Subtree{})), (uint32(ts_subtree_alloc_size(tls, uint32(goal_subtree_count)) / Size_t(unsafe.Sizeof(Subtree{})))))
	}

	array__grow(tls, (self + 32 /* &.iterators */), uint64(1), uint64(unsafe.Sizeof(StackIterator{})))
	*(*StackIterator)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 32 /* &.iterators */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self+32 /* &.iterators */))).Size, 1))*32)) = *(*StackIterator)(unsafe.Pointer(bp /* iterator */))

	for (*Stack)(unsafe.Pointer(self)).Iterators.Size > Uint32_t(0) {
		{
			var i Uint32_t = Uint32_t(0)
			var size Uint32_t = (*Stack)(unsafe.Pointer(self)).Iterators.Size
		__1:
			if !(i < size) {
				goto __3
			}
			{
				var iterator uintptr = ((*Stack)(unsafe.Pointer(self)).Iterators.Contents + uintptr(i)*32)
				var node uintptr = (*StackIterator)(unsafe.Pointer(iterator)).Node

				var action StackAction = (*struct {
					f func(*libc.TLS, uintptr, uintptr) StackAction
				})(unsafe.Pointer(&struct{ uintptr }{callback})).f(tls, payload, iterator)
				var should_pop uint8 = (uint8(action & StackActionPop))
				var should_stop uint8 = (uint8(libc.Bool32(((action & StackActionStop) != 0) || (int32((*StackNode)(unsafe.Pointer(node)).Link_count) == 0))))

				if should_pop != 0 {
					*(*SubtreeArray)(unsafe.Pointer(bp + 32 /* subtrees */)) = (*StackIterator)(unsafe.Pointer(iterator)).Subtrees
					if !(should_stop != 0) {
						Xts_subtree_array_copy(tls, *(*SubtreeArray)(unsafe.Pointer(bp + 32 /* subtrees */)), bp+32 /* &subtrees */)
					}
					Xts_subtree_array_reverse(tls, bp+32 /* &subtrees */)
					ts_stack__add_slice(tls,
						self,
						version,
						node,
						bp+32 /* &subtrees */)
				}

				if should_stop != 0 {
					if !(should_pop != 0) {
						Xts_subtree_array_delete(tls, (*Stack)(unsafe.Pointer(self)).Subtree_pool, (iterator + 8 /* &.subtrees */))
					}
					array__erase(tls, (self + 32 /* &.iterators */), uint64(unsafe.Sizeof(StackIterator{})), i)
					i--
					size--
					goto __2
				}

				{
					var j Uint32_t = Uint32_t(1)
				__4:
					if !(j <= Uint32_t((*StackNode)(unsafe.Pointer(node)).Link_count)) {
						goto __6
					}
					{
						var next_iterator uintptr
						// var link StackLink at bp+48, 32

						if j == Uint32_t((*StackNode)(unsafe.Pointer(node)).Link_count) {
							*(*StackLink)(unsafe.Pointer(bp + 48 /* link */)) = *(*StackLink)(unsafe.Pointer((node + 16 /* &.links */)))
							next_iterator = ((*Stack)(unsafe.Pointer(self)).Iterators.Contents + uintptr(i)*32)
						} else {
							if (*Stack)(unsafe.Pointer(self)).Iterators.Size >= Uint32_t(MAX_ITERATOR_COUNT) {
								goto __5
							}
							*(*StackLink)(unsafe.Pointer(bp + 48 /* link */)) = *(*StackLink)(unsafe.Pointer((node + 16 /* &.links */) + uintptr(j)*32))
							var current_iterator = *(*StackIterator)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Iterators.Contents + uintptr(i)*32))
							array__grow(tls, (self + 32 /* &.iterators */), uint64(1), uint64(unsafe.Sizeof(StackIterator{})))
							*(*StackIterator)(unsafe.Pointer((*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((self + 32 /* &.iterators */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((self+32 /* &.iterators */))).Size, 1))*32)) = current_iterator
							next_iterator = func() uintptr {
								if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self+32 /* &.iterators */))).Size-Uint32_t(1)) < (*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self+32 /* &.iterators */))).Size)), int64(0)) != 0 {
									libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__84)), ts+2946 /* "upstream/tree-si..." */, 338, ts+3102 /* "(uint32_t)(&self..." */)
								} else {
								}
								return ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self + 32 /* &.iterators */))).Contents + uintptr(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self+32 /* &.iterators */))).Size-Uint32_t(1)))*32)
							}()
							Xts_subtree_array_copy(tls, (*StackIterator)(unsafe.Pointer(next_iterator)).Subtrees, (next_iterator + 8 /* &.subtrees */))
						}

						(*StackIterator)(unsafe.Pointer(next_iterator)).Node = (*StackLink)(unsafe.Pointer(bp + 48 /* &link */)).Node
						if *(*uintptr)(unsafe.Pointer(bp + 48 /* &link */ + 8 /* &.subtree */)) != 0 {
							if include_subtrees != 0 {
								array__grow(tls, (next_iterator + 8 /* &.subtrees */), uint64(1), uint64(unsafe.Sizeof(Subtree{})))
								*(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer((next_iterator + 8 /* &.subtrees */))).Contents + uintptr(libc.PostIncUint32(&(*SubtreeArray)(unsafe.Pointer((next_iterator+8 /* &.subtrees */))).Size, 1))*16)) = (*StackLink)(unsafe.Pointer(bp + 48 /* &link */)).Subtree
								Xts_subtree_retain(tls, (*StackLink)(unsafe.Pointer(bp+48 /* &link */)).Subtree)
							}

							if !(ts_subtree_extra(tls, (*StackLink)(unsafe.Pointer(bp+48 /* &link */)).Subtree) != 0) {
								(*StackIterator)(unsafe.Pointer(next_iterator)).Subtree_count++
								if !(int32((*StackLink)(unsafe.Pointer(bp+48 /* &link */)).Is_pending) != 0) {
									(*StackIterator)(unsafe.Pointer(next_iterator)).Is_pending = uint8(False)
								}
							}
						} else {
							(*StackIterator)(unsafe.Pointer(next_iterator)).Subtree_count++
							(*StackIterator)(unsafe.Pointer(next_iterator)).Is_pending = uint8(False)
						}

					}
					goto __5
				__5:
					j++
					goto __4
					goto __6
				__6:
					;
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	return (*Stack)(unsafe.Pointer(self)).Slices
}

var __func__84 = *(*[12]int8)(unsafe.Pointer(ts + 3168 /* "stack__iter" */)) /* stack.c:276:60 */

func Xts_stack_new(tls *libc.TLS, subtree_pool uintptr) uintptr { /* stack.c:366:7: */
	var self uintptr = ts_calloc_default(tls, uint64(1), uint64(unsafe.Sizeof(Stack{})))

	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Size = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Capacity = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Contents = uintptr(0)
	(*StackSliceArray)(unsafe.Pointer((self + 16 /* &.slices */))).Size = Uint32_t(0)
	(*StackSliceArray)(unsafe.Pointer((self + 16 /* &.slices */))).Capacity = Uint32_t(0)
	(*StackSliceArray)(unsafe.Pointer((self + 16 /* &.slices */))).Contents = uintptr(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 32 /* &.iterators */))).Size = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 32 /* &.iterators */))).Capacity = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 32 /* &.iterators */))).Contents = uintptr(0)
	(*StackNodeArray)(unsafe.Pointer((self + 48 /* &.node_pool */))).Size = Uint32_t(0)
	(*StackNodeArray)(unsafe.Pointer((self + 48 /* &.node_pool */))).Capacity = Uint32_t(0)
	(*StackNodeArray)(unsafe.Pointer((self + 48 /* &.node_pool */))).Contents = uintptr(0)
	array__reserve(tls, (self /* &.heads */), uint64(unsafe.Sizeof(StackHead{})), uint32(4))
	array__reserve(tls, (self + 16 /* &.slices */), uint64(unsafe.Sizeof(StackSlice{})), uint32(4))
	array__reserve(tls, (self + 32 /* &.iterators */), uint64(unsafe.Sizeof(StackIterator{})), uint32(4))
	array__reserve(tls, (self + 48 /* &.node_pool */), uint64(unsafe.Sizeof(uintptr(0))), uint32(MAX_NODE_POOL_SIZE))

	(*Stack)(unsafe.Pointer(self)).Subtree_pool = subtree_pool
	(*Stack)(unsafe.Pointer(self)).Base_node = stack_node_new(tls, uintptr(0), Subtree{}, uint8(False), uint16(1), (self + 48 /* &.node_pool */))
	Xts_stack_clear(tls, self)

	return self
}

func Xts_stack_delete(tls *libc.TLS, self uintptr) { /* stack.c:385:6: */
	if (*Stack)(unsafe.Pointer(self)).Slices.Contents != 0 {
		array__delete(tls, (self + 16 /* &.slices */))
	}
	if (*Stack)(unsafe.Pointer(self)).Iterators.Contents != 0 {
		array__delete(tls, (self + 32 /* &.iterators */))
	}
	stack_node_release(tls, (*Stack)(unsafe.Pointer(self)).Base_node, (self + 48 /* &.node_pool */), (*Stack)(unsafe.Pointer(self)).Subtree_pool)
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < (*Stack)(unsafe.Pointer(self)).Heads.Size) {
			goto __3
		}
		{
			stack_head_delete(tls, ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(i)*48), (self + 48 /* &.node_pool */), (*Stack)(unsafe.Pointer(self)).Subtree_pool)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Size = Uint32_t(0)
	if (*Stack)(unsafe.Pointer(self)).Node_pool.Contents != 0 {
		{
			var i Uint32_t = Uint32_t(0)
		__4:
			if !(i < (*Stack)(unsafe.Pointer(self)).Node_pool.Size) {
				goto __6
			}
			ts_free_default(tls, *(*uintptr)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Node_pool.Contents + uintptr(i)*8)))
			goto __5
		__5:
			i++
			goto __4
			goto __6
		__6:
			;
		}
		array__delete(tls, (self + 48 /* &.node_pool */))
	}
	array__delete(tls, (self /* &.heads */))
	ts_free_default(tls, self)
}

func Xts_stack_version_count(tls *libc.TLS, self uintptr) Uint32_t { /* stack.c:404:10: */
	return (*Stack)(unsafe.Pointer(self)).Heads.Size
}

func Xts_stack_state(tls *libc.TLS, self uintptr, version StackVersion) TSStateId { /* stack.c:408:11: */
	return (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__85)), ts+2946 /* "upstream/tree-si..." */, 409, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}())).Node)).State
}

var __func__85 = *(*[15]int8)(unsafe.Pointer(ts + 3180 /* "ts_stack_state" */)) /* stack.c:408:67 */

func Xts_stack_position(tls *libc.TLS, self uintptr, version StackVersion) Length { /* stack.c:412:8: */
	return (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__86)), ts+2946 /* "upstream/tree-si..." */, 413, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}())).Node)).Position
}

var __func__86 = *(*[18]int8)(unsafe.Pointer(ts + 3195 /* "ts_stack_positio..." */)) /* stack.c:412:67 */

func Xts_stack_last_external_token(tls *libc.TLS, self uintptr, version StackVersion) Subtree { /* stack.c:416:9: */
	return (*StackHead)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__87)), ts+2946 /* "upstream/tree-si..." */, 417, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}())).Last_external_token
}

var __func__87 = *(*[29]int8)(unsafe.Pointer(ts + 3213 /* "ts_stack_last_ex..." */)) /* stack.c:416:79 */

func Xts_stack_set_last_external_token(tls *libc.TLS, self uintptr, version StackVersion, token Subtree) { /* stack.c:420:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = token

	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__88)), ts+2946 /* "upstream/tree-si..." */, 421, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	if *(*uintptr)(unsafe.Pointer(bp /* &token */)) != 0 {
		Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer(bp /* token */)))
	}
	if *(*uintptr)(unsafe.Pointer(head + 8 /* &.last_external_token */)) != 0 {
		Xts_subtree_release(tls, (*Stack)(unsafe.Pointer(self)).Subtree_pool, (*StackHead)(unsafe.Pointer(head)).Last_external_token)
	}
	(*StackHead)(unsafe.Pointer(head)).Last_external_token = *(*Subtree)(unsafe.Pointer(bp /* token */))
}

var __func__88 = *(*[33]int8)(unsafe.Pointer(ts + 3242 /* "ts_stack_set_las..." */)) /* stack.c:420:89 */

func Xts_stack_error_cost(tls *libc.TLS, self uintptr, version StackVersion) uint32 { /* stack.c:427:10: */
	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__89)), ts+2946 /* "upstream/tree-si..." */, 428, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	var result uint32 = (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head)).Node)).Error_cost
	if ((*StackHead)(unsafe.Pointer(head)).Status == StackStatusPaused) || ((int32((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head)).Node)).State) == ERROR_STATE) && !(int32(*(*uintptr)(unsafe.Pointer(((*StackHead)(unsafe.Pointer(head)).Node + 16 /* &.links */) + 8 /* &.subtree */))) != 0)) {
		result = result + (uint32(ERROR_COST_PER_RECOVERY))
	}
	return result
}

var __func__89 = *(*[20]int8)(unsafe.Pointer(ts + 3275 /* "ts_stack_error_c..." */)) /* stack.c:427:71 */

func Xts_stack_node_count_since_error(tls *libc.TLS, self uintptr, version StackVersion) uint32 { /* stack.c:438:10: */
	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__90)), ts+2946 /* "upstream/tree-si..." */, 439, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	if (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head)).Node)).Node_count < (*StackHead)(unsafe.Pointer(head)).Node_count_at_last_error {
		(*StackHead)(unsafe.Pointer(head)).Node_count_at_last_error = (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head)).Node)).Node_count
	}
	return ((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head)).Node)).Node_count - (*StackHead)(unsafe.Pointer(head)).Node_count_at_last_error)
}

var __func__90 = *(*[32]int8)(unsafe.Pointer(ts + 3295 /* "ts_stack_node_co..." */)) /* stack.c:438:83 */

func Xts_stack_push(tls *libc.TLS, self uintptr, version StackVersion, subtree Subtree, pending uint8, state TSStateId) { /* stack.c:446:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = subtree

	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__91)), ts+2946 /* "upstream/tree-si..." */, 448, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	var new_node uintptr = stack_node_new(tls, (*StackHead)(unsafe.Pointer(head)).Node, *(*Subtree)(unsafe.Pointer(bp /* subtree */)), pending, state, (self + 48 /* &.node_pool */))
	if !(int32(*(*uintptr)(unsafe.Pointer(bp /* &subtree */))) != 0) {
		(*StackHead)(unsafe.Pointer(head)).Node_count_at_last_error = (*StackNode)(unsafe.Pointer(new_node)).Node_count
	}
	(*StackHead)(unsafe.Pointer(head)).Node = new_node
}

var __func__91 = *(*[14]int8)(unsafe.Pointer(ts + 3327 /* "ts_stack_push" */)) /* stack.c:447:51 */

func iterate_callback(tls *libc.TLS, payload uintptr, iterator uintptr) StackAction { /* stack.c:454:20: */
	var session uintptr = payload
	(*struct {
		f func(*libc.TLS, uintptr, TSStateId, Uint32_t)
	})(unsafe.Pointer(&struct{ uintptr }{(*StackIterateSession)(unsafe.Pointer(session)).Callback})).f(tls,
		(*StackIterateSession)(unsafe.Pointer(session)).Payload,
		(*StackNode)(unsafe.Pointer((*StackIterator)(unsafe.Pointer(iterator)).Node)).State,
		(*StackIterator)(unsafe.Pointer(iterator)).Subtree_count)
	return StackActionNone
}

func Xts_stack_iterate(tls *libc.TLS, self uintptr, version StackVersion, callback StackIterateCallback, payload uintptr) { /* stack.c:464:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*StackIterateSession)(unsafe.Pointer(bp /* session */)) = StackIterateSession{Payload: payload, Callback: callback}
	stack__iter(tls, self, version, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) StackAction
	}{iterate_callback})), bp /* &session */, -1)
}

func pop_count_callback(tls *libc.TLS, payload uintptr, iterator uintptr) StackAction { /* stack.c:470:20: */
	var goal_subtree_count uintptr = payload
	if (*StackIterator)(unsafe.Pointer(iterator)).Subtree_count == *(*uint32)(unsafe.Pointer(goal_subtree_count)) {
		return (StackAction(StackActionPop | StackActionStop))
	} else {
		return StackActionNone
	}
	return StackAction(0)
}

func Xts_stack_pop_count(tls *libc.TLS, self uintptr, version StackVersion, count Uint32_t) StackSliceArray { /* stack.c:479:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*Uint32_t)(unsafe.Pointer(bp)) = count

	return stack__iter(tls, self, version, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) StackAction
	}{pop_count_callback})), bp /* &count */, int32(*(*Uint32_t)(unsafe.Pointer(bp /* count */))))
}

func pop_pending_callback(tls *libc.TLS, payload uintptr, iterator uintptr) StackAction { /* stack.c:483:20: */
	_ = payload
	if (*StackIterator)(unsafe.Pointer(iterator)).Subtree_count >= Uint32_t(1) {
		if (*StackIterator)(unsafe.Pointer(iterator)).Is_pending != 0 {
			return (StackAction(StackActionPop | StackActionStop))
		} else {
			return StackActionStop
		}
	} else {
		return StackActionNone
	}
	return StackAction(0)
}

func Xts_stack_pop_pending(tls *libc.TLS, self uintptr, version StackVersion) StackSliceArray { /* stack.c:496:17: */
	var pop = stack__iter(tls, self, version, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) StackAction
	}{pop_pending_callback})), uintptr(0), 0)
	if pop.Size > Uint32_t(0) {
		Xts_stack_renumber_version(tls, self, (*StackSlice)(unsafe.Pointer(pop.Contents)).Version, version)
		(*StackSlice)(unsafe.Pointer(pop.Contents)).Version = version
	}
	return pop
}

func pop_error_callback(tls *libc.TLS, payload uintptr, iterator uintptr) StackAction { /* stack.c:505:20: */
	if (*StackIterator)(unsafe.Pointer(iterator)).Subtrees.Size > Uint32_t(0) {
		var found_error uintptr = payload
		if !(int32(*(*uint8)(unsafe.Pointer(found_error))) != 0) && (ts_subtree_is_error(tls, *(*Subtree)(unsafe.Pointer((*StackIterator)(unsafe.Pointer(iterator)).Subtrees.Contents))) != 0) {
			*(*uint8)(unsafe.Pointer(found_error)) = uint8(True)
			return (StackAction(StackActionPop | StackActionStop))
		} else {
			return StackActionStop
		}
	} else {
		return StackActionNone
	}
	return StackAction(0)
}

func Xts_stack_pop_error(tls *libc.TLS, self uintptr, version StackVersion) SubtreeArray { /* stack.c:519:14: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	var node uintptr = (*StackHead)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__92)), ts+2946 /* "upstream/tree-si..." */, 520, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}())).Node
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < uint32((*StackNode)(unsafe.Pointer(node)).Link_count)) {
			goto __3
		}
		{
			if (*(*uintptr)(unsafe.Pointer((node + 16 /* &.links */) + uintptr(i)*32 + 8 /* &.subtree */)) != 0) && (ts_subtree_is_error(tls, (*StackLink)(unsafe.Pointer((node+16 /* &.links */)+uintptr(i)*32)).Subtree) != 0) {
				*(*uint8)(unsafe.Pointer(bp /* found_error */)) = uint8(False)
				var pop = stack__iter(tls, self, version, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr) StackAction
				}{pop_error_callback})), bp /* &found_error */, 1)
				if pop.Size > Uint32_t(0) {
					if libc.X__builtin_expect(tls, libc.BoolInt64(!(pop.Size == Uint32_t(1))), int64(0)) != 0 {
						libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__92)), ts+2946 /* "upstream/tree-si..." */, 526, ts+3341 /* "pop.size == 1" */)
					} else {
					}
					Xts_stack_renumber_version(tls, self, (*StackSlice)(unsafe.Pointer(pop.Contents)).Version, version)
					return (*StackSlice)(unsafe.Pointer(pop.Contents)).Subtrees
				}
				goto __3
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return SubtreeArray{}
}

var __func__92 = *(*[19]int8)(unsafe.Pointer(ts + 3355 /* "ts_stack_pop_err..." */)) /* stack.c:519:68 */

func pop_all_callback(tls *libc.TLS, payload uintptr, iterator uintptr) StackAction { /* stack.c:536:20: */
	_ = payload
	if int32((*StackNode)(unsafe.Pointer((*StackIterator)(unsafe.Pointer(iterator)).Node)).Link_count) == 0 {
		return StackActionPop
	}
	return StackActionNone
}

func Xts_stack_pop_all(tls *libc.TLS, self uintptr, version StackVersion) StackSliceArray { /* stack.c:541:17: */
	return stack__iter(tls, self, version, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) StackAction
	}{pop_all_callback})), uintptr(0), 0)
}

type SummarizeStackSession = struct {
	Summary     uintptr
	Max_depth   uint32
	__ccgo_pad1 [4]byte
} /* stack.c:548:3 */

func summarize_stack_callback(tls *libc.TLS, payload uintptr, iterator uintptr) StackAction { /* stack.c:550:20: */
	var session uintptr = payload
	var state TSStateId = (*StackNode)(unsafe.Pointer((*StackIterator)(unsafe.Pointer(iterator)).Node)).State
	var depth uint32 = (*StackIterator)(unsafe.Pointer(iterator)).Subtree_count
	if depth > (*SummarizeStackSession)(unsafe.Pointer(session)).Max_depth {
		return StackActionStop
	}
	{
		var i uint32 = ((*StackSummary)(unsafe.Pointer((*SummarizeStackSession)(unsafe.Pointer(session)).Summary)).Size - Uint32_t(1))
	__1:
		if !((i + uint32(1)) > uint32(0)) {
			goto __3
		}
		{
			var entry = *(*StackSummaryEntry)(unsafe.Pointer((*StackSummary)(unsafe.Pointer((*SummarizeStackSession)(unsafe.Pointer(session)).Summary)).Contents + uintptr(i)*20))
			if entry.Depth < depth {
				goto __3
			}
			if (entry.Depth == depth) && (int32(entry.State) == int32(state)) {
				return StackActionNone
			}

		}
		goto __2
	__2:
		i--
		goto __1
		goto __3
	__3:
		;
	}
	array__grow(tls, (*SummarizeStackSession)(unsafe.Pointer(session)).Summary, uint64(1), uint64(unsafe.Sizeof(StackSummaryEntry{})))
	*(*StackSummaryEntry)(unsafe.Pointer((*StackSummary)(unsafe.Pointer(((*SummarizeStackSession)(unsafe.Pointer(session)).Summary))).Contents + uintptr(libc.PostIncUint32(&(*StackSummary)(unsafe.Pointer((*SummarizeStackSession)(unsafe.Pointer(session)).Summary)).Size, 1))*20)) = StackSummaryEntry{Position: (*StackNode)(unsafe.Pointer((*StackIterator)(unsafe.Pointer(iterator)).Node)).Position, Depth: depth, State: state}
	return StackActionNone
}

func Xts_stack_record_summary(tls *libc.TLS, self uintptr, version StackVersion, max_depth uint32) { /* stack.c:568:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*SummarizeStackSession)(unsafe.Pointer(bp /* session */)) = SummarizeStackSession{Summary: ts_malloc_default(tls, uint64(unsafe.Sizeof(StackSummary{}))), Max_depth: max_depth}
	(*StackSummary)(unsafe.Pointer((*SummarizeStackSession)(unsafe.Pointer(bp /* &session */)).Summary)).Size = Uint32_t(0)
	(*StackSummary)(unsafe.Pointer((*SummarizeStackSession)(unsafe.Pointer(bp /* &session */)).Summary)).Capacity = Uint32_t(0)
	(*StackSummary)(unsafe.Pointer((*SummarizeStackSession)(unsafe.Pointer(bp /* &session */)).Summary)).Contents = uintptr(0)
	stack__iter(tls, self, version, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) StackAction
	}{summarize_stack_callback})), bp /* &session */, -1)
	var head uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(version)*48)
	if (*StackHead)(unsafe.Pointer(head)).Summary != 0 {
		array__delete(tls, (*StackHead)(unsafe.Pointer(head)).Summary)
		ts_free_default(tls, (*StackHead)(unsafe.Pointer(head)).Summary)
	}
	(*StackHead)(unsafe.Pointer(head)).Summary = (*SummarizeStackSession)(unsafe.Pointer(bp /* &session */)).Summary
}

func Xts_stack_get_summary(tls *libc.TLS, self uintptr, version StackVersion) uintptr { /* stack.c:583:14: */
	return (*StackHead)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__93)), ts+2946 /* "upstream/tree-si..." */, 584, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}())).Summary
}

var __func__93 = *(*[21]int8)(unsafe.Pointer(ts + 3374 /* "ts_stack_get_sum..." */)) /* stack.c:583:71 */

func Xts_stack_dynamic_precedence(tls *libc.TLS, self uintptr, version StackVersion) int32 { /* stack.c:587:5: */
	return (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__94)), ts+2946 /* "upstream/tree-si..." */, 588, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}())).Node)).Dynamic_precedence
}

var __func__94 = *(*[28]int8)(unsafe.Pointer(ts + 3395 /* "ts_stack_dynamic..." */)) /* stack.c:587:68 */

func Xts_stack_has_advanced_since_error(tls *libc.TLS, self uintptr, version StackVersion) uint8 { /* stack.c:591:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__95)), ts+2946 /* "upstream/tree-si..." */, 592, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	var node uintptr = (*StackHead)(unsafe.Pointer(head)).Node
	if (*StackNode)(unsafe.Pointer(node)).Error_cost == uint32(0) {
		return uint8(True)
	}
	for node != 0 {
		if int32((*StackNode)(unsafe.Pointer(node)).Link_count) > 0 {
			*(*Subtree)(unsafe.Pointer(bp /* subtree */)) = (*StackLink)(unsafe.Pointer((node + 16 /* &.links */))).Subtree
			if *(*uintptr)(unsafe.Pointer(bp /* &subtree */)) != 0 {
				if ts_subtree_total_bytes(tls, *(*Subtree)(unsafe.Pointer(bp /* subtree */))) > Uint32_t(0) {
					return uint8(True)
				} else if ((*StackNode)(unsafe.Pointer(node)).Node_count > (*StackHead)(unsafe.Pointer(head)).Node_count_at_last_error) && (ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp /* subtree */))) == Uint32_t(0)) {
					node = (*StackLink)(unsafe.Pointer((node + 16 /* &.links */))).Node
					continue
				}
			}
		}
		break
	}
	return uint8(False)
}

var __func__95 = *(*[34]int8)(unsafe.Pointer(ts + 3423 /* "ts_stack_has_adv..." */)) /* stack.c:591:81 */

func Xts_stack_remove_version(tls *libc.TLS, self uintptr, version StackVersion) { /* stack.c:615:6: */
	stack_head_delete(tls, func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__96)), ts+2946 /* "upstream/tree-si..." */, 616, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}(), (self + 48 /* &.node_pool */), (*Stack)(unsafe.Pointer(self)).Subtree_pool)
	array__erase(tls, (self /* &.heads */), uint64(unsafe.Sizeof(StackHead{})), version)
}

var __func__96 = *(*[24]int8)(unsafe.Pointer(ts + 3457 /* "ts_stack_remove_..." */)) /* stack.c:615:65 */

func Xts_stack_renumber_version(tls *libc.TLS, self uintptr, v1 StackVersion, v2 StackVersion) { /* stack.c:620:6: */
	if v1 == v2 {
		return
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(v2 < v1)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__97)), ts+2946 /* "upstream/tree-si..." */, 622, ts+3481 /* "v2 < v1" */)
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(v1 < (*Stack)(unsafe.Pointer(self)).Heads.Size)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__97)), ts+2946 /* "upstream/tree-si..." */, 623, ts+3489 /* "(uint32_t)v1 < s..." */)
	} else {
	}
	var source_head uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(v1)*48)
	var target_head uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(v2)*48)
	if ((*StackHead)(unsafe.Pointer(target_head)).Summary != 0) && !(int32((*StackHead)(unsafe.Pointer(source_head)).Summary) != 0) {
		(*StackHead)(unsafe.Pointer(source_head)).Summary = (*StackHead)(unsafe.Pointer(target_head)).Summary
		(*StackHead)(unsafe.Pointer(target_head)).Summary = uintptr(0)
	}
	stack_head_delete(tls, target_head, (self + 48 /* &.node_pool */), (*Stack)(unsafe.Pointer(self)).Subtree_pool)
	*(*StackHead)(unsafe.Pointer(target_head)) = *(*StackHead)(unsafe.Pointer(source_head))
	array__erase(tls, (self /* &.heads */), uint64(unsafe.Sizeof(StackHead{})), v1)
}

var __func__97 = *(*[26]int8)(unsafe.Pointer(ts + 3521 /* "ts_stack_renumbe..." */)) /* stack.c:620:79 */

func Xts_stack_swap_versions(tls *libc.TLS, self uintptr, v1 StackVersion, v2 StackVersion) { /* stack.c:635:6: */
	var temporary_head = *(*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(v1)*48))
	*(*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(v1)*48)) = *(*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(v2)*48))
	*(*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(v2)*48)) = temporary_head
}

func Xts_stack_copy_version(tls *libc.TLS, self uintptr, version StackVersion) StackVersion { /* stack.c:641:14: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*Stack)(unsafe.Pointer(self)).Heads.Size)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__98)), ts+2946 /* "upstream/tree-si..." */, 642, ts+3547 /* "version < self->..." */)
	} else {
	}
	array__grow(tls, (self /* &.heads */), uint64(1), uint64(unsafe.Sizeof(StackHead{})))
	*(*StackHead)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Size, 1))*48)) = *(*StackHead)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(version)*48))
	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__98)), ts+2946 /* "upstream/tree-si..." */, 644, ts+3574 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size-Uint32_t(1)))*48)
	}()
	stack_node_retain(tls, (*StackHead)(unsafe.Pointer(head)).Node)
	if *(*uintptr)(unsafe.Pointer(head + 8 /* &.last_external_token */)) != 0 {
		Xts_subtree_retain(tls, (*StackHead)(unsafe.Pointer(head)).Last_external_token)
	}
	(*StackHead)(unsafe.Pointer(head)).Summary = uintptr(0)
	return ((*Stack)(unsafe.Pointer(self)).Heads.Size - Uint32_t(1))
}

var __func__98 = *(*[22]int8)(unsafe.Pointer(ts + 3632 /* "ts_stack_copy_ve..." */)) /* stack.c:641:71 */

func Xts_stack_merge(tls *libc.TLS, self uintptr, version1 StackVersion, version2 StackVersion) uint8 { /* stack.c:651:6: */
	if !(Xts_stack_can_merge(tls, self, version1, version2) != 0) {
		return uint8(False)
	}
	var head1 uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(version1)*48)
	var head2 uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(version2)*48)
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < Uint32_t((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head2)).Node)).Link_count)) {
			goto __3
		}
		{
			stack_node_add_link(tls, (*StackHead)(unsafe.Pointer(head1)).Node, *(*StackLink)(unsafe.Pointer(((*StackHead)(unsafe.Pointer(head2)).Node + 16 /* &.links */) + uintptr(i)*32)), (*Stack)(unsafe.Pointer(self)).Subtree_pool)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	if int32((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head1)).Node)).State) == ERROR_STATE {
		(*StackHead)(unsafe.Pointer(head1)).Node_count_at_last_error = (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head1)).Node)).Node_count
	}
	Xts_stack_remove_version(tls, self, version2)
	return uint8(True)
}

func Xts_stack_can_merge(tls *libc.TLS, self uintptr, version1 StackVersion, version2 StackVersion) uint8 { /* stack.c:665:6: */
	var head1 uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(version1)*48)
	var head2 uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(version2)*48)
	return (uint8(libc.Bool32(((((((*StackHead)(unsafe.Pointer(head1)).Status == StackStatusActive) && ((*StackHead)(unsafe.Pointer(head2)).Status == StackStatusActive)) && (int32((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head1)).Node)).State) == int32((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head2)).Node)).State))) && ((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head1)).Node)).Position.Bytes == (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head2)).Node)).Position.Bytes)) && ((*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head1)).Node)).Error_cost == (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head2)).Node)).Error_cost)) && (Xts_subtree_external_scanner_state_eq(tls, (*StackHead)(unsafe.Pointer(head1)).Last_external_token, (*StackHead)(unsafe.Pointer(head2)).Last_external_token) != 0))))
}

func Xts_stack_halt(tls *libc.TLS, self uintptr, version StackVersion) { /* stack.c:677:6: */
	(*StackHead)(unsafe.Pointer(func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__99)), ts+2946 /* "upstream/tree-si..." */, 678, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}())).Status = StackStatusHalted
}

var __func__99 = *(*[14]int8)(unsafe.Pointer(ts + 3654 /* "ts_stack_halt" */)) /* stack.c:677:55 */

func Xts_stack_pause(tls *libc.TLS, self uintptr, version StackVersion, lookahead TSSymbol) { /* stack.c:681:6: */
	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__100)), ts+2946 /* "upstream/tree-si..." */, 682, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	(*StackHead)(unsafe.Pointer(head)).Status = StackStatusPaused
	(*StackHead)(unsafe.Pointer(head)).Lookahead_when_paused = lookahead
	(*StackHead)(unsafe.Pointer(head)).Node_count_at_last_error = (*StackNode)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head)).Node)).Node_count
}

var __func__100 = *(*[15]int8)(unsafe.Pointer(ts + 3668 /* "ts_stack_pause" */)) /* stack.c:681:76 */

func Xts_stack_is_active(tls *libc.TLS, self uintptr, version StackVersion) uint8 { /* stack.c:688:6: */
	return (uint8(libc.Bool32((*StackHead)(unsafe.Pointer((func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__101)), ts+2946 /* "upstream/tree-si..." */, 689, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()))).Status == StackStatusActive)))
}

var __func__101 = *(*[19]int8)(unsafe.Pointer(ts + 3683 /* "ts_stack_is_acti..." */)) /* stack.c:688:66 */

func Xts_stack_is_halted(tls *libc.TLS, self uintptr, version StackVersion) uint8 { /* stack.c:692:6: */
	return (uint8(libc.Bool32((*StackHead)(unsafe.Pointer((func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__102)), ts+2946 /* "upstream/tree-si..." */, 693, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()))).Status == StackStatusHalted)))
}

var __func__102 = *(*[19]int8)(unsafe.Pointer(ts + 3702 /* "ts_stack_is_halt..." */)) /* stack.c:692:66 */

func Xts_stack_is_paused(tls *libc.TLS, self uintptr, version StackVersion) uint8 { /* stack.c:696:6: */
	return (uint8(libc.Bool32((*StackHead)(unsafe.Pointer((func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__103)), ts+2946 /* "upstream/tree-si..." */, 697, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()))).Status == StackStatusPaused)))
}

var __func__103 = *(*[19]int8)(unsafe.Pointer(ts + 3721 /* "ts_stack_is_paus..." */)) /* stack.c:696:66 */

func Xts_stack_resume(tls *libc.TLS, self uintptr, version StackVersion) TSSymbol { /* stack.c:700:10: */
	var head uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(version < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__104)), ts+2946 /* "upstream/tree-si..." */, 701, ts+3061 /* "(uint32_t)versio..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(version)*48)
	}()
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((*StackHead)(unsafe.Pointer(head)).Status == StackStatusPaused)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__104)), ts+2946 /* "upstream/tree-si..." */, 702, ts+3740 /* "head->status == ..." */)
	} else {
	}
	var result TSSymbol = (*StackHead)(unsafe.Pointer(head)).Lookahead_when_paused
	(*StackHead)(unsafe.Pointer(head)).Status = StackStatusActive
	(*StackHead)(unsafe.Pointer(head)).Lookahead_when_paused = TSSymbol(0)
	return result
}

var __func__104 = *(*[16]int8)(unsafe.Pointer(ts + 3774 /* "ts_stack_resume" */)) /* stack.c:700:61 */

func Xts_stack_clear(tls *libc.TLS, self uintptr) { /* stack.c:709:6: */
	stack_node_retain(tls, (*Stack)(unsafe.Pointer(self)).Base_node)
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < (*Stack)(unsafe.Pointer(self)).Heads.Size) {
			goto __3
		}
		{
			stack_head_delete(tls, ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(i)*48), (self + 48 /* &.node_pool */), (*Stack)(unsafe.Pointer(self)).Subtree_pool)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Size = Uint32_t(0)
	array__grow(tls, (self /* &.heads */), uint64(1), uint64(unsafe.Sizeof(StackHead{})))
	*(*StackHead)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self /* &.heads */))).Size, 1))*48)) = StackHead{Node: (*Stack)(unsafe.Pointer(self)).Base_node}
}

func Xts_stack_print_dot_graph(tls *libc.TLS, self uintptr, language uintptr, f uintptr) uint8 { /* stack.c:723:6: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	array__reserve(tls, (self + 32 /* &.iterators */), uint64(unsafe.Sizeof(StackIterator{})), uint32(32))
	var was_recording_allocations uint8 = ts_toggle_allocation_recording(tls, uint8(False))
	if !(f != 0) {
		f = libc.X__stderrp
	}

	libc.Xfprintf(tls, f, ts+3790 /* "digraph stack {\n" */, 0)
	libc.Xfprintf(tls, f, ts+3807 /* "rankdir=\"RL\";\n" */, 0)
	libc.Xfprintf(tls, f, ts+3822 /* "edge [arrowhead=..." */, 0)

	*(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp + 192 /* visited_nodes */)) = struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}{}

	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 32 /* &.iterators */))).Size = Uint32_t(0)
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < (*Stack)(unsafe.Pointer(self)).Heads.Size) {
			goto __3
		}
		{
			var head uintptr = ((*Stack)(unsafe.Pointer(self)).Heads.Contents + uintptr(i)*48)
			if (*StackHead)(unsafe.Pointer(head)).Status == StackStatusHalted {
				goto __2
			}

			libc.Xfprintf(tls, f, ts+3845 /* "node_head_%u [sh..." */, libc.VaList(bp, i))
			libc.Xfprintf(tls, f, ts+3882 /* "node_head_%u -> ..." */, libc.VaList(bp+8, i, (*StackHead)(unsafe.Pointer(head)).Node))

			if (*StackHead)(unsafe.Pointer(head)).Status == StackStatusPaused {
				libc.Xfprintf(tls, f, ts+3908 /* "color=red " */, 0)
			}
			libc.Xfprintf(tls, f,
				ts+3919, /* "label=%u, fontco..." */
				libc.VaList(bp+24, i,
					Xts_stack_node_count_since_error(tls, self, i),
					Xts_stack_error_cost(tls, self, i)))

			if (*StackHead)(unsafe.Pointer(head)).Summary != 0 {
				libc.Xfprintf(tls, f, ts+4003 /* "\nsummary_size: %..." */, libc.VaList(bp+48, (*StackSummary)(unsafe.Pointer((*StackHead)(unsafe.Pointer(head)).Summary)).Size))
			}

			if *(*uintptr)(unsafe.Pointer(head + 8 /* &.last_external_token */)) != 0 {
				var state uintptr = (*(*uintptr)(unsafe.Pointer(head + 8 /* &.last_external_token */)) + 48 /* &.external_scanner_state */)
				var data uintptr = Xts_external_scanner_state_data(tls, state)
				libc.Xfprintf(tls, f, ts+4021 /* "\nexternal_scanne..." */, 0)
				{
					var j Uint32_t = Uint32_t(0)
				__4:
					if !(j < (*ExternalScannerState)(unsafe.Pointer(state)).Length) {
						goto __6
					}
					libc.Xfprintf(tls, f, ts+4046 /* " %2X" */, libc.VaList(bp+56, int32(*(*int8)(unsafe.Pointer(data + uintptr(j))))))
					goto __5
				__5:
					j++
					goto __4
					goto __6
				__6:
					;
				}
			}

			libc.Xfprintf(tls, f, ts+4051 /* "\"]\n" */, 0)
			array__grow(tls, (self + 32 /* &.iterators */), uint64(1), uint64(unsafe.Sizeof(StackIterator{})))
			*(*StackIterator)(unsafe.Pointer((*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self + 32 /* &.iterators */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
				Contents uintptr
				Size     Uint32_t
				Capacity Uint32_t
			})(unsafe.Pointer((self+32 /* &.iterators */))).Size, 1))*32)) = StackIterator{Node: (*StackHead)(unsafe.Pointer(head)).Node}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	var all_iterators_done uint8 = uint8(False)
	for !(all_iterators_done != 0) {
		all_iterators_done = uint8(True)

		{
			var i Uint32_t = Uint32_t(0)
		__7:
			if !(i < (*Stack)(unsafe.Pointer(self)).Iterators.Size) {
				goto __9
			}
			{
				var iterator = *(*StackIterator)(unsafe.Pointer((*Stack)(unsafe.Pointer(self)).Iterators.Contents + uintptr(i)*32))
				var node uintptr = iterator.Node

				{
					var j Uint32_t = Uint32_t(0)
				__10:
					if !(j < (*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer(bp+192 /* &visited_nodes */)).Size) {
						goto __12
					}
					{
						if *(*uintptr)(unsafe.Pointer((*struct {
							Contents uintptr
							Size     Uint32_t
							Capacity Uint32_t
						})(unsafe.Pointer(bp+192 /* &visited_nodes */)).Contents + uintptr(j)*8)) == node {
							node = uintptr(0)
							goto __12
						}

					}
					goto __11
				__11:
					j++
					goto __10
					goto __12
				__12:
					;
				}

				if !(node != 0) {
					goto __8
				}
				all_iterators_done = uint8(False)

				libc.Xfprintf(tls, f, ts+4055 /* "node_%p [" */, libc.VaList(bp+64, node))
				if int32((*StackNode)(unsafe.Pointer(node)).State) == ERROR_STATE {
					libc.Xfprintf(tls, f, ts+4065 /* "label=\"?\"" */, 0)
				} else if ((int32((*StackNode)(unsafe.Pointer(node)).Link_count) == 1) && (*(*uintptr)(unsafe.Pointer((node + 16 /* &.links */) + 8 /* &.subtree */)) != 0)) && (ts_subtree_extra(tls, (*StackLink)(unsafe.Pointer((node+16 /* &.links */))).Subtree) != 0) {
					libc.Xfprintf(tls, f, ts+4075 /* "shape=point marg..." */, 0)
				} else {
					libc.Xfprintf(tls, f, ts+4105 /* "label=\"%d\"" */, libc.VaList(bp+72, int32((*StackNode)(unsafe.Pointer(node)).State)))
				}

				libc.Xfprintf(tls,
					f,
					ts+4116, /* " tooltip=\"positi..." */
					libc.VaList(bp+80, ((*StackNode)(unsafe.Pointer(node)).Position.Extent.Row+Uint32_t(1)),
						(*StackNode)(unsafe.Pointer(node)).Position.Extent.Column,
						(*StackNode)(unsafe.Pointer(node)).Node_count,
						(*StackNode)(unsafe.Pointer(node)).Error_cost,
						(*StackNode)(unsafe.Pointer(node)).Dynamic_precedence))

				{
					var j1 int32 = 0
				__13:
					if !(j1 < int32((*StackNode)(unsafe.Pointer(node)).Link_count)) {
						goto __15
					}
					{
						*(*StackLink)(unsafe.Pointer(bp + 160 /* link */)) = *(*StackLink)(unsafe.Pointer((node + 16 /* &.links */) + uintptr(j1)*32))
						libc.Xfprintf(tls, f, ts+4198 /* "node_%p -> node_..." */, libc.VaList(bp+120, node, (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Node))
						if (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Is_pending != 0 {
							libc.Xfprintf(tls, f, ts+4219 /* "style=dashed " */, 0)
						}
						if (*(*uintptr)(unsafe.Pointer(bp + 160 /* &link */ + 8 /* &.subtree */)) != 0) && (ts_subtree_extra(tls, (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Subtree) != 0) {
							libc.Xfprintf(tls, f, ts+4233 /* "fontcolor=gray " */, 0)
						}

						if !(int32(*(*uintptr)(unsafe.Pointer(bp + 160 /* &link */ + 8 /* &.subtree */))) != 0) {
							libc.Xfprintf(tls, f, ts+4249 /* "color=red" */, 0)
						} else {
							libc.Xfprintf(tls, f, ts+4259 /* "label=\"" */, 0)
							var quoted uint8 = (uint8(libc.Bool32((ts_subtree_visible(tls, (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Subtree) != 0) && !(ts_subtree_named(tls, (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Subtree) != 0))))
							if quoted != 0 {
								libc.Xfprintf(tls, f, ts+4267 /* "'" */, 0)
							}
							var name uintptr = Xts_language_symbol_name(tls, language, ts_subtree_symbol(tls, (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Subtree))
							{
								var c uintptr = name
							__16:
								if !(*(*int8)(unsafe.Pointer(c)) != 0) {
									goto __18
								}
								{
									if (int32(*(*int8)(unsafe.Pointer(c))) == 34) || (int32(*(*int8)(unsafe.Pointer(c))) == '\\') {
										libc.Xfprintf(tls, f, ts+4269 /* "\\" */, 0)
									}
									libc.Xfprintf(tls, f, ts+4271 /* "%c" */, libc.VaList(bp+136, int32(*(*int8)(unsafe.Pointer(c)))))

								}
								goto __17
							__17:
								c++
								goto __16
								goto __18
							__18:
								;
							}
							if quoted != 0 {
								libc.Xfprintf(tls, f, ts+4267 /* "'" */, 0)
							}
							libc.Xfprintf(tls, f, ts+4274 /* "\"" */, 0)
							libc.Xfprintf(tls,
								f,
								ts+4276, /* "labeltooltip=\"er..." */
								libc.VaList(bp+144, ts_subtree_error_cost(tls, (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Subtree),
									ts_subtree_dynamic_precedence(tls, (*StackLink)(unsafe.Pointer(bp+160 /* &link */)).Subtree)))
						}

						libc.Xfprintf(tls, f, ts+4329 /* "];\n" */, 0)
						var next_iterator uintptr
						if j1 == 0 {
							next_iterator = ((*Stack)(unsafe.Pointer(self)).Iterators.Contents + uintptr(i)*32)
						} else {
							array__grow(tls, (self + 32 /* &.iterators */), uint64(1), uint64(unsafe.Sizeof(StackIterator{})))
							*(*StackIterator)(unsafe.Pointer((*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((self + 32 /* &.iterators */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
								Contents uintptr
								Size     Uint32_t
								Capacity Uint32_t
							})(unsafe.Pointer((self+32 /* &.iterators */))).Size, 1))*32)) = iterator
							next_iterator = func() uintptr {
								if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self+32 /* &.iterators */))).Size-Uint32_t(1)) < (*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self+32 /* &.iterators */))).Size)), int64(0)) != 0 {
									libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__105)), ts+2946 /* "upstream/tree-si..." */, 842, ts+3102 /* "(uint32_t)(&self..." */)
								} else {
								}
								return ((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self + 32 /* &.iterators */))).Contents + uintptr(((*struct {
									Contents uintptr
									Size     Uint32_t
									Capacity Uint32_t
								})(unsafe.Pointer((self+32 /* &.iterators */))).Size-Uint32_t(1)))*32)
							}()
						}
						(*StackIterator)(unsafe.Pointer(next_iterator)).Node = (*StackLink)(unsafe.Pointer(bp + 160 /* &link */)).Node

					}
					goto __14
				__14:
					j1++
					goto __13
					goto __15
				__15:
					;
				}

				array__grow(tls, bp+192 /* &visited_nodes */, uint64(1), uint64(unsafe.Sizeof(uintptr(0))))
				*(*uintptr)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((bp + 192 /* &visited_nodes */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer(bp+192 /* &visited_nodes */)).Size, 1))*8)) = node

			}
			goto __8
		__8:
			i++
			goto __7
			goto __9
		__9:
			;
		}
	}

	libc.Xfprintf(tls, f, ts+4333 /* "}\n" */, 0)

	array__delete(tls, bp+192 /* &visited_nodes */)
	ts_toggle_allocation_recording(tls, was_recording_allocations)
	return uint8(True)
}

var __func__105 = *(*[25]int8)(unsafe.Pointer(ts + 4336 /* "ts_stack_print_d..." */)) /* stack.c:723:81 */

// 8462256: modified __assert_rtn() replaces deprecated __eprintf()

// Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// This code is derived from software contributed to Berkeley by
// Paul Borman at Krystal Technologies.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)ctype.h	8.4 (Berkeley) 1/21/94

// Copyright (C) 1992-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

type Edit = struct {
	Start   Length
	Old_end Length
	New_end Length
} /* subtree.c:19:3 */

var empty_state = ExternalScannerState{} /* subtree.c:24:35 */

// ExternalScannerState

func Xts_external_scanner_state_init(tls *libc.TLS, self uintptr, data uintptr, length uint32) { /* subtree.c:28:6: */
	(*ExternalScannerState)(unsafe.Pointer(self)).Length = length
	if uint64(length) > uint64(unsafe.Sizeof([24]int8{})) {
		*(*uintptr)(unsafe.Pointer(self /* &.long_data */)) = ts_malloc_default(tls, uint64(length))
		libc.X__builtin___memcpy_chk(tls, *(*uintptr)(unsafe.Pointer(self)), data, uint64(length), libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(self)), 0))
	} else {
		libc.X__builtin___memcpy_chk(tls, self /* &.short_data */, data, uint64(length), libc.X__builtin_object_size(tls, self /* &.short_data */, 0))
	}
}

func Xts_external_scanner_state_copy(tls *libc.TLS, self uintptr) ExternalScannerState { /* subtree.c:38:22: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*ExternalScannerState)(unsafe.Pointer(bp /* result */)) = *(*ExternalScannerState)(unsafe.Pointer(self))
	if uint64((*ExternalScannerState)(unsafe.Pointer(self)).Length) > uint64(unsafe.Sizeof([24]int8{})) {
		*(*uintptr)(unsafe.Pointer(bp /* &result */ /* &.long_data */)) = ts_malloc_default(tls, uint64((*ExternalScannerState)(unsafe.Pointer(self)).Length))
		libc.X__builtin___memcpy_chk(tls, *(*uintptr)(unsafe.Pointer(bp /* &result */ /* &.long_data */)), *(*uintptr)(unsafe.Pointer(self)), uint64((*ExternalScannerState)(unsafe.Pointer(self)).Length), libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(bp /* &result */ /* &.long_data */)), 0))
	}
	return *(*ExternalScannerState)(unsafe.Pointer(bp /* result */))
}

func Xts_external_scanner_state_delete(tls *libc.TLS, self uintptr) { /* subtree.c:47:6: */
	if uint64((*ExternalScannerState)(unsafe.Pointer(self)).Length) > uint64(unsafe.Sizeof([24]int8{})) {
		ts_free_default(tls, *(*uintptr)(unsafe.Pointer(self)))
	}
}

func Xts_external_scanner_state_data(tls *libc.TLS, self uintptr) uintptr { /* subtree.c:53:12: */
	if uint64((*ExternalScannerState)(unsafe.Pointer(self)).Length) > uint64(unsafe.Sizeof([24]int8{})) {
		return *(*uintptr)(unsafe.Pointer(self))
	} else {
		return self /* &.short_data */
	}
	return uintptr(0)
}

func Xts_external_scanner_state_eq(tls *libc.TLS, a uintptr, b uintptr) uint8 { /* subtree.c:61:6: */
	return (uint8(libc.Bool32((a == b) || (((*ExternalScannerState)(unsafe.Pointer(a)).Length == (*ExternalScannerState)(unsafe.Pointer(b)).Length) && !(libc.Xmemcmp(tls, Xts_external_scanner_state_data(tls, a), Xts_external_scanner_state_data(tls, b), uint64((*ExternalScannerState)(unsafe.Pointer(a)).Length)) != 0)))))
}

// SubtreeArray

func Xts_subtree_array_copy(tls *libc.TLS, self SubtreeArray, dest uintptr) { /* subtree.c:70:6: */
	(*SubtreeArray)(unsafe.Pointer(dest)).Size = self.Size
	(*SubtreeArray)(unsafe.Pointer(dest)).Capacity = self.Capacity
	(*SubtreeArray)(unsafe.Pointer(dest)).Contents = self.Contents
	if self.Capacity > Uint32_t(0) {
		(*SubtreeArray)(unsafe.Pointer(dest)).Contents = ts_calloc_default(tls, uint64(self.Capacity), uint64(unsafe.Sizeof(Subtree{})))
		libc.X__builtin___memcpy_chk(tls, (*SubtreeArray)(unsafe.Pointer(dest)).Contents, self.Contents, (uint64(self.Size) * uint64(unsafe.Sizeof(Subtree{}))), libc.X__builtin_object_size(tls, (*SubtreeArray)(unsafe.Pointer(dest)).Contents, 0))
		{
			var i Uint32_t = Uint32_t(0)
		__1:
			if !(i < self.Size) {
				goto __3
			}
			{
				Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(dest)).Contents + uintptr(i)*16)))

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}
}

func Xts_subtree_array_clear(tls *libc.TLS, pool uintptr, self uintptr) { /* subtree.c:83:6: */
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < (*SubtreeArray)(unsafe.Pointer(self)).Size) {
			goto __3
		}
		{
			Xts_subtree_release(tls, pool, *(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(self)).Contents + uintptr(i)*16)))

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	(*SubtreeArray)(unsafe.Pointer(self)).Size = Uint32_t(0)
}

func Xts_subtree_array_delete(tls *libc.TLS, pool uintptr, self uintptr) { /* subtree.c:90:6: */
	Xts_subtree_array_clear(tls, pool, self)
	array__delete(tls, self)
}

func Xts_subtree_array_remove_trailing_extras(tls *libc.TLS, self uintptr, destination uintptr) { /* subtree.c:95:6: */
	(*SubtreeArray)(unsafe.Pointer(destination)).Size = Uint32_t(0)
	for (*SubtreeArray)(unsafe.Pointer(self)).Size > Uint32_t(0) {
		var last = *(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(self)).Contents + uintptr(((*SubtreeArray)(unsafe.Pointer(self)).Size-Uint32_t(1)))*16))
		if ts_subtree_extra(tls, last) != 0 {
			(*SubtreeArray)(unsafe.Pointer(self)).Size--
			array__grow(tls, destination, uint64(1), uint64(unsafe.Sizeof(Subtree{})))
			*(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer((destination))).Contents + uintptr(libc.PostIncUint32(&(*SubtreeArray)(unsafe.Pointer(destination)).Size, 1))*16)) = last
		} else {
			break
		}
	}
	Xts_subtree_array_reverse(tls, destination)
}

func Xts_subtree_array_reverse(tls *libc.TLS, self uintptr) { /* subtree.c:112:6: */
	{
		var i Uint32_t = Uint32_t(0)
		var limit Uint32_t = ((*SubtreeArray)(unsafe.Pointer(self)).Size / Uint32_t(2))
	__1:
		if !(i < limit) {
			goto __3
		}
		{
			var reverse_index Size_t = (Size_t(((*SubtreeArray)(unsafe.Pointer(self)).Size - Uint32_t(1)) - i))
			var swap = *(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(self)).Contents + uintptr(i)*16))
			*(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(self)).Contents + uintptr(i)*16)) = *(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(self)).Contents + uintptr(reverse_index)*16))
			*(*Subtree)(unsafe.Pointer((*SubtreeArray)(unsafe.Pointer(self)).Contents + uintptr(reverse_index)*16)) = swap

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
}

// SubtreePool

func Xts_subtree_pool_new(tls *libc.TLS, capacity Uint32_t) SubtreePool { /* subtree.c:123:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*SubtreePool)(unsafe.Pointer(bp /* self */)) = SubtreePool{}
	array__reserve(tls, (bp /* &self */ /* &.free_trees */), uint64(unsafe.Sizeof(MutableSubtree{})), capacity)
	return *(*SubtreePool)(unsafe.Pointer(bp /* self */))
}

func Xts_subtree_pool_delete(tls *libc.TLS, self uintptr) { /* subtree.c:129:6: */
	if (*SubtreePool)(unsafe.Pointer(self)).Free_trees.Contents != 0 {
		{
			var i uint32 = uint32(0)
		__1:
			if !(i < (*SubtreePool)(unsafe.Pointer(self)).Free_trees.Size) {
				goto __3
			}
			{
				ts_free_default(tls, *(*uintptr)(unsafe.Pointer((*SubtreePool)(unsafe.Pointer(self)).Free_trees.Contents + uintptr(i)*16)))

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
		array__delete(tls, (self /* &.free_trees */))
	}
	if (*SubtreePool)(unsafe.Pointer(self)).Tree_stack.Contents != 0 {
		array__delete(tls, (self + 16 /* &.tree_stack */))
	}
}

func ts_subtree_pool_allocate(tls *libc.TLS, self uintptr) uintptr { /* subtree.c:139:24: */
	if (*SubtreePool)(unsafe.Pointer(self)).Free_trees.Size > Uint32_t(0) {
		return *(*uintptr)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((self /* &.free_trees */))).Contents + uintptr(libc.PreDecUint32(&(*MutableSubtreeArray)(unsafe.Pointer((self /* &.free_trees */))).Size, 1))*16))
	} else {
		return ts_malloc_default(tls, uint64(unsafe.Sizeof(SubtreeHeapData{})))
	}
	return uintptr(0)
}

func ts_subtree_pool_free(tls *libc.TLS, self uintptr, tree uintptr) { /* subtree.c:147:13: */
	if ((*SubtreePool)(unsafe.Pointer(self)).Free_trees.Capacity > Uint32_t(0)) && (((*SubtreePool)(unsafe.Pointer(self)).Free_trees.Size + Uint32_t(1)) <= Uint32_t(TS_MAX_TREE_POOL_SIZE)) {
		array__grow(tls, (self /* &.free_trees */), uint64(1), uint64(unsafe.Sizeof(MutableSubtree{})))
		*(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((self /* &.free_trees */))).Contents + uintptr(libc.PostIncUint32(&(*MutableSubtreeArray)(unsafe.Pointer((self /* &.free_trees */))).Size, 1))*16)) = func() (r MutableSubtree) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = tree
			return r
		}()
	} else {
		ts_free_default(tls, tree)
	}
}

// Subtree

func ts_subtree_can_inline(tls *libc.TLS, padding Length, size Length, lookahead_bytes Uint32_t) uint8 { /* subtree.c:157:20: */
	return (uint8(libc.Bool32((((((padding.Bytes < Uint32_t(UINT8_MAX)) && (padding.Extent.Row < Uint32_t(16))) && (padding.Extent.Column < Uint32_t(UINT8_MAX))) && (size.Extent.Row == Uint32_t(0))) && (size.Extent.Column < Uint32_t(UINT8_MAX))) && (lookahead_bytes < Uint32_t(16)))))
}

func Xts_subtree_new_leaf(tls *libc.TLS, pool uintptr, symbol TSSymbol, padding Length, size Length, lookahead_bytes Uint32_t, parse_state TSStateId, has_external_tokens uint8, depends_on_column uint8, is_keyword uint8, language uintptr) Subtree { /* subtree.c:167:9: */
	var metadata = Xts_language_symbol_metadata(tls, language, symbol)
	var extra uint8 = (uint8(libc.Bool32(int32(symbol) == Ts_builtin_sym_end)))

	var is_inline uint8 = (uint8(libc.Bool32(((int32(symbol) <= UINT8_MAX) && !(has_external_tokens != 0)) && (ts_subtree_can_inline(tls, padding, size, lookahead_bytes) != 0))))

	if is_inline != 0 {
		return func() (r Subtree) {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) |= uint8(True) & 0x1
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) |= uint8(metadata.Visible) & 0x1 << 1
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) |= uint8(metadata.Named) & 0x1 << 2
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) |= uint8(extra) & 0x1 << 3
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) |= uint8(False) & 0x1 << 4
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) |= uint8(False) & 0x1 << 5
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) |= uint8(is_keyword) & 0x1 << 6
			*(*Uint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 2)) = Uint8_t(symbol)
			*(*Uint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 3)) = Uint8_t(padding.Bytes)
			*(*Uint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 4)) = Uint8_t(size.Bytes)
			*(*Uint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 5)) = Uint8_t(padding.Extent.Column)
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 6)) |= uint8(padding.Extent.Row) & 0xf
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 6)) |= uint8(lookahead_bytes) & 0xf << 4
			*(*Uint16_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 8)) = parse_state
			return r
		}()
	} else {
		var data uintptr = ts_subtree_pool_allocate(tls, pool)
		*(*SubtreeHeapData)(unsafe.Pointer(data)) = SubtreeHeapData{Ref_count: Uint32_t(1), Padding: padding, Size: size, Lookahead_bytes: lookahead_bytes, Symbol: symbol, Parse_state: parse_state, Visible: uint8(metadata.Visible)&0x1 | uint8(metadata.Named)&0x1<<1 | uint8(extra)&0x1<<2 | uint8(has_external_tokens)&0x1<<6 | uint8(depends_on_column)&0x1<<7, Is_missing: uint8(is_keyword) & 0x1 << 1}
		return func() (r Subtree) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = data
			return r
		}()
	}
	return Subtree{}
}

func Xts_subtree_set_symbol(tls *libc.TLS, self uintptr, symbol TSSymbol, language uintptr) { /* subtree.c:226:6: */
	var metadata = Xts_language_symbol_metadata(tls, language, symbol)
	if (uint8(int32(*(*uint8)(unsafe.Pointer(self /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(int32(symbol) < UINT8_MAX)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__108)), ts+4361 /* "upstream/tree-si..." */, 233, ts+4400 /* "symbol < 255" */)
		} else {
		}
		(*SubtreeInlineData)(unsafe.Pointer(self)).Symbol = Uint8_t(symbol)
		libc.SetBitFieldPtr8Uint8(self /* &.data */ /* &.named */, metadata.Named, 2, 0x4)
		libc.SetBitFieldPtr8Uint8(self /* &.data */ /* &.visible */, metadata.Visible, 1, 0x2)
	} else {
		(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* .Ptr */)))).Symbol = symbol
		libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(self /* .Ptr */))+44 /* &.named */, metadata.Named, 1, 0x2)
		libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(self /* .Ptr */))+44 /* &.visible */, metadata.Visible, 0, 0x1)
	}
}

var __func__108 = *(*[22]int8)(unsafe.Pointer(ts + 4413 /* "ts_subtree_set_s..." */)) /* subtree.c:230:3 */

func Xts_subtree_new_error(tls *libc.TLS, pool uintptr, lookahead_char Int32_t, padding Length, size Length, bytes_scanned Uint32_t, parse_state TSStateId, language uintptr) Subtree { /* subtree.c:244:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Subtree)(unsafe.Pointer(bp /* result */)) = Xts_subtree_new_leaf(tls,
		pool, libc.Uint16(libc.Uint16FromInt32(-1)), padding, size, bytes_scanned,
		parse_state, uint8(False), uint8(False), uint8(False), language)
	var data uintptr = *(*uintptr)(unsafe.Pointer(bp /* &result */))
	libc.SetBitFieldPtr8Uint8(data+44 /* &.fragile_left */, uint8(True), 3, 0x8)
	libc.SetBitFieldPtr8Uint8(data+44 /* &.fragile_right */, uint8(True), 4, 0x10)
	*(*Int32_t)(unsafe.Pointer(data + 48 /* &.lookahead_char */)) = lookahead_char
	return *(*Subtree)(unsafe.Pointer(bp /* result */))
}

// Clone a subtree.
func Xts_subtree_clone(tls *libc.TLS, self Subtree) MutableSubtree { /* subtree.c:260:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	var alloc_size Size_t = ts_subtree_alloc_size(tls, (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count)
	var new_children uintptr = ts_malloc_default(tls, alloc_size)
	var old_children uintptr = func() uintptr {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return uintptr(0)
		}
		return ((*(*uintptr)(unsafe.Pointer(bp /* &self */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count)*16)
	}()
	libc.X__builtin___memcpy_chk(tls, new_children, old_children, alloc_size, libc.X__builtin_object_size(tls, new_children, 0))
	var result uintptr = (new_children + uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count)*16)
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count > Uint32_t(0) {
		{
			var i Uint32_t = Uint32_t(0)
		__1:
			if !(i < (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count) {
				goto __3
			}
			{
				Xts_subtree_retain(tls, *(*Subtree)(unsafe.Pointer(new_children + uintptr(i)*16)))

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	} else if (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.has_external_tokens */)) & 0x40 >> 6))) != 0 {
		*(*ExternalScannerState)(unsafe.Pointer(result + 48 /* &.external_scanner_state */)) = Xts_external_scanner_state_copy(tls,
			(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48 /* &.external_scanner_state */))
	}
	(*SubtreeHeapData)(unsafe.Pointer(result)).Ref_count = Uint32_t(1)
	return func() (r MutableSubtree) {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = result
		return r
	}()
}

// Get mutable version of a subtree.
//
// This takes ownership of the subtree. If the subtree has only one owner,
// this will directly convert it into a mutable version. Otherwise, it will
// perform a copy.
func Xts_subtree_make_mut(tls *libc.TLS, pool uintptr, self Subtree) MutableSubtree { /* subtree.c:284:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return func() (r MutableSubtree) {
			*(*SubtreeInlineData)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = *(*SubtreeInlineData)(unsafe.Pointer(bp /* &self */))
			return r
		}()
	}
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Ref_count == Uint32_t(1) {
		return ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer(bp /* self */)))
	}
	var result = Xts_subtree_clone(tls, *(*Subtree)(unsafe.Pointer(bp /* self */)))
	Xts_subtree_release(tls, pool, *(*Subtree)(unsafe.Pointer(bp /* self */)))
	return result
}

func ts_subtree__compress(tls *libc.TLS, self MutableSubtree, count uint32, language uintptr, stack uintptr) { /* subtree.c:292:13: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var initial_stack_size uint32 = (*MutableSubtreeArray)(unsafe.Pointer(stack)).Size

	*(*MutableSubtree)(unsafe.Pointer(bp /* tree */)) = self
	var symbol TSSymbol = (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Symbol
	{
		var i uint32 = uint32(0)
	__1:
		if !(i < count) {
			goto __3
		}
		{
			if ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Ref_count > Uint32_t(1)) || ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count < Uint32_t(2)) {
				goto __3
			}

			*(*MutableSubtree)(unsafe.Pointer(bp + 16 /* child */)) = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count)*16)
			}()))))
			if ((((uint8(int32(*(*uint8)(unsafe.Pointer((bp + 16 /* &child */ /* &.data */) /* &.is_inline */)) & 0x1 >> 0))) != 0) || ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)))).Child_count < Uint32_t(2))) || ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)))).Ref_count > Uint32_t(1))) || (int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)))).Symbol) != int32(symbol)) {
				goto __3
			}

			*(*MutableSubtree)(unsafe.Pointer(bp + 32 /* grandchild */)) = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &child */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)))).Child_count)*16)
			}()))))
			if ((((uint8(int32(*(*uint8)(unsafe.Pointer((bp + 32 /* &grandchild */ /* &.data */) /* &.is_inline */)) & 0x1 >> 0))) != 0) || ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */)))).Child_count < Uint32_t(2))) || ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */)))).Ref_count > Uint32_t(1))) || (int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */)))).Symbol) != int32(symbol)) {
				goto __3
			}

			*(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count)*16)
			}()))) = ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 32 /* grandchild */)))
			*(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &child */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)))).Child_count)*16)
			}()))) = *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &grandchild */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */)))).Child_count)*16)
			}()) + uintptr(((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */)))).Child_count-Uint32_t(1)))*16))
			*(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &grandchild */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */)))).Child_count)*16)
			}()) + uintptr(((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &grandchild */)))).Child_count-Uint32_t(1)))*16)) = ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 16 /* child */)))
			array__grow(tls, stack, uint64(1), uint64(unsafe.Sizeof(MutableSubtree{})))
			*(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((stack))).Contents + uintptr(libc.PostIncUint32(&(*MutableSubtreeArray)(unsafe.Pointer(stack)).Size, 1))*16)) = *(*MutableSubtree)(unsafe.Pointer(bp /* tree */))
			*(*MutableSubtree)(unsafe.Pointer(bp /* tree */)) = *(*MutableSubtree)(unsafe.Pointer(bp + 32 /* grandchild */))

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	for (*MutableSubtreeArray)(unsafe.Pointer(stack)).Size > initial_stack_size {
		*(*MutableSubtree)(unsafe.Pointer(bp /* tree */)) = *(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((stack))).Contents + uintptr(libc.PreDecUint32(&(*MutableSubtreeArray)(unsafe.Pointer(stack)).Size, 1))*16))
		*(*MutableSubtree)(unsafe.Pointer(bp + 48 /* child */)) = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer((func() uintptr {
			if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
				return uintptr(0)
			}
			return ((*(*uintptr)(unsafe.Pointer(bp /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count)*16)
		}()))))
		var grandchild = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer((func() uintptr {
			if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 48 /* &child */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
				return uintptr(0)
			}
			return ((*(*uintptr)(unsafe.Pointer(bp + 48 /* &child */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* &child */)))).Child_count)*16)
		}()) + uintptr(((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* &child */)))).Child_count-Uint32_t(1)))*16)))
		Xts_subtree_summarize_children(tls, grandchild, language)
		Xts_subtree_summarize_children(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 48 /* child */)), language)
		Xts_subtree_summarize_children(tls, *(*MutableSubtree)(unsafe.Pointer(bp /* tree */)), language)
	}
}

func Xts_subtree_balance(tls *libc.TLS, self Subtree, pool uintptr, language uintptr) { /* subtree.c:338:6: */
	bp := tls.Alloc(48)
	defer tls.Free(48)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	(*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Size = Uint32_t(0)

	if (ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* self */))) > Uint32_t(0)) && ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Ref_count == Uint32_t(1)) {
		array__grow(tls, (pool + 16 /* &.tree_stack */), uint64(1), uint64(unsafe.Sizeof(MutableSubtree{})))
		*(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Contents + uintptr(libc.PostIncUint32(&(*MutableSubtreeArray)(unsafe.Pointer((pool+16 /* &.tree_stack */))).Size, 1))*16)) = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer(bp /* self */)))
	}

	for (*SubtreePool)(unsafe.Pointer(pool)).Tree_stack.Size > Uint32_t(0) {
		*(*MutableSubtree)(unsafe.Pointer(bp + 16 /* tree */)) = *(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Contents + uintptr(libc.PreDecUint32(&(*MutableSubtreeArray)(unsafe.Pointer((pool+16 /* &.tree_stack */))).Size, 1))*16))

		if *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)) + 60)) > Uint32_t(0) {
			var child1 = *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count)*16)
			}())))
			var child2 = *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count)*16)
			}()) + uintptr(((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count-Uint32_t(1)))*16))
			var repeat_delta int64 = (int64(ts_subtree_repeat_depth(tls, child1)) - int64(ts_subtree_repeat_depth(tls, child2)))
			if repeat_delta > int64(0) {
				var n uint32 = uint32(repeat_delta)
				{
					var i uint32 = (n / uint32(2))
				__1:
					if !(i > uint32(0)) {
						goto __3
					}
					{
						ts_subtree__compress(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 16 /* tree */)), i, language, (pool + 16 /* &.tree_stack */))
						n = n - (i)

					}
					goto __2
				__2:
					i = i / (uint32(2))
					goto __1
					goto __3
				__3:
					;
				}
			}
		}

		{
			var i Uint32_t = Uint32_t(0)
		__4:
			if !(i < (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count) {
				goto __6
			}
			{
				*(*Subtree)(unsafe.Pointer(bp + 32 /* child */)) = *(*Subtree)(unsafe.Pointer((func() uintptr {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						return uintptr(0)
					}
					return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count)*16)
				}()) + uintptr(i)*16))
				if (ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 32 /* child */))) > Uint32_t(0)) && ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &child */)))).Ref_count == Uint32_t(1)) {
					array__grow(tls, (pool + 16 /* &.tree_stack */), uint64(1), uint64(unsafe.Sizeof(MutableSubtree{})))
					*(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Contents + uintptr(libc.PostIncUint32(&(*MutableSubtreeArray)(unsafe.Pointer((pool+16 /* &.tree_stack */))).Size, 1))*16)) = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer(bp + 32 /* child */)))
				}

			}
			goto __5
		__5:
			i++
			goto __4
			goto __6
		__6:
			;
		}
	}
}

// Assign all of the node's properties that depend on its children.
func Xts_subtree_summarize_children(tls *libc.TLS, self MutableSubtree, language uintptr) { /* subtree.c:371:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*MutableSubtree)(unsafe.Pointer(bp)) = self

	if libc.X__builtin_expect(tls, libc.BoolInt64(!(!((int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0)) != 0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__109)), ts+4361 /* "upstream/tree-si..." */, 375, ts+4435 /* "!self.data.is_in..." */)
	} else {
	}

	*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 52 /* &.named_child_count */)) = Uint32_t(0)
	*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48 /* &.visible_child_count */)) = Uint32_t(0)
	(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Error_cost = Uint32_t(0)
	*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 60 /* &.repeat_depth */)) = Uint32_t(0)
	*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 56 /* &.node_count */)) = Uint32_t(1)
	libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.has_external_tokens */, uint8(False), 6, 0x40)
	libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.depends_on_column */, uint8(False), 7, 0x80)
	*(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 64 /* &.dynamic_precedence */)) = 0

	var structural_index Uint32_t = Uint32_t(0)
	var alias_sequence uintptr = ts_language_alias_sequence(tls, language, uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 68))))
	var lookahead_end_byte Uint32_t = Uint32_t(0)

	var children uintptr = func() uintptr {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return uintptr(0)
		}
		return ((*(*uintptr)(unsafe.Pointer(bp /* &self */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count)*16)
	}()
	{
		var i Uint32_t = Uint32_t(0)
	__1:
		if !(i < (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count) {
			goto __3
		}
		{
			*(*Subtree)(unsafe.Pointer(bp + 16 /* child */)) = *(*Subtree)(unsafe.Pointer(children + uintptr(i)*16))

			if ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size.Extent.Row == Uint32_t(0)) && (ts_subtree_depends_on_column(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0) {
				libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.depends_on_column */, uint8(True), 7, 0x80)
			}

			if i == Uint32_t(0) {
				(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Padding = ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */)))
				(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size = ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */)))
			} else {
				(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size = length_add(tls, (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size, ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))))
			}

			var child_lookahead_end_byte Uint32_t = (((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Padding.Bytes + (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size.Bytes) + ts_subtree_lookahead_bytes(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))))
			if child_lookahead_end_byte > lookahead_end_byte {
				lookahead_end_byte = child_lookahead_end_byte
			}

			if int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */)))) != ((int32(libc.Uint16FromInt32(-1))) - 1) {
				*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 32 /* &.error_cost */)) += (ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))))
			}

			var grandchild_count Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */)))
			if (int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol) == (int32(libc.Uint16FromInt32(-1)))) || (int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol) == ((int32(libc.Uint16FromInt32(-1))) - 1)) {
				if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0) && !((ts_subtree_is_error(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0) && (grandchild_count == Uint32_t(0))) {
					if ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0 {
						*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 32 /* &.error_cost */)) += (Uint32_t(ERROR_COST_PER_SKIPPED_TREE))
					} else if grandchild_count > Uint32_t(0) {
						*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 32 /* &.error_cost */)) += (Uint32_t(ERROR_COST_PER_SKIPPED_TREE) * *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)) + 48)))
					}
				}
			}

			*(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 64 /* &.dynamic_precedence */)) += (ts_subtree_dynamic_precedence(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))))
			*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 56 /* &.node_count */)) += (ts_subtree_node_count(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))))

			if ((alias_sequence != 0) && (int32(*(*TSSymbol)(unsafe.Pointer(alias_sequence + uintptr(structural_index)*2))) != 0)) && !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0) {
				*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48 /* &.visible_child_count */))++
				if Xts_language_symbol_metadata(tls, language, *(*TSSymbol)(unsafe.Pointer(alias_sequence + uintptr(structural_index)*2))).Named != 0 {
					*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 52 /* &.named_child_count */))++
				}
			} else if ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0 {
				*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48 /* &.visible_child_count */))++
				if ts_subtree_named(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0 {
					*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 52 /* &.named_child_count */))++
				}
			} else if grandchild_count > Uint32_t(0) {
				*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48 /* &.visible_child_count */)) += (*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)) + 48)))
				*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 52 /* &.named_child_count */)) += (*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &child */)) + 52)))
			}

			if ts_subtree_has_external_tokens(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0 {
				libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.has_external_tokens */, uint8(True), 6, 0x40)
			}

			if ts_subtree_is_error(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0 {
				libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.fragile_left */, libc.AssignBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.fragile_right */, uint8(True), 1, 4, 0x10), 3, 0x8)
				(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Parse_state = (TSStateId((0x7fff * 2) + 1))
			}

			if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* child */))) != 0) {
				structural_index++
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Lookahead_bytes = ((lookahead_end_byte - (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size.Bytes) - (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Padding.Bytes)

	if (int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol) == (int32(libc.Uint16FromInt32(-1)))) || (int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol) == ((int32(libc.Uint16FromInt32(-1))) - 1)) {
		*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 32 /* &.error_cost */)) += ((Uint32_t(ERROR_COST_PER_RECOVERY) + (Uint32_t(ERROR_COST_PER_SKIPPED_CHAR) * (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size.Bytes)) + (Uint32_t(ERROR_COST_PER_SKIPPED_LINE) * (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size.Extent.Row))
	}

	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count > Uint32_t(0) {
		var first_child = *(*Subtree)(unsafe.Pointer(children))
		var last_child = *(*Subtree)(unsafe.Pointer(children + uintptr(((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count-Uint32_t(1)))*16))

		*(*TSSymbol)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 70 /* &.first_leaf */ /* &.symbol */)) = ts_subtree_leaf_symbol(tls, first_child)
		*(*TSStateId)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 70 /* &.first_leaf */ + 2 /* &.parse_state */)) = ts_subtree_leaf_parse_state(tls, first_child)

		if ts_subtree_fragile_left(tls, first_child) != 0 {
			libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.fragile_left */, uint8(True), 3, 0x8)
		}
		if ts_subtree_fragile_right(tls, last_child) != 0 {
			libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &self */))+44 /* &.fragile_right */, uint8(True), 4, 0x10)
		}

		if ((((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count >= Uint32_t(2)) && !((int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.visible */)) & 0x1 >> 0)) != 0)) && !((int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.named */)) & 0x2 >> 1)) != 0)) && (int32(ts_subtree_symbol(tls, first_child)) == int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol)) {
			if ts_subtree_repeat_depth(tls, first_child) > ts_subtree_repeat_depth(tls, last_child) {
				*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 60 /* &.repeat_depth */)) = (ts_subtree_repeat_depth(tls, first_child) + Uint32_t(1))
			} else {
				*(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 60 /* &.repeat_depth */)) = (ts_subtree_repeat_depth(tls, last_child) + Uint32_t(1))
			}
		}
	}
}

var __func__109 = *(*[30]int8)(unsafe.Pointer(ts + 4456 /* "ts_subtree_summa..." */)) /* subtree.c:374:3 */

// Create a new parent node with the given children.
//
// This takes ownership of the children array.
func Xts_subtree_new_node(tls *libc.TLS, symbol TSSymbol, children uintptr, production_id uint32, language uintptr) MutableSubtree { /* subtree.c:492:16: */
	var metadata = Xts_language_symbol_metadata(tls, language, symbol)
	var fragile uint8 = (uint8(libc.Bool32((int32(symbol) == (int32(libc.Uint16FromInt32(-1)))) || (int32(symbol) == ((int32(libc.Uint16FromInt32(-1))) - 1)))))

	// Allocate the node's data at the end of the array of children.
	var new_byte_size Size_t = ts_subtree_alloc_size(tls, (*SubtreeArray)(unsafe.Pointer(children)).Size)
	if (uint64((*SubtreeArray)(unsafe.Pointer(children)).Capacity) * uint64(unsafe.Sizeof(Subtree{}))) < new_byte_size {
		(*SubtreeArray)(unsafe.Pointer(children)).Contents = ts_realloc_default(tls, (*SubtreeArray)(unsafe.Pointer(children)).Contents, new_byte_size)
		(*SubtreeArray)(unsafe.Pointer(children)).Capacity = (Uint32_t(new_byte_size / Size_t(unsafe.Sizeof(Subtree{}))))
	}
	var data uintptr = ((*SubtreeArray)(unsafe.Pointer(children)).Contents + uintptr((*SubtreeArray)(unsafe.Pointer(children)).Size)*16)

	*(*SubtreeHeapData)(unsafe.Pointer(data)) = SubtreeHeapData{Ref_count: Uint32_t(1), Child_count: (*SubtreeArray)(unsafe.Pointer(children)).Size, Symbol: symbol, Visible: uint8(metadata.Visible)&0x1 | uint8(metadata.Named)&0x1<<1 | uint8(fragile)&0x1<<3 | uint8(fragile)&0x1<<4, X__48: func() (r struct {
		_    [0]uint64
		X__0 struct {
			Visible_child_count Uint32_t
			Named_child_count   Uint32_t
			Node_count          Uint32_t
			Repeat_depth        Uint32_t
			Dynamic_precedence  Int32_t
			Production_id       Uint16_t
			First_leaf          struct {
				Symbol      TSSymbol
				Parse_state TSStateId
			}
			__ccgo_pad1 [2]byte
		}
		_ [4]byte
	}) { *(*Uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 8)) = Uint32_t(0); *(*Uint16_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 20)) = Uint16_t(production_id); *(*TSSymbol)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 22)) = TSSymbol(0); *(*TSStateId)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 24)) = TSStateId(0); return r }()}
	var result = func() (r MutableSubtree) {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = data
		return r
	}()
	Xts_subtree_summarize_children(tls, result, language)
	return result
}

// Create a new error node contaning the given children.
//
// This node is treated as 'extra'. Its children are prevented from having
// having any effect on the parse state.
func Xts_subtree_new_error_node(tls *libc.TLS, children uintptr, extra uint8, language uintptr) Subtree { /* subtree.c:534:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*MutableSubtree)(unsafe.Pointer(bp /* result */)) = Xts_subtree_new_node(tls,
		libc.Uint16(libc.Uint16FromInt32(-1)), children, uint32(0), language)
	libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &result */))+44 /* &.extra */, extra, 2, 0x4)
	return ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp /* result */)))
}

// Create a new 'missing leaf' node.
//
// This node is treated as 'extra'. Its children are prevented from having
// having any effect on the parse state.
func Xts_subtree_new_missing_leaf(tls *libc.TLS, pool uintptr, symbol TSSymbol, padding Length, language uintptr) Subtree { /* subtree.c:550:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Subtree)(unsafe.Pointer(bp /* result */)) = Xts_subtree_new_leaf(tls,
		pool, symbol, padding, length_zero(tls), uint32(0),
		uint16(0), uint8(False), uint8(False), uint8(False), language)
	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &result */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		libc.SetBitFieldPtr8Uint8(bp /* &result */ /* &.data */ /* &.is_missing */, uint8(True), 5, 0x20)
	} else {
		libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(bp /* &result */))+45 /* &.is_missing */, uint8(True), 0, 0x1)
	}
	return *(*Subtree)(unsafe.Pointer(bp /* result */))
}

func Xts_subtree_retain(tls *libc.TLS, self Subtree) { /* subtree.c:568:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Ref_count > Uint32_t(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__110)), ts+4361 /* "upstream/tree-si..." */, 570, ts+4486 /* "self.ptr->ref_co..." */)
	} else {
	}
	atomic_inc(tls, (*(*uintptr)(unsafe.Pointer(bp /* &self */)) /* &.ref_count */))
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Ref_count != Uint32_t(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__110)), ts+4361 /* "upstream/tree-si..." */, 572, ts+4510 /* "self.ptr->ref_co..." */)
	} else {
	}
}

var __func__110 = *(*[18]int8)(unsafe.Pointer(ts + 4535 /* "ts_subtree_retai..." */)) /* subtree.c:568:38 */

func Xts_subtree_release(tls *libc.TLS, pool uintptr, self Subtree) { /* subtree.c:575:6: */
	bp := tls.Alloc(48)
	defer tls.Free(48)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		return
	}
	(*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Size = Uint32_t(0)

	if libc.X__builtin_expect(tls, libc.BoolInt64(!((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Ref_count > Uint32_t(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__111)), ts+4361 /* "upstream/tree-si..." */, 579, ts+4486 /* "self.ptr->ref_co..." */)
	} else {
	}
	if atomic_dec(tls, (*(*uintptr)(unsafe.Pointer(bp /* &self */)) /* &.ref_count */)) == Uint32_t(0) {
		array__grow(tls, (pool + 16 /* &.tree_stack */), uint64(1), uint64(unsafe.Sizeof(MutableSubtree{})))
		*(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Contents + uintptr(libc.PostIncUint32(&(*MutableSubtreeArray)(unsafe.Pointer((pool+16 /* &.tree_stack */))).Size, 1))*16)) = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer(bp /* self */)))
	}

	for (*SubtreePool)(unsafe.Pointer(pool)).Tree_stack.Size > Uint32_t(0) {
		*(*MutableSubtree)(unsafe.Pointer(bp + 16 /* tree */)) = *(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Contents + uintptr(libc.PreDecUint32(&(*MutableSubtreeArray)(unsafe.Pointer((pool+16 /* &.tree_stack */))).Size, 1))*16))
		if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count > Uint32_t(0) {
			var children uintptr = func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count)*16)
			}()
			{
				var i Uint32_t = Uint32_t(0)
			__1:
				if !(i < (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))).Child_count) {
					goto __3
				}
				{
					*(*Subtree)(unsafe.Pointer(bp + 32 /* child */)) = *(*Subtree)(unsafe.Pointer(children + uintptr(i)*16))
					if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &child */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						goto __2
					}
					if libc.X__builtin_expect(tls, libc.BoolInt64(!((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &child */)))).Ref_count > Uint32_t(0))), int64(0)) != 0 {
						libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__111)), ts+4361 /* "upstream/tree-si..." */, 591, ts+4553 /* "child.ptr->ref_c..." */)
					} else {
					}
					if atomic_dec(tls, (*(*uintptr)(unsafe.Pointer(bp + 32 /* &child */)) /* &.ref_count */)) == Uint32_t(0) {
						array__grow(tls, (pool + 16 /* &.tree_stack */), uint64(1), uint64(unsafe.Sizeof(MutableSubtree{})))
						*(*MutableSubtree)(unsafe.Pointer((*MutableSubtreeArray)(unsafe.Pointer((pool + 16 /* &.tree_stack */))).Contents + uintptr(libc.PostIncUint32(&(*MutableSubtreeArray)(unsafe.Pointer((pool+16 /* &.tree_stack */))).Size, 1))*16)) = ts_subtree_to_mut_unsafe(tls, *(*Subtree)(unsafe.Pointer(bp + 32 /* child */)))
					}

				}
				goto __2
			__2:
				i++
				goto __1
				goto __3
			__3:
				;
			}
			ts_free_default(tls, children)
		} else {
			if (uint8(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)) + 44 /* &.has_external_tokens */)) & 0x40 >> 6))) != 0 {
				Xts_external_scanner_state_delete(tls, (*(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)) + 48 /* &.external_scanner_state */))
			}
			ts_subtree_pool_free(tls, pool, *(*uintptr)(unsafe.Pointer(bp + 16 /* &tree */)))
		}
	}
}

var __func__111 = *(*[19]int8)(unsafe.Pointer(ts + 4578 /* "ts_subtree_relea..." */)) /* subtree.c:575:58 */

func Xts_subtree_eq(tls *libc.TLS, self Subtree, other Subtree) uint8 { /* subtree.c:606:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	*(*Subtree)(unsafe.Pointer(bp + 16)) = other

	if ((uint8(int32(*(*uint8)(unsafe.Pointer((bp /* &self */ /* &.data */) /* &.is_inline */)) & 0x1 >> 0))) != 0) || ((uint8(int32(*(*uint8)(unsafe.Pointer((bp + 16 /* &other */ /* &.data */) /* &.is_inline */)) & 0x1 >> 0))) != 0) {
		return (uint8(libc.Bool32(libc.Xmemcmp(tls, bp /* &self */, bp+16 /* &other */, uint64(unsafe.Sizeof(SubtreeInlineData{}))) == 0)))
	}

	if *(*uintptr)(unsafe.Pointer(bp /* &self */)) != 0 {
		if !(int32(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */))) != 0) {
			return uint8(False)
		}
	} else {
		return libc.BoolUint8(!(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) != 0))
	}

	if int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol) != int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)))).Symbol) {
		return uint8(False)
	}
	if (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.visible */)) & 0x1 >> 0)) != (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) + 44 /* &.visible */)) & 0x1 >> 0)) {
		return uint8(False)
	}
	if (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 44 /* &.named */)) & 0x2 >> 1)) != (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) + 44 /* &.named */)) & 0x2 >> 1)) {
		return uint8(False)
	}
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Padding.Bytes != (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)))).Padding.Bytes {
		return uint8(False)
	}
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Size.Bytes != (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)))).Size.Bytes {
		return uint8(False)
	}
	if int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Symbol) == (int32(libc.Uint16FromInt32(-1))) {
		return (uint8(libc.Bool32(*(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48)) == *(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) + 48)))))
	}
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count != (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)))).Child_count {
		return uint8(False)
	}
	if (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count > Uint32_t(0) {
		if *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48)) != *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) + 48)) {
			return uint8(False)
		}
		if *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 52)) != *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) + 52)) {
			return uint8(False)
		}

		{
			var i Uint32_t = Uint32_t(0)
		__1:
			if !(i < (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count) {
				goto __3
			}
			{
				if !(Xts_subtree_eq(tls, *(*Subtree)(unsafe.Pointer((func() uintptr {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						return uintptr(0)
					}
					return ((*(*uintptr)(unsafe.Pointer(bp /* &self */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count)*16)
				}()) + uintptr(i)*16)), *(*Subtree)(unsafe.Pointer((func() uintptr {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &other */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						return uintptr(0)
					}
					return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)))).Child_count)*16)
				}()) + uintptr(i)*16))) != 0) {
					return uint8(False)
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}
	return uint8(True)
}

func Xts_subtree_compare(tls *libc.TLS, left Subtree, right Subtree) int32 { /* subtree.c:637:5: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*Subtree)(unsafe.Pointer(bp)) = left
	*(*Subtree)(unsafe.Pointer(bp + 16)) = right

	if int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp /* left */)))) < int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */)))) {
		return -1
	}
	if int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */)))) < int32(ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp /* left */)))) {
		return 1
	}
	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* left */))) < ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))) {
		return -1
	}
	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* right */))) < ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* left */))) {
		return 1
	}
	{
		var i Uint32_t = Uint32_t(0)
		var n Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* left */)))
	__1:
		if !(i < n) {
			goto __3
		}
		{
			var left_child = *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &left */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp /* &left */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &left */)))).Child_count)*16)
			}()) + uintptr(i)*16))
			var right_child = *(*Subtree)(unsafe.Pointer((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 16 /* &right */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &right */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &right */)))).Child_count)*16)
			}()) + uintptr(i)*16))
			switch Xts_subtree_compare(tls, left_child, right_child) {
			case -1:
				return -1
			case 1:
				return 1
			default:
				break
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
	return 0
}

func ts_subtree_set_has_changes(tls *libc.TLS, self uintptr) { /* subtree.c:654:20: */
	if (uint8(int32(*(*uint8)(unsafe.Pointer(self /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
		libc.SetBitFieldPtr8Uint8(self /* &.data */ /* &.has_changes */, uint8(True), 4, 0x10)
	} else {
		libc.SetBitFieldPtr8Uint8(*(*uintptr)(unsafe.Pointer(self /* .Ptr */))+44 /* &.has_changes */, uint8(True), 5, 0x20)
	}
}

func Xts_subtree_edit(tls *libc.TLS, self Subtree, edit uintptr, pool uintptr) Subtree { /* subtree.c:662:9: */
	bp := tls.Alloc(48)
	defer tls.Free(48)
	*(*Subtree)(unsafe.Pointer(bp + 16)) = self

	*(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp /* stack */)) = struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	}{}
	array__grow(tls, bp /* &stack */, uint64(1), uint64(unsafe.Sizeof(struct {
		Tree        uintptr
		Edit        Edit
		__ccgo_pad1 [4]byte
	}{})))
	*(*struct {
		Tree        uintptr
		Edit        Edit
		__ccgo_pad1 [4]byte
	})(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((bp /* &stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp /* &stack */)).Size, 1))*48)) = struct {
		Tree        uintptr
		Edit        Edit
		__ccgo_pad1 [4]byte
	}{Tree: bp + 16 /* &self */, Edit: Edit{Start: Length{Bytes: (*TSInputEdit)(unsafe.Pointer(edit)).Start_byte, Extent: (*TSInputEdit)(unsafe.Pointer(edit)).Start_point}, Old_end: Length{Bytes: (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_byte, Extent: (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_point}, New_end: Length{Bytes: (*TSInputEdit)(unsafe.Pointer(edit)).New_end_byte, Extent: (*TSInputEdit)(unsafe.Pointer(edit)).New_end_point}}}

	for (*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer(bp /* &stack */)).Size != 0 {
		var entry = *(*struct {
			Tree        uintptr
			Edit        Edit
			__ccgo_pad1 [4]byte
		})(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((bp /* &stack */))).Contents + uintptr(libc.PreDecUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer(bp /* &stack */)).Size, 1))*48))
		var edit = entry.Edit
		var is_noop uint8 = (uint8(libc.Bool32((edit.Old_end.Bytes == edit.Start.Bytes) && (edit.New_end.Bytes == edit.Start.Bytes))))
		var is_pure_insertion uint8 = (uint8(libc.Bool32(edit.Old_end.Bytes == edit.Start.Bytes)))
		var invalidate_first_row uint8 = ts_subtree_depends_on_column(tls, *(*Subtree)(unsafe.Pointer(entry.Tree)))

		var size = ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(entry.Tree)))
		var padding = ts_subtree_padding(tls, *(*Subtree)(unsafe.Pointer(entry.Tree)))
		var lookahead_bytes Uint32_t = ts_subtree_lookahead_bytes(tls, *(*Subtree)(unsafe.Pointer(entry.Tree)))
		var end_byte Uint32_t = ((padding.Bytes + size.Bytes) + lookahead_bytes)
		if (edit.Start.Bytes > end_byte) || ((is_noop != 0) && (edit.Start.Bytes == end_byte)) {
			continue
		}

		// If the edit is entirely within the space before this subtree, then shift this
		// subtree over according to the edit without changing its size.
		if edit.Old_end.Bytes <= padding.Bytes {
			padding = length_add(tls, edit.New_end, length_sub(tls, padding, edit.Old_end))
		} else if edit.Start.Bytes < padding.Bytes {
			size = length_sub(tls, size, length_sub(tls, edit.Old_end, padding))
			padding = edit.New_end
		} else if (edit.Start.Bytes == padding.Bytes) && (is_pure_insertion != 0) {
			padding = edit.New_end
		} else {
			var total_bytes Uint32_t = (padding.Bytes + size.Bytes)
			if (edit.Start.Bytes < total_bytes) || ((edit.Start.Bytes == total_bytes) && (is_pure_insertion != 0)) {
				size = length_add(tls,
					length_sub(tls, edit.New_end, padding),
					length_sub(tls, size, length_sub(tls, edit.Old_end, padding)))
			}
		}

		*(*MutableSubtree)(unsafe.Pointer(bp + 32 /* result */)) = Xts_subtree_make_mut(tls, pool, *(*Subtree)(unsafe.Pointer(entry.Tree)))

		if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &result */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			if ts_subtree_can_inline(tls, padding, size, lookahead_bytes) != 0 {
				(*SubtreeInlineData)(unsafe.Pointer(bp + 32 /* &result */)).Padding_bytes = Uint8_t(padding.Bytes)
				libc.SetBitFieldPtr8Uint8(bp+32 /* &result */ /* &.data */ +6 /* &.padding_rows */, Uint8_t(padding.Extent.Row), 0, 0xf)
				(*SubtreeInlineData)(unsafe.Pointer(bp + 32 /* &result */)).Padding_columns = Uint8_t(padding.Extent.Column)
				(*SubtreeInlineData)(unsafe.Pointer(bp + 32 /* &result */)).Size_bytes = Uint8_t(size.Bytes)
			} else {
				var data uintptr = ts_subtree_pool_allocate(tls, pool)
				(*SubtreeHeapData)(unsafe.Pointer(data)).Ref_count = Uint32_t(1)
				(*SubtreeHeapData)(unsafe.Pointer(data)).Padding = padding
				(*SubtreeHeapData)(unsafe.Pointer(data)).Size = size
				(*SubtreeHeapData)(unsafe.Pointer(data)).Lookahead_bytes = lookahead_bytes
				(*SubtreeHeapData)(unsafe.Pointer(data)).Error_cost = Uint32_t(0)
				(*SubtreeHeapData)(unsafe.Pointer(data)).Child_count = Uint32_t(0)
				(*SubtreeHeapData)(unsafe.Pointer(data)).Symbol = TSSymbol((*SubtreeInlineData)(unsafe.Pointer(bp + 32 /* &result */)).Symbol)
				(*SubtreeHeapData)(unsafe.Pointer(data)).Parse_state = (*SubtreeInlineData)(unsafe.Pointer(bp + 32 /* &result */)).Parse_state
				libc.SetBitFieldPtr8Uint8(data+44 /* &.visible */, (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &result */ /* &.data */ /* &.visible */)) & 0x2 >> 1))), 0, 0x1)
				libc.SetBitFieldPtr8Uint8(data+44 /* &.named */, (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &result */ /* &.data */ /* &.named */)) & 0x4 >> 2))), 1, 0x2)
				libc.SetBitFieldPtr8Uint8(data+44 /* &.extra */, (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &result */ /* &.data */ /* &.extra */)) & 0x8 >> 3))), 2, 0x4)
				libc.SetBitFieldPtr8Uint8(data+44 /* &.fragile_left */, uint8(False), 3, 0x8)
				libc.SetBitFieldPtr8Uint8(data+44 /* &.fragile_right */, uint8(False), 4, 0x10)
				libc.SetBitFieldPtr8Uint8(data+44 /* &.has_changes */, uint8(False), 5, 0x20)
				libc.SetBitFieldPtr8Uint8(data+44 /* &.has_external_tokens */, uint8(False), 6, 0x40)
				libc.SetBitFieldPtr8Uint8(data+44 /* &.depends_on_column */, uint8(False), 7, 0x80)
				libc.SetBitFieldPtr8Uint8(data+45 /* &.is_missing */, (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &result */ /* &.data */ /* &.is_missing */)) & 0x20 >> 5))), 0, 0x1)
				libc.SetBitFieldPtr8Uint8(data+45 /* &.is_keyword */, (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 /* &result */ /* &.data */ /* &.is_keyword */)) & 0x40 >> 6))), 1, 0x2)
				*(*uintptr)(unsafe.Pointer(bp + 32 /* &result */)) = data
			}
		} else {
			(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &result */)))).Padding = padding
			(*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* &result */)))).Size = size
		}

		ts_subtree_set_has_changes(tls, bp+32 /* &result */)
		*(*Subtree)(unsafe.Pointer(entry.Tree)) = ts_subtree_from_mut(tls, *(*MutableSubtree)(unsafe.Pointer(bp + 32 /* result */)))
		var child_left Length
		var child_right = length_zero(tls)
		{
			var i Uint32_t = Uint32_t(0)
			var n Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(entry.Tree)))
		__1:
			if !(i < n) {
				goto __3
			}
			{
				var child uintptr = ((func() uintptr {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(entry.Tree /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						return uintptr(0)
					}
					return ((*(*uintptr)(unsafe.Pointer(entry.Tree))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(entry.Tree)))).Child_count)*16)
				}()) + uintptr(i)*16)
				var child_size = ts_subtree_total_size(tls, *(*Subtree)(unsafe.Pointer(child)))
				child_left = child_right
				child_right = length_add(tls, child_left, child_size)

				// If this child ends before the edit, it is not affected.
				if (child_right.Bytes + ts_subtree_lookahead_bytes(tls, *(*Subtree)(unsafe.Pointer(child)))) < edit.Start.Bytes {
					goto __2
				}

				// Keep editing child nodes until a node is reached that starts after the edit.
				// Also, if this node's validity depends on its column position, then continue
				// invaliditing child nodes until reaching a line break.
				if ((child_left.Bytes > edit.Old_end.Bytes) || (((child_left.Bytes == edit.Old_end.Bytes) && (child_size.Bytes > Uint32_t(0))) && (i > Uint32_t(0)))) && (!(invalidate_first_row != 0) || (child_left.Extent.Row > (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(entry.Tree /* .Ptr */)))).Padding.Extent.Row)) {
					goto __3
				}

				// Transform edit into the child's coordinate space.
				var child_edit = Edit{Start: length_sub(tls, edit.Start, child_left), Old_end: length_sub(tls, edit.Old_end, child_left), New_end: length_sub(tls, edit.New_end, child_left)}

				// Clamp child_edit to the child's bounds.
				if edit.Start.Bytes < child_left.Bytes {
					child_edit.Start = length_zero(tls)
				}
				if edit.Old_end.Bytes < child_left.Bytes {
					child_edit.Old_end = length_zero(tls)
				}
				if edit.New_end.Bytes < child_left.Bytes {
					child_edit.New_end = length_zero(tls)
				}
				if edit.Old_end.Bytes > child_right.Bytes {
					child_edit.Old_end = child_size
				}

				// Interpret all inserted text as applying to the *first* child that touches the edit.
				// Subsequent children are only never have any text inserted into them; they are only
				// shrunk to compensate for the edit.
				if (child_right.Bytes > edit.Start.Bytes) || ((child_right.Bytes == edit.Start.Bytes) && (is_pure_insertion != 0)) {
					edit.New_end = edit.Start
				} else {
					child_edit.Old_end = child_edit.Start
					child_edit.New_end = child_edit.Start
				}

				// Queue processing of this child's subtree.
				array__grow(tls, bp /* &stack */, uint64(1), uint64(unsafe.Sizeof(struct {
					Tree        uintptr
					Edit        Edit
					__ccgo_pad1 [4]byte
				}{})))
				*(*struct {
					Tree        uintptr
					Edit        Edit
					__ccgo_pad1 [4]byte
				})(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((bp /* &stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer(bp /* &stack */)).Size, 1))*48)) = struct {
					Tree        uintptr
					Edit        Edit
					__ccgo_pad1 [4]byte
				}{Tree: child, Edit: child_edit}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	array__delete(tls, bp /* &stack */)
	return *(*Subtree)(unsafe.Pointer(bp + 16 /* self */))
}

func Xts_subtree_last_external_token(tls *libc.TLS, tree Subtree) Subtree { /* subtree.c:824:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = tree

	if !(ts_subtree_has_external_tokens(tls, *(*Subtree)(unsafe.Pointer(bp /* tree */))) != 0) {
		return Subtree{}
	}
	for (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count > Uint32_t(0) {
		{
			var i Uint32_t = ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count - Uint32_t(1))
		__1:
			if !((i + Uint32_t(1)) > Uint32_t(0)) {
				goto __3
			}
			{
				var child = *(*Subtree)(unsafe.Pointer((func() uintptr {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(bp /* &tree */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						return uintptr(0)
					}
					return ((*(*uintptr)(unsafe.Pointer(bp /* &tree */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &tree */)))).Child_count)*16)
				}()) + uintptr(i)*16))
				if ts_subtree_has_external_tokens(tls, child) != 0 {
					*(*Subtree)(unsafe.Pointer(bp /* tree */)) = child
					goto __3
				}

			}
			goto __2
		__2:
			i--
			goto __1
			goto __3
		__3:
			;
		}
	}
	return *(*Subtree)(unsafe.Pointer(bp /* tree */))
}

func ts_subtree__write_char_to_string(tls *libc.TLS, s uintptr, n Size_t, c Int32_t) Size_t { /* subtree.c:838:15: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if c == -1 {
		return Size_t(libc.X__builtin___snprintf_chk(tls, s, n, 0, libc.X__builtin_object_size(tls, s, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4597 /* "INVALID" */, 0))
	} else if c == 0 {
		return Size_t(libc.X__builtin___snprintf_chk(tls, s, n, 0, libc.X__builtin_object_size(tls, s, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4605 /* "'\\0'" */, 0))
	} else if c == '\n' {
		return Size_t(libc.X__builtin___snprintf_chk(tls, s, n, 0, libc.X__builtin_object_size(tls, s, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4610 /* "'\\n'" */, 0))
	} else if c == '\t' {
		return Size_t(libc.X__builtin___snprintf_chk(tls, s, n, 0, libc.X__builtin_object_size(tls, s, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4615 /* "'\\t'" */, 0))
	} else if c == '\r' {
		return Size_t(libc.X__builtin___snprintf_chk(tls, s, n, 0, libc.X__builtin_object_size(tls, s, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4620 /* "'\\r'" */, 0))
	} else if ((0 < c) && (c < 128)) && (libc.Xisprint(tls, c) != 0) {
		return Size_t(libc.X__builtin___snprintf_chk(tls, s, n, 0, libc.X__builtin_object_size(tls, s, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4625 /* "'%c'" */, libc.VaList(bp, c)))
	} else {
		return Size_t(libc.X__builtin___snprintf_chk(tls, s, n, 0, libc.X__builtin_object_size(tls, s, func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4630 /* "%d" */, libc.VaList(bp+8, c)))
	}
	return Size_t(0)
}

func ts_subtree__write_dot_string(tls *libc.TLS, f uintptr, string uintptr) { /* subtree.c:855:13: */
	{
		var c uintptr = string
	__1:
		if !(*(*int8)(unsafe.Pointer(c)) != 0) {
			goto __3
		}
		{
			if int32(*(*int8)(unsafe.Pointer(c))) == '"' {
				libc.Xfputs(tls, ts+4633 /* "\\\"" */, f)
			} else if int32(*(*int8)(unsafe.Pointer(c))) == '\n' {
				libc.Xfputs(tls, ts+4636 /* "\\n" */, f)
			} else {
				libc.Xfputc(tls, int32(*(*int8)(unsafe.Pointer(c))), f)
			}

		}
		goto __2
	__2:
		c++
		goto __1
		goto __3
	__3:
		;
	}
}

var sROOT_FIELD uintptr = ts + 4639 /* "__ROOT__" */ /* subtree.c:867:19 */

func ts_subtree__write_to_string(tls *libc.TLS, self Subtree, string uintptr, limit Size_t, language uintptr, include_all uint8, alias_symbol TSSymbol, alias_is_named uint8, field_name uintptr) Size_t { /* subtree.c:869:15: */
	bp := tls.Alloc(88)
	defer tls.Free(88)
	*(*Subtree)(unsafe.Pointer(bp + 40)) = self
	*(*uintptr)(unsafe.Pointer(bp + 64)) = string

	if !(int32(*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */))) != 0) {
		return Size_t(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* string */)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* string */)), func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4648 /* "(NULL)" */, 0))
	}

	*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) = *(*uintptr)(unsafe.Pointer(bp + 64 /* string */))
	var writer uintptr
	if limit > uint64(0) {
		writer = bp + 56 /* &cursor */
	} else {
		writer = bp + 64 /* &string */
	}
	var is_root uint8 = (uint8(libc.Bool32(field_name == sROOT_FIELD)))
	var is_visible uint8 = (uint8(libc.Bool32(((include_all != 0) || (ts_subtree_missing(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) != 0)) || (func() int32 {
		if alias_symbol != 0 {
			return int32(alias_is_named)
		}
		return (libc.Bool32((ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) != 0) && (ts_subtree_named(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) != 0)))
	}() != 0))))

	if is_visible != 0 {
		if !(is_root != 0) {
			*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+4655 /* " " */, 0))
			if field_name != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+4657 /* "%s: " */, libc.VaList(bp, field_name)))
			}
		}

		if ((ts_subtree_is_error(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) != 0) && (ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) == Uint32_t(0))) && ((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */)))).Size.Bytes > Uint32_t(0)) {
			*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
				if X_USE_FORTIFY_LEVEL > 1 {
					return 1
				}
				return 0
			}()), ts+4662 /* "(UNEXPECTED " */, 0))
			*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(ts_subtree__write_char_to_string(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, *(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */)) + 48))))
		} else {
			var symbol TSSymbol
			if alias_symbol != 0 {
				symbol = alias_symbol
			} else {
				symbol = ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */)))
			}
			var symbol_name uintptr = Xts_language_symbol_name(tls, language, symbol)
			if ts_subtree_missing(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+4675 /* "(MISSING " */, 0))
				if (alias_is_named != 0) || (ts_subtree_named(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) != 0) {
					*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
						if X_USE_FORTIFY_LEVEL > 1 {
							return 1
						}
						return 0
					}()), ts+4685 /* "%s" */, libc.VaList(bp+8, symbol_name)))
				} else {
					*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
						if X_USE_FORTIFY_LEVEL > 1 {
							return 1
						}
						return 0
					}()), ts+4688 /* "\"%s\"" */, libc.VaList(bp+16, symbol_name)))
				}
			} else {
				*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
					if X_USE_FORTIFY_LEVEL > 1 {
						return 1
					}
					return 0
				}()), ts+4693 /* "(%s" */, libc.VaList(bp+24, symbol_name)))
			}
		}
	} else if is_root != 0 {
		var symbol TSSymbol = ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */)))
		var symbol_name uintptr = Xts_language_symbol_name(tls, language, symbol)
		*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4697 /* "(\"%s\")" */, libc.VaList(bp+32, symbol_name)))
	}

	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(bp + 40 /* self */))) != 0 {
		var alias_sequence uintptr = ts_language_alias_sequence(tls, language, uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */)) + 68))))
		// var field_map uintptr at bp+72, 8

		// var field_map_end uintptr at bp+80, 8

		ts_language_field_map(tls,
			language,
			uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */)) + 68))),
			bp+72, /* &field_map */
			bp+80 /* &field_map_end */)

		var structural_child_index Uint32_t = Uint32_t(0)
		{
			var i Uint32_t = Uint32_t(0)
		__1:
			if !(i < (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */)))).Child_count) {
				goto __3
			}
			{
				var child = *(*Subtree)(unsafe.Pointer((func() uintptr {
					if (uint8(int32(*(*uint8)(unsafe.Pointer(bp + 40 /* &self */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
						return uintptr(0)
					}
					return ((*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* &self */)))).Child_count)*16)
				}()) + uintptr(i)*16))
				if ts_subtree_extra(tls, child) != 0 {
					*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(ts_subtree__write_to_string(tls,
						child, *(*uintptr)(unsafe.Pointer(writer)), limit,
						language, include_all,
						uint16(0), uint8(False), uintptr(0)))
				} else {
					var alias_symbol TSSymbol
					if alias_sequence != 0 {
						alias_symbol = *(*TSSymbol)(unsafe.Pointer(alias_sequence + uintptr(structural_child_index)*2))
					} else {
						alias_symbol = uint16(0)
					}
					var alias_is_named uint8
					if alias_symbol != 0 {
						alias_is_named = Xts_language_symbol_metadata(tls, language, alias_symbol).Named
					} else {
						alias_is_named = uint8(False)
					}

					var child_field_name uintptr
					if is_visible != 0 {
						child_field_name = uintptr(0)
					} else {
						child_field_name = field_name
					}
					{
						var i uintptr = *(*uintptr)(unsafe.Pointer(bp + 72 /* field_map */))
					__4:
						if !(i < *(*uintptr)(unsafe.Pointer(bp + 80 /* field_map_end */))) {
							goto __6
						}
						{
							if !(int32((*TSFieldMapEntry)(unsafe.Pointer(i)).Inherited) != 0) && (Uint32_t((*TSFieldMapEntry)(unsafe.Pointer(i)).Child_index) == structural_child_index) {
								child_field_name = *(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(language)).Field_names + uintptr((*TSFieldMapEntry)(unsafe.Pointer(i)).Field_id)*8))
								goto __6
							}

						}
						goto __5
					__5:
						i += 4
						goto __4
						goto __6
					__6:
						;
					}

					*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(ts_subtree__write_to_string(tls,
						child, *(*uintptr)(unsafe.Pointer(writer)), limit,
						language, include_all,
						alias_symbol, alias_is_named, child_field_name))
					structural_child_index++
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
			;
		}
	}

	if is_visible != 0 {
		*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */)) += uintptr(libc.X__builtin___snprintf_chk(tls, *(*uintptr)(unsafe.Pointer(writer)), limit, 0, libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(writer)), func() int32 {
			if X_USE_FORTIFY_LEVEL > 1 {
				return 1
			}
			return 0
		}()), ts+4704 /* ")" */, 0))
	}

	return (Size_t((int64(*(*uintptr)(unsafe.Pointer(bp + 56 /* cursor */))) - int64(*(*uintptr)(unsafe.Pointer(bp + 64 /* string */)))) / 1))
}

func Xts_subtree_string(tls *libc.TLS, self Subtree, language uintptr, include_all uint8) uintptr { /* subtree.c:969:6: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	// var scratch_string [1]int8 at bp, 1

	var size Size_t = (ts_subtree__write_to_string(tls,
		self, bp /* &scratch_string[0] */, uint64(0),
		language, include_all,
		uint16(0), uint8(False), sROOT_FIELD) + uint64(1))
	var result uintptr = ts_malloc_default(tls, (size * Size_t(unsafe.Sizeof(int8(0)))))
	ts_subtree__write_to_string(tls,
		self, result, size,
		language, include_all,
		uint16(0), uint8(False), sROOT_FIELD)
	return result
}

func Xts_subtree__print_dot_graph(tls *libc.TLS, self uintptr, start_offset Uint32_t, language uintptr, alias_symbol TSSymbol, f uintptr) { /* subtree.c:989:6: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var subtree_symbol TSSymbol = ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(self)))
	var symbol TSSymbol
	if alias_symbol != 0 {
		symbol = alias_symbol
	} else {
		symbol = subtree_symbol
	}
	var end_offset Uint32_t = (start_offset + ts_subtree_total_bytes(tls, *(*Subtree)(unsafe.Pointer(self))))
	libc.Xfprintf(tls, f, ts+4706 /* "tree_%p [label=\"" */, libc.VaList(bp, self))
	ts_subtree__write_dot_string(tls, f, Xts_language_symbol_name(tls, language, symbol))
	libc.Xfprintf(tls, f, ts+4274 /* "\"" */, 0)

	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(self))) == Uint32_t(0) {
		libc.Xfprintf(tls, f, ts+4723 /* ", shape=plaintex..." */, 0)
	}
	if ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(self))) != 0 {
		libc.Xfprintf(tls, f, ts+4741 /* ", fontcolor=gray" */, 0)
	}

	libc.Xfprintf(tls, f,

		ts+4758, /* ", tooltip=\"range..." */
		libc.VaList(bp+8, start_offset, end_offset,
			int32(ts_subtree_parse_state(tls, *(*Subtree)(unsafe.Pointer(self)))),
			ts_subtree_error_cost(tls, *(*Subtree)(unsafe.Pointer(self))),
			ts_subtree_has_changes(tls, *(*Subtree)(unsafe.Pointer(self))),
			ts_subtree_depends_on_column(tls, *(*Subtree)(unsafe.Pointer(self))),
			ts_subtree_repeat_depth(tls, *(*Subtree)(unsafe.Pointer(self))),
			ts_subtree_lookahead_bytes(tls, *(*Subtree)(unsafe.Pointer(self)))))

	if (ts_subtree_is_error(tls, *(*Subtree)(unsafe.Pointer(self))) != 0) && (ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(self))) == Uint32_t(0)) {
		libc.Xfprintf(tls, f, ts+4884 /* "\ncharacter: '%c'" */, libc.VaList(bp+72, *(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* .Ptr */)) + 48))))
	}

	libc.Xfprintf(tls, f, ts+4051 /* "\"]\n" */, 0)

	var child_start_offset Uint32_t = start_offset
	var child_info_offset Uint32_t = (Uint32_t(int32((*TSLanguage)(unsafe.Pointer(language)).Max_alias_sequence_length) * int32(ts_subtree_production_id(tls, *(*Subtree)(unsafe.Pointer(self))))))
	{
		var i Uint32_t = Uint32_t(0)
		var n Uint32_t = ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer(self)))
	__1:
		if !(i < n) {
			goto __3
		}
		{
			var child uintptr = ((func() uintptr {
				if (uint8(int32(*(*uint8)(unsafe.Pointer(self /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
					return uintptr(0)
				}
				return ((*(*uintptr)(unsafe.Pointer(self))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self)))).Child_count)*16)
			}()) + uintptr(i)*16)
			var alias_symbol TSSymbol = TSSymbol(0)
			if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(child))) != 0) && (child_info_offset != 0) {
				alias_symbol = *(*TSSymbol)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer(language)).Alias_sequences + uintptr(child_info_offset)*2))
				child_info_offset++
			}
			Xts_subtree__print_dot_graph(tls, child, child_start_offset, language, alias_symbol, f)
			libc.Xfprintf(tls, f, ts+4901 /* "tree_%p -> tree_..." */, libc.VaList(bp+80, self, child, i))
			child_start_offset = child_start_offset + (ts_subtree_total_bytes(tls, *(*Subtree)(unsafe.Pointer(child))))

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}
}

func Xts_subtree_print_dot_graph(tls *libc.TLS, self Subtree, language uintptr, f uintptr) { /* subtree.c:1042:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Subtree)(unsafe.Pointer(bp)) = self

	libc.Xfprintf(tls, f, ts+4934 /* "digraph tree {\n" */, 0)
	libc.Xfprintf(tls, f, ts+3822 /* "edge [arrowhead=..." */, 0)
	Xts_subtree__print_dot_graph(tls, bp /* &self */, uint32(0), language, uint16(0), f)
	libc.Xfprintf(tls, f, ts+4333 /* "}\n" */, 0)
}

func Xts_subtree_external_scanner_state_eq(tls *libc.TLS, self Subtree, other Subtree) uint8 { /* subtree.c:1049:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*Subtree)(unsafe.Pointer(bp)) = self
	*(*Subtree)(unsafe.Pointer(bp + 16)) = other

	var state1 uintptr = uintptr(unsafe.Pointer(&empty_state))
	var state2 uintptr = uintptr(unsafe.Pointer(&empty_state))
	if ((*(*uintptr)(unsafe.Pointer(bp /* &self */)) != 0) && (ts_subtree_has_external_tokens(tls, *(*Subtree)(unsafe.Pointer(bp /* self */))) != 0)) && !(int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &self */)))).Child_count) != 0) {
		state1 = (*(*uintptr)(unsafe.Pointer(bp /* &self */)) + 48 /* &.external_scanner_state */)
	}
	if ((*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) != 0) && (ts_subtree_has_external_tokens(tls, *(*Subtree)(unsafe.Pointer(bp + 16 /* other */))) != 0)) && !(int32((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)))).Child_count) != 0) {
		state2 = (*(*uintptr)(unsafe.Pointer(bp + 16 /* &other */)) + 48 /* &.external_scanner_state */)
	}
	return Xts_external_scanner_state_eq(tls, state1, state2)
}

type CursorChildIterator = struct {
	Parent                 Subtree
	Tree                   uintptr
	Position               Length
	Child_index            Uint32_t
	Structural_child_index Uint32_t
	__ccgo_pad1            [4]byte
	Alias_sequence         uintptr
} /* tree_cursor.c:14:3 */

// CursorChildIterator

func ts_tree_cursor_iterate_children(tls *libc.TLS, self uintptr) CursorChildIterator { /* tree_cursor.c:18:35: */
	var last_entry uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+8 /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__116)), ts+4950 /* "upstream/tree-si..." */, 19, ts+758 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+8 /* &.stack */))).Size-Uint32_t(1)))*32)
	}()
	if ts_subtree_child_count(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(last_entry)).Subtree))) == Uint32_t(0) {
		return CursorChildIterator{Tree: (*TreeCursor)(unsafe.Pointer(self)).Tree, Position: length_zero(tls)}
	}
	var alias_sequence uintptr = ts_language_alias_sequence(tls,
		(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
		uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(last_entry)).Subtree /* .Ptr */)) + 68))))
	return CursorChildIterator{Parent: *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(last_entry)).Subtree)), Tree: (*TreeCursor)(unsafe.Pointer(self)).Tree, Position: (*TreeCursorEntry)(unsafe.Pointer(last_entry)).Position, Alias_sequence: alias_sequence}
}

var __func__116 = *(*[32]int8)(unsafe.Pointer(ts + 4993 /* "ts_tree_cursor_i..." */)) /* tree_cursor.c:18:91 */

func ts_tree_cursor_child_iterator_next(tls *libc.TLS, self uintptr, result uintptr, visible uintptr) uint8 { /* tree_cursor.c:37:20: */
	if !(int32(*(*uintptr)(unsafe.Pointer(self /* &.parent */))) != 0) || ((*CursorChildIterator)(unsafe.Pointer(self)).Child_index == (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* &.parent */)))).Child_count) {
		return uint8(False)
	}
	var child uintptr = ((func() uintptr {
		if (uint8(int32(*(*uint8)(unsafe.Pointer(self /* &.parent */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
			return uintptr(0)
		}
		return ((*(*uintptr)(unsafe.Pointer(self /* &.parent */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* &.parent */)))).Child_count)*16)
	}()) + uintptr((*CursorChildIterator)(unsafe.Pointer(self)).Child_index)*16)
	*(*TreeCursorEntry)(unsafe.Pointer(result)) = TreeCursorEntry{Subtree: child, Position: (*CursorChildIterator)(unsafe.Pointer(self)).Position, Child_index: (*CursorChildIterator)(unsafe.Pointer(self)).Child_index, Structural_child_index: (*CursorChildIterator)(unsafe.Pointer(self)).Structural_child_index}
	*(*uint8)(unsafe.Pointer(visible)) = ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer(child)))
	var extra uint8 = ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(child)))
	if !(extra != 0) && ((*CursorChildIterator)(unsafe.Pointer(self)).Alias_sequence != 0) {
		*(*uint8)(unsafe.Pointer(visible)) |= uint8((int32(*(*TSSymbol)(unsafe.Pointer((*CursorChildIterator)(unsafe.Pointer(self)).Alias_sequence + uintptr((*CursorChildIterator)(unsafe.Pointer(self)).Structural_child_index)*2)))))
		(*CursorChildIterator)(unsafe.Pointer(self)).Structural_child_index++
	}

	(*CursorChildIterator)(unsafe.Pointer(self)).Position = length_add(tls, (*CursorChildIterator)(unsafe.Pointer(self)).Position, ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer(child))))
	(*CursorChildIterator)(unsafe.Pointer(self)).Child_index++

	if (*CursorChildIterator)(unsafe.Pointer(self)).Child_index < (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* &.parent */)))).Child_count {
		var next_child = *(*Subtree)(unsafe.Pointer((func() uintptr {
			if (uint8(int32(*(*uint8)(unsafe.Pointer(self /* &.parent */ /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
				return uintptr(0)
			}
			return ((*(*uintptr)(unsafe.Pointer(self /* &.parent */))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(self /* &.parent */)))).Child_count)*16)
		}()) + uintptr((*CursorChildIterator)(unsafe.Pointer(self)).Child_index)*16))
		(*CursorChildIterator)(unsafe.Pointer(self)).Position = length_add(tls, (*CursorChildIterator)(unsafe.Pointer(self)).Position, ts_subtree_padding(tls, next_child))
	}

	return uint8(True)
}

// TSTreeCursor - lifecycle

func Xts_tree_cursor_new(tls *libc.TLS, node TSNode) TSTreeCursor { /* tree_cursor.c:68:14: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*TSTreeCursor)(unsafe.Pointer(bp /* self */)) = TSTreeCursor{}
	Xts_tree_cursor_init(tls, bp /* &self */, node)
	return *(*TSTreeCursor)(unsafe.Pointer(bp /* self */))
}

func Xts_tree_cursor_reset(tls *libc.TLS, _self uintptr, node TSNode) { /* tree_cursor.c:74:6: */
	Xts_tree_cursor_init(tls, _self, node)
}

func Xts_tree_cursor_init(tls *libc.TLS, self uintptr, node TSNode) { /* tree_cursor.c:78:6: */
	(*TreeCursor)(unsafe.Pointer(self)).Tree = node.Tree
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 8 /* &.stack */))).Size = Uint32_t(0)
	array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
	*(*TreeCursorEntry)(unsafe.Pointer((*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = TreeCursorEntry{Subtree: node.Id, Position: Length{Bytes: Xts_node_start_byte(tls, node), Extent: Xts_node_start_point(tls, node)}}
}

func Xts_tree_cursor_delete(tls *libc.TLS, _self uintptr) { /* tree_cursor.c:92:6: */
	var self uintptr = _self
	array__delete(tls, (self + 8 /* &.stack */))
}

// TSTreeCursor - walking the tree

func Xts_tree_cursor_goto_first_child(tls *libc.TLS, _self uintptr) uint8 { /* tree_cursor.c:99:6: */
	bp := tls.Alloc(89)
	defer tls.Free(89)

	var self uintptr = _self
	var did_descend uint8
	for ok := true; ok; ok = did_descend != 0 {
		did_descend = uint8(False)
		// var visible uint8 at bp+88, 1

		// var entry TreeCursorEntry at bp+56, 32

		*(*CursorChildIterator)(unsafe.Pointer(bp /* iterator */)) = ts_tree_cursor_iterate_children(tls, self)
		for ts_tree_cursor_child_iterator_next(tls, bp /* &iterator */, bp+56 /* &entry */, bp+88 /* &visible */) != 0 {
			if *(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) != 0 {
				array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
				*(*TreeCursorEntry)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
				return uint8(True)
			}

			if ts_subtree_visible_child_count(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Subtree))) > Uint32_t(0) {
				array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
				*(*TreeCursorEntry)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
				did_descend = uint8(True)
				break
			}
		}
	}

	return uint8(False)
}

func Xts_tree_cursor_goto_first_child_for_byte(tls *libc.TLS, _self uintptr, goal_byte Uint32_t) Int64_t { /* tree_cursor.c:126:9: */
	bp := tls.Alloc(89)
	defer tls.Free(89)

	var self uintptr = _self
	var initial_size Uint32_t = (*TreeCursor)(unsafe.Pointer(self)).Stack.Size
	var visible_child_index Uint32_t = Uint32_t(0)
	var did_descend uint8
	for ok := true; ok; ok = did_descend != 0 {
		did_descend = uint8(False)
		// var visible uint8 at bp+88, 1

		// var entry TreeCursorEntry at bp+56, 32

		*(*CursorChildIterator)(unsafe.Pointer(bp /* iterator */)) = ts_tree_cursor_iterate_children(tls, self)
		for ts_tree_cursor_child_iterator_next(tls, bp /* &iterator */, bp+56 /* &entry */, bp+88 /* &visible */) != 0 {
			var end_byte Uint32_t = ((*TreeCursorEntry)(unsafe.Pointer(bp+56 /* &entry */)).Position.Bytes + ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Subtree))).Bytes)
			var at_goal uint8 = (uint8(libc.Bool32(end_byte > goal_byte)))
			var visible_child_count Uint32_t = ts_subtree_visible_child_count(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Subtree)))

			if at_goal != 0 {
				if *(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) != 0 {
					array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
					*(*TreeCursorEntry)(unsafe.Pointer((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
					return Int64_t(visible_child_index)
				}

				if visible_child_count > Uint32_t(0) {
					array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
					*(*TreeCursorEntry)(unsafe.Pointer((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
					did_descend = uint8(True)
					break
				}
			} else if *(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) != 0 {
				visible_child_index++
			} else {
				visible_child_index = visible_child_index + (visible_child_count)
			}
		}
	}

	(*TreeCursor)(unsafe.Pointer(self)).Stack.Size = initial_size
	return int64(-1)
}

func Xts_tree_cursor_goto_first_child_for_point(tls *libc.TLS, _self uintptr, goal_point TSPoint) Int64_t { /* tree_cursor.c:166:9: */
	bp := tls.Alloc(89)
	defer tls.Free(89)

	var self uintptr = _self
	var initial_size Uint32_t = (*TreeCursor)(unsafe.Pointer(self)).Stack.Size
	var visible_child_index Uint32_t = Uint32_t(0)
	var did_descend uint8
	for ok := true; ok; ok = did_descend != 0 {
		did_descend = uint8(False)
		// var visible uint8 at bp+88, 1

		// var entry TreeCursorEntry at bp+56, 32

		*(*CursorChildIterator)(unsafe.Pointer(bp /* iterator */)) = ts_tree_cursor_iterate_children(tls, self)
		for ts_tree_cursor_child_iterator_next(tls, bp /* &iterator */, bp+56 /* &entry */, bp+88 /* &visible */) != 0 {
			var end_point = point_add(tls, (*TreeCursorEntry)(unsafe.Pointer(bp+56 /* &entry */)).Position.Extent, ts_subtree_size(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Subtree))).Extent)
			var at_goal uint8 = point_gt(tls, end_point, goal_point)
			var visible_child_count Uint32_t = ts_subtree_visible_child_count(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Subtree)))
			if at_goal != 0 {
				if *(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) != 0 {
					array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
					*(*TreeCursorEntry)(unsafe.Pointer((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
					return Int64_t(visible_child_index)
				}
				if visible_child_count > Uint32_t(0) {
					array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
					*(*TreeCursorEntry)(unsafe.Pointer((*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
						Contents uintptr
						Size     Uint32_t
						Capacity Uint32_t
					})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
					did_descend = uint8(True)
					break
				}
			} else if *(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) != 0 {
				visible_child_index++
			} else {
				visible_child_index = visible_child_index + (visible_child_count)
			}
		}
	}

	(*TreeCursor)(unsafe.Pointer(self)).Stack.Size = initial_size
	return int64(-1)
}

func Xts_tree_cursor_goto_next_sibling(tls *libc.TLS, _self uintptr) uint8 { /* tree_cursor.c:204:6: */
	bp := tls.Alloc(89)
	defer tls.Free(89)

	var self uintptr = _self
	var initial_size Uint32_t = (*TreeCursor)(unsafe.Pointer(self)).Stack.Size

	for (*TreeCursor)(unsafe.Pointer(self)).Stack.Size > Uint32_t(1) {
		*(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */)) = *(*TreeCursorEntry)(unsafe.Pointer((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PreDecUint32(&(*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32))
		*(*CursorChildIterator)(unsafe.Pointer(bp /* iterator */)) = ts_tree_cursor_iterate_children(tls, self)
		(*CursorChildIterator)(unsafe.Pointer(bp /* &iterator */)).Child_index = (*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Child_index
		(*CursorChildIterator)(unsafe.Pointer(bp /* &iterator */)).Structural_child_index = (*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Structural_child_index
		(*CursorChildIterator)(unsafe.Pointer(bp /* &iterator */)).Position = (*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Position

		*(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) = uint8(False)
		ts_tree_cursor_child_iterator_next(tls, bp /* &iterator */, bp+56 /* &entry */, bp+88 /* &visible */)
		if (*(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) != 0) && (((*TreeCursor)(unsafe.Pointer(self)).Stack.Size + Uint32_t(1)) < initial_size) {
			break
		}

		for ts_tree_cursor_child_iterator_next(tls, bp /* &iterator */, bp+56 /* &entry */, bp+88 /* &visible */) != 0 {
			if *(*uint8)(unsafe.Pointer(bp + 88 /* visible */)) != 0 {
				array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
				*(*TreeCursorEntry)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
				return uint8(True)
			}

			if ts_subtree_visible_child_count(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* &entry */)).Subtree))) != 0 {
				array__grow(tls, (self + 8 /* &.stack */), uint64(1), uint64(unsafe.Sizeof(TreeCursorEntry{})))
				*(*TreeCursorEntry)(unsafe.Pointer((*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(libc.PostIncUint32(&(*struct {
					Contents uintptr
					Size     Uint32_t
					Capacity Uint32_t
				})(unsafe.Pointer((self+8 /* &.stack */))).Size, 1))*32)) = *(*TreeCursorEntry)(unsafe.Pointer(bp + 56 /* entry */))
				Xts_tree_cursor_goto_first_child(tls, _self)
				return uint8(True)
			}
		}
	}

	(*TreeCursor)(unsafe.Pointer(self)).Stack.Size = initial_size
	return uint8(False)
}

func Xts_tree_cursor_goto_parent(tls *libc.TLS, _self uintptr) uint8 { /* tree_cursor.c:237:6: */
	var self uintptr = _self
	{
		var i uint32 = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Size - Uint32_t(2))
	__1:
		if !((i + uint32(1)) > uint32(0)) {
			goto __3
		}
		{
			var entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr(i)*32)
			if ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0 {
				(*TreeCursor)(unsafe.Pointer(self)).Stack.Size = (i + uint32(1))
				return uint8(True)
			}
			if (i > uint32(0)) && !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0) {
				var parent_entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr((i-uint32(1)))*32)
				if ts_language_alias_at(tls,
					(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
					uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)) + 68))),
					(*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index) != 0 {
					(*TreeCursor)(unsafe.Pointer(self)).Stack.Size = (i + uint32(1))
					return uint8(True)
				}
			}

		}
		goto __2
	__2:
		i--
		goto __1
		goto __3
	__3:
		;
	}
	return uint8(False)
}

func Xts_tree_cursor_current_node(tls *libc.TLS, _self uintptr) TSNode { /* tree_cursor.c:260:8: */
	var self uintptr = _self
	var last_entry uintptr = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+8 /* &.stack */))).Size-Uint32_t(1)) < (*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+8 /* &.stack */))).Size)), int64(0)) != 0 {
			libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__117)), ts+4950 /* "upstream/tree-si..." */, 262, ts+758 /* "(uint32_t)(&self..." */)
		} else {
		}
		return ((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self + 8 /* &.stack */))).Contents + uintptr(((*struct {
			Contents uintptr
			Size     Uint32_t
			Capacity Uint32_t
		})(unsafe.Pointer((self+8 /* &.stack */))).Size-Uint32_t(1)))*32)
	}()
	var alias_symbol TSSymbol = TSSymbol(0)
	if ((*TreeCursor)(unsafe.Pointer(self)).Stack.Size > Uint32_t(1)) && !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(last_entry)).Subtree))) != 0) {
		var parent_entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr(((*TreeCursor)(unsafe.Pointer(self)).Stack.Size-Uint32_t(2)))*32)
		alias_symbol = ts_language_alias_at(tls,
			(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
			uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)) + 68))),
			(*TreeCursorEntry)(unsafe.Pointer(last_entry)).Structural_child_index)
	}
	return Xts_node_new(tls,
		(*TreeCursor)(unsafe.Pointer(self)).Tree,
		(*TreeCursorEntry)(unsafe.Pointer(last_entry)).Subtree,
		(*TreeCursorEntry)(unsafe.Pointer(last_entry)).Position,
		alias_symbol)
}

var __func__117 = *(*[28]int8)(unsafe.Pointer(ts + 5025 /* "ts_tree_cursor_c..." */)) /* tree_cursor.c:260:63 */

// Private - Get various facts about the current node that are needed
// when executing tree queries.
func Xts_tree_cursor_current_status(tls *libc.TLS, _self uintptr, field_id uintptr, has_later_siblings uintptr, has_later_named_siblings uintptr, can_have_later_siblings_with_this_field uintptr, supertypes uintptr, supertype_count uintptr) { /* tree_cursor.c:282:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var self uintptr = _self
	var max_supertypes uint32 = *(*uint32)(unsafe.Pointer(supertype_count))
	*(*TSFieldId)(unsafe.Pointer(field_id)) = TSFieldId(0)
	*(*uint32)(unsafe.Pointer(supertype_count)) = uint32(0)
	*(*uint8)(unsafe.Pointer(has_later_siblings)) = uint8(False)
	*(*uint8)(unsafe.Pointer(has_later_named_siblings)) = uint8(False)
	*(*uint8)(unsafe.Pointer(can_have_later_siblings_with_this_field)) = uint8(False)

	// Walk up the tree, visiting the current node and its invisible ancestors,
	// because fields can refer to nodes through invisible *wrapper* nodes,
	{
		var i uint32 = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Size - Uint32_t(1))
	__1:
		if !(i > uint32(0)) {
			goto __3
		}
		{
			var entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr(i)*32)
			var parent_entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr((i-uint32(1)))*32)

			var alias_sequence uintptr = ts_language_alias_sequence(tls,
				(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
				uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)) + 68))))

			// Stop walking up when a visible ancestor is found.
			var entry_symbol TSSymbol = func() uint16 {
				if (!(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0) && (alias_sequence != 0)) && (*(*TSSymbol)(unsafe.Pointer(alias_sequence + uintptr((*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index)*2)) != 0) {
					return *(*TSSymbol)(unsafe.Pointer(alias_sequence + uintptr((*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index)*2))
				}
				return ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree)))
			}()
			var entry_metadata = Xts_language_symbol_metadata(tls,
				(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
				entry_symbol)
			if (i != ((*TreeCursor)(unsafe.Pointer(self)).Stack.Size - Uint32_t(1))) && (entry_metadata.Visible != 0) {
				goto __3
			}

			// Record any supertypes
			if (entry_metadata.Supertype != 0) && (*(*uint32)(unsafe.Pointer(supertype_count)) < max_supertypes) {
				*(*TSSymbol)(unsafe.Pointer(supertypes + uintptr(*(*uint32)(unsafe.Pointer(supertype_count)))*2)) = entry_symbol
				(*(*uint32)(unsafe.Pointer(supertype_count)))++
			}

			// Determine if the current node has later siblings.
			if !(int32(*(*uint8)(unsafe.Pointer(has_later_siblings))) != 0) {
				var sibling_count uint32 = (*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)))).Child_count
				var structural_child_index uint32 = (*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index
				if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0) {
					structural_child_index++
				}
				{
					var j uint32 = ((*TreeCursorEntry)(unsafe.Pointer(entry)).Child_index + Uint32_t(1))
				__4:
					if !(j < sibling_count) {
						goto __6
					}
					{
						*(*Subtree)(unsafe.Pointer(bp /* sibling */)) = *(*Subtree)(unsafe.Pointer((func() uintptr {
							if (uint8(int32(*(*uint8)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* &.data */ /* &.is_inline */)) & 0x1 >> 0))) != 0 {
								return uintptr(0)
							}
							return ((*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree))) - uintptr((*SubtreeHeapData)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree)))).Child_count)*16)
						}()) + uintptr(j)*16))
						var sibling_metadata = Xts_language_symbol_metadata(tls,
							(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
							func() uint16 {
								if (!(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp /* sibling */))) != 0) && (alias_sequence != 0)) && (*(*TSSymbol)(unsafe.Pointer(alias_sequence + uintptr(structural_child_index)*2)) != 0) {
									return *(*TSSymbol)(unsafe.Pointer(alias_sequence + uintptr(structural_child_index)*2))
								}
								return ts_subtree_symbol(tls, *(*Subtree)(unsafe.Pointer(bp /* sibling */)))
							}())
						if sibling_metadata.Visible != 0 {
							*(*uint8)(unsafe.Pointer(has_later_siblings)) = uint8(True)
							if *(*uint8)(unsafe.Pointer(has_later_named_siblings)) != 0 {
								goto __6
							}
							if sibling_metadata.Named != 0 {
								*(*uint8)(unsafe.Pointer(has_later_named_siblings)) = uint8(True)
								goto __6
							}
						} else if ts_subtree_visible_child_count(tls, *(*Subtree)(unsafe.Pointer(bp /* sibling */))) > Uint32_t(0) {
							*(*uint8)(unsafe.Pointer(has_later_siblings)) = uint8(True)
							if *(*uint8)(unsafe.Pointer(has_later_named_siblings)) != 0 {
								goto __6
							}
							if *(*Uint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* &sibling */)) + 52)) > Uint32_t(0) {
								*(*uint8)(unsafe.Pointer(has_later_named_siblings)) = uint8(True)
								goto __6
							}
						}
						if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer(bp /* sibling */))) != 0) {
							structural_child_index++
						}

					}
					goto __5
				__5:
					j++
					goto __4
					goto __6
				__6:
					;
				}
			}

			if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0) {
				// var field_map uintptr at bp+16, 8

				// var field_map_end uintptr at bp+24, 8

				ts_language_field_map(tls,
					(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
					uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)) + 68))),
					bp+16 /* &field_map */, bp+24 /* &field_map_end */)

				// Look for a field name associated with the current node.
				if !(int32(*(*TSFieldId)(unsafe.Pointer(field_id))) != 0) {
					{
						var i uintptr = *(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */))
					__7:
						if !(i < *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
							goto __9
						}
						{
							if !(int32((*TSFieldMapEntry)(unsafe.Pointer(i)).Inherited) != 0) && (Uint32_t((*TSFieldMapEntry)(unsafe.Pointer(i)).Child_index) == (*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index) {
								*(*TSFieldId)(unsafe.Pointer(field_id)) = (*TSFieldMapEntry)(unsafe.Pointer(i)).Field_id
								goto __9
							}

						}
						goto __8
					__8:
						i += 4
						goto __7
						goto __9
					__9:
						;
					}
				}

				// Determine if the current node can have later siblings with the same field name.
				if *(*TSFieldId)(unsafe.Pointer(field_id)) != 0 {
					{
						var i uintptr = *(*uintptr)(unsafe.Pointer(bp + 16 /* field_map */))
					__10:
						if !(i < *(*uintptr)(unsafe.Pointer(bp + 24 /* field_map_end */))) {
							goto __12
						}
						{
							if (int32((*TSFieldMapEntry)(unsafe.Pointer(i)).Field_id) == int32(*(*TSFieldId)(unsafe.Pointer(field_id)))) && (Uint32_t((*TSFieldMapEntry)(unsafe.Pointer(i)).Child_index) > (*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index) {
								*(*uint8)(unsafe.Pointer(can_have_later_siblings_with_this_field)) = uint8(True)
								goto __12
							}

						}
						goto __11
					__11:
						i += 4
						goto __10
						goto __12
					__12:
						;
					}
				}
			}

		}
		goto __2
	__2:
		i--
		goto __1
		goto __3
	__3:
		;
	}
}

func Xts_tree_cursor_parent_node(tls *libc.TLS, _self uintptr) TSNode { /* tree_cursor.c:402:8: */
	var self uintptr = _self
	{
		var i int32 = (int32((*TreeCursor)(unsafe.Pointer(self)).Stack.Size) - 2)
	__1:
		if !(i >= 0) {
			goto __3
		}
		{
			var entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr(i)*32)
			var is_visible uint8 = uint8(True)
			var alias_symbol TSSymbol = TSSymbol(0)
			if i > 0 {
				var parent_entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr((i-1))*32)
				alias_symbol = ts_language_alias_at(tls,
					(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
					uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)) + 68))),
					(*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index)
				is_visible = (uint8(libc.Bool32((int32(alias_symbol) != 0) || (ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0))))
			}
			if is_visible != 0 {
				return Xts_node_new(tls,
					(*TreeCursor)(unsafe.Pointer(self)).Tree,
					(*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree,
					(*TreeCursorEntry)(unsafe.Pointer(entry)).Position,
					alias_symbol)
			}

		}
		goto __2
	__2:
		i--
		goto __1
		goto __3
	__3:
		;
	}
	return Xts_node_new(tls, uintptr(0), uintptr(0), length_zero(tls), uint16(0))
}

func Xts_tree_cursor_current_field_id(tls *libc.TLS, _self uintptr) TSFieldId { /* tree_cursor.c:429:11: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var self uintptr = _self

	// Walk up the tree, visiting the current node and its invisible ancestors.
	{
		var i uint32 = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Size - Uint32_t(1))
	__1:
		if !(i > uint32(0)) {
			goto __3
		}
		{
			var entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr(i)*32)
			var parent_entry uintptr = ((*TreeCursor)(unsafe.Pointer(self)).Stack.Contents + uintptr((i-uint32(1)))*32)

			// Stop walking up when another visible node is found.
			if i != ((*TreeCursor)(unsafe.Pointer(self)).Stack.Size - Uint32_t(1)) {
				if ts_subtree_visible(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0 {
					goto __3
				}
				if !(ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0) && (ts_language_alias_at(tls,
					(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
					uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)) + 68))),
					(*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index) != 0) {
					goto __3
				}
			}

			if ts_subtree_extra(tls, *(*Subtree)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(entry)).Subtree))) != 0 {
				goto __3
			}
			// var field_map uintptr at bp, 8

			// var field_map_end uintptr at bp+8, 8

			ts_language_field_map(tls,
				(*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language,
				uint32(*(*Uint16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*TreeCursorEntry)(unsafe.Pointer(parent_entry)).Subtree /* .Ptr */)) + 68))),
				bp /* &field_map */, bp+8 /* &field_map_end */)
			{
				var i uintptr = *(*uintptr)(unsafe.Pointer(bp /* field_map */))
			__4:
				if !(i < *(*uintptr)(unsafe.Pointer(bp + 8 /* field_map_end */))) {
					goto __6
				}
				{
					if !(int32((*TSFieldMapEntry)(unsafe.Pointer(i)).Inherited) != 0) && (Uint32_t((*TSFieldMapEntry)(unsafe.Pointer(i)).Child_index) == (*TreeCursorEntry)(unsafe.Pointer(entry)).Structural_child_index) {
						return (*TSFieldMapEntry)(unsafe.Pointer(i)).Field_id
					}

				}
				goto __5
			__5:
				i += 4
				goto __4
				goto __6
			__6:
				;
			}

		}
		goto __2
	__2:
		i--
		goto __1
		goto __3
	__3:
		;
	}
	return TSFieldId(0)
}

func Xts_tree_cursor_current_field_name(tls *libc.TLS, _self uintptr) uintptr { /* tree_cursor.c:467:12: */
	var id TSFieldId = Xts_tree_cursor_current_field_id(tls, _self)
	if id != 0 {
		var self uintptr = _self
		return *(*uintptr)(unsafe.Pointer((*TSLanguage)(unsafe.Pointer((*TSTree)(unsafe.Pointer((*TreeCursor)(unsafe.Pointer(self)).Tree)).Language)).Field_names + uintptr(id)*8))
	} else {
		return uintptr(0)
	}
	return uintptr(0)
}

func Xts_tree_cursor_copy(tls *libc.TLS, _cursor uintptr) TSTreeCursor { /* tree_cursor.c:477:14: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var cursor uintptr = _cursor
	*(*TSTreeCursor)(unsafe.Pointer(bp /* res */)) = TSTreeCursor{}
	var copy uintptr = bp /* &res */
	(*TreeCursor)(unsafe.Pointer(copy)).Tree = (*TreeCursor)(unsafe.Pointer(cursor)).Tree
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((copy + 8 /* &.stack */))).Size = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((copy + 8 /* &.stack */))).Capacity = Uint32_t(0)
	(*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((copy + 8 /* &.stack */))).Contents = uintptr(0)
	array__splice(tls, (copy + 8 /* &.stack */), uint64(unsafe.Sizeof(TreeCursorEntry{})), (*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((copy + 8 /* &.stack */))).Size, uint32(0), (*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((cursor + 8 /* &.stack */))).Size, (*struct {
		Contents uintptr
		Size     Uint32_t
		Capacity Uint32_t
	})(unsafe.Pointer((cursor + 8 /* &.stack */))).Contents)
	return *(*TSTreeCursor)(unsafe.Pointer(bp /* res */))
}

func Xts_tree_new(tls *libc.TLS, root Subtree, language uintptr, included_ranges uintptr, included_range_count uint32) uintptr { /* tree.c:8:8: */
	var result uintptr = ts_malloc_default(tls, uint64(unsafe.Sizeof(TSTree{})))
	(*TSTree)(unsafe.Pointer(result)).Root = root
	(*TSTree)(unsafe.Pointer(result)).Language = language
	(*TSTree)(unsafe.Pointer(result)).Included_ranges = ts_calloc_default(tls, uint64(included_range_count), uint64(unsafe.Sizeof(TSRange{})))
	libc.X__builtin___memcpy_chk(tls, (*TSTree)(unsafe.Pointer(result)).Included_ranges, included_ranges, (uint64(included_range_count) * uint64(unsafe.Sizeof(TSRange{}))), libc.X__builtin_object_size(tls, (*TSTree)(unsafe.Pointer(result)).Included_ranges, 0))
	(*TSTree)(unsafe.Pointer(result)).Included_range_count = included_range_count
	return result
}

func Xts_tree_copy(tls *libc.TLS, self uintptr) uintptr { /* tree.c:21:8: */
	Xts_subtree_retain(tls, (*TSTree)(unsafe.Pointer(self)).Root)
	return Xts_tree_new(tls, (*TSTree)(unsafe.Pointer(self)).Root, (*TSTree)(unsafe.Pointer(self)).Language, (*TSTree)(unsafe.Pointer(self)).Included_ranges, (*TSTree)(unsafe.Pointer(self)).Included_range_count)
}

func Xts_tree_delete(tls *libc.TLS, self uintptr) { /* tree.c:26:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if !(self != 0) {
		return
	}

	*(*SubtreePool)(unsafe.Pointer(bp /* pool */)) = Xts_subtree_pool_new(tls, uint32(0))
	Xts_subtree_release(tls, bp /* &pool */, (*TSTree)(unsafe.Pointer(self)).Root)
	Xts_subtree_pool_delete(tls, bp /* &pool */)
	ts_free_default(tls, (*TSTree)(unsafe.Pointer(self)).Included_ranges)
	ts_free_default(tls, self)
}

func Xts_tree_root_node(tls *libc.TLS, self uintptr) TSNode { /* tree.c:36:8: */
	return Xts_node_new(tls, self, (self /* &.root */), ts_subtree_padding(tls, (*TSTree)(unsafe.Pointer(self)).Root), uint16(0))
}

func Xts_tree_language(tls *libc.TLS, self uintptr) uintptr { /* tree.c:40:18: */
	return (*TSTree)(unsafe.Pointer(self)).Language
}

func Xts_tree_edit(tls *libc.TLS, self uintptr, edit uintptr) { /* tree.c:44:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	{
		var i uint32 = uint32(0)
	__1:
		if !(i < (*TSTree)(unsafe.Pointer(self)).Included_range_count) {
			goto __3
		}
		{
			var range1 uintptr = ((*TSTree)(unsafe.Pointer(self)).Included_ranges + uintptr(i)*24)
			if (*TSRange)(unsafe.Pointer(range1)).End_byte >= (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_byte {
				if (*TSRange)(unsafe.Pointer(range1)).End_byte != UINT32_MAX {
					(*TSRange)(unsafe.Pointer(range1)).End_byte = ((*TSInputEdit)(unsafe.Pointer(edit)).New_end_byte + ((*TSRange)(unsafe.Pointer(range1)).End_byte - (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_byte))
					(*TSRange)(unsafe.Pointer(range1)).End_point = point_add(tls,
						(*TSInputEdit)(unsafe.Pointer(edit)).New_end_point,
						point_sub(tls, (*TSRange)(unsafe.Pointer(range1)).End_point, (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_point))
					if (*TSRange)(unsafe.Pointer(range1)).End_byte < (*TSInputEdit)(unsafe.Pointer(edit)).New_end_byte {
						(*TSRange)(unsafe.Pointer(range1)).End_byte = UINT32_MAX
						(*TSRange)(unsafe.Pointer(range1)).End_point = TSPoint{Row: UINT32_MAX, Column: UINT32_MAX}
					}
				}
				if (*TSRange)(unsafe.Pointer(range1)).Start_byte >= (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_byte {
					(*TSRange)(unsafe.Pointer(range1)).Start_byte = ((*TSInputEdit)(unsafe.Pointer(edit)).New_end_byte + ((*TSRange)(unsafe.Pointer(range1)).Start_byte - (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_byte))
					(*TSRange)(unsafe.Pointer(range1)).Start_point = point_add(tls,
						(*TSInputEdit)(unsafe.Pointer(edit)).New_end_point,
						point_sub(tls, (*TSRange)(unsafe.Pointer(range1)).Start_point, (*TSInputEdit)(unsafe.Pointer(edit)).Old_end_point))
					if (*TSRange)(unsafe.Pointer(range1)).Start_byte < (*TSInputEdit)(unsafe.Pointer(edit)).New_end_byte {
						(*TSRange)(unsafe.Pointer(range1)).Start_byte = UINT32_MAX
						(*TSRange)(unsafe.Pointer(range1)).Start_point = TSPoint{Row: UINT32_MAX, Column: UINT32_MAX}
					}
				}
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
		;
	}

	*(*SubtreePool)(unsafe.Pointer(bp /* pool */)) = Xts_subtree_pool_new(tls, uint32(0))
	(*TSTree)(unsafe.Pointer(self)).Root = Xts_subtree_edit(tls, (*TSTree)(unsafe.Pointer(self)).Root, edit, bp /* &pool */)
	Xts_subtree_pool_delete(tls, bp /* &pool */)
}

func Xts_tree_get_changed_ranges(tls *libc.TLS, self uintptr, other uintptr, count uintptr) uintptr { /* tree.c:78:9: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*TreeCursor)(unsafe.Pointer(bp /* cursor1 */)) = TreeCursor{}
	*(*TreeCursor)(unsafe.Pointer(bp + 24 /* cursor2 */)) = TreeCursor{}
	Xts_tree_cursor_init(tls, bp /* &cursor1 */, Xts_tree_root_node(tls, self))
	Xts_tree_cursor_init(tls, bp+24 /* &cursor2 */, Xts_tree_root_node(tls, other))

	*(*TSRangeArray)(unsafe.Pointer(bp + 48 /* included_range_differences */)) = TSRangeArray{}
	Xts_range_array_get_changed_ranges(tls,
		(*TSTree)(unsafe.Pointer(self)).Included_ranges, (*TSTree)(unsafe.Pointer(self)).Included_range_count,
		(*TSTree)(unsafe.Pointer(other)).Included_ranges, (*TSTree)(unsafe.Pointer(other)).Included_range_count,
		bp+48 /* &included_range_differences */)
	// var result uintptr at bp+64, 8

	*(*Uint32_t)(unsafe.Pointer(count)) = Xts_subtree_get_changed_ranges(tls,
		(self /* &.root */), (other /* &.root */), bp /* &cursor1 */, bp+24, /* &cursor2 */
		(*TSTree)(unsafe.Pointer(self)).Language, bp+48 /* &included_range_differences */, bp+64 /* &result */)

	array__delete(tls, bp+48 /* &included_range_differences */)
	array__delete(tls, (bp /* &cursor1 */ + 8 /* &.stack */))
	array__delete(tls, (bp + 24 /* &cursor2 */ + 8 /* &.stack */))
	return *(*uintptr)(unsafe.Pointer(bp + 64 /* result */))
}

func Xts_tree_print_dot_graph(tls *libc.TLS, self uintptr, file uintptr) { /* tree.c:103:6: */
	Xts_subtree_print_dot_graph(tls, (*TSTree)(unsafe.Pointer(self)).Root, (*TSTree)(unsafe.Pointer(self)).Language, file)
}

var ts1 = "tree-sitter failed to allocate %zu bytes\x00tree-sitter failed to reallocate %zu bytes\x00upstream/tree-sitter/lib/src/array.h\x00index < self->size\x00array__erase\x00old_end <= self->size\x00array__splice\x00upstream/tree-sitter/lib/src/get_changed_ranges.c\x00(uint32_t)(self)->size - 1 < (self)->size\x00ts_range_array_add\x00(uint32_t)(&self->cursor.stack)->size - 1 < (&self->cursor.stack)->size\x00iterator_start_position\x00iterator_end_position\x00iterator_tree_is_visible\x00iterator_ascend\x00iterator_descend\x00iterator_advance\x00upstream/tree-sitter/lib/src/language.c\x00symbol < self->token_count\x00ts_language_table_entry\x00ERROR\x00_ERROR\x00 000000000000\x1000\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1e\x0f\x0f\x0f\x00\x00\x00\x00\x00skip character:'%c'\x00skip character:%d\x00consume character:'%c'\x00consume character:%d\x00upstream/tree-sitter/lib/src/reusable_node.h\x00(uint32_t)(&self->stack)->size - 1 < (&self->stack)->size\x00reusable_node_advance\x00reusable_node_descend\x00\x00graph {\nlabel=\"\x00\"\n}\n\n\x00upstream/tree-sitter/lib/src/parser.c\x00(uint32_t)0 < (&slice.subtrees)->size\x00breakdown_top_of_stack tree:%s\x00\n\n\x00ts_parser__breakdown_top_of_stack\x00state_mismatch sym:%s\x00no_lookahead_after_non_terminal_extra\x00lex_external state:%d, row:%u, column:%u\x00lex_internal state:%d, row:%u, column:%u\x00skip_unrecognized_character\x00lexed_lookahead sym:\x00, size:%u\x00before_reusable_node symbol:%s\x00past_reusable_node symbol:%s\x00reusable_node_has_different_external_scanner_state symbol:%s\x00has_changes\x00is_error\x00is_missing\x00is_fragile\x00contains_different_included_range\x00cant_reuse_node_%s tree:%s\x00cant_reuse_node symbol:%s, first_leaf_symbol:%s\x00reuse_node symbol:%s\x00select_smaller_error symbol:%s, over_symbol:%s\x00select_higher_precedence symbol:%s, prec:%u, over_symbol:%s, other_prec:%u\x00select_earlier symbol:%s, over_symbol:%s\x00select_existing symbol:%s, over_symbol:%s\x00ts_subtree_is_eof(lookahead)\x00!tree.data.is_inline\x00root.ptr\x00ts_parser__accept\x00recover_with_missing symbol:%s, state:%u\x00did_merge\x00ts_parser__handle_error\x00error_trees.size == 1\x00ts_parser__recover_to_state\x00recover_to_previous state:%u, depth:%u\x00recover_eof\x00skip_token symbol:%s\x00shift_extra\x00shift state:%u\x00reduce sym:%s, child_count:%u\x00accept\x00switch from_keyword:%s, to_word_token:%s\x00detect_error\x00resume version:%u\x00condense\x00a\x00resume_parsing\x00parse_after_edit\x00\n\x00different_included_range %u - %u\x00new_parse\x00process version:%d, version_count:%u, state:%d, row:%u, col:%u\x00done\x00upstream/tree-sitter/lib/src/query.c\x00id < self->list.size\x00capture_list_pool_get_mut\x00(uint32_t)(&subgraph->nodes)->size - 1 < (&subgraph->nodes)->size\x00(uint32_t)(&subgraph->start_states)->size - 1 < (&subgraph->start_states)->size\x00exists\x00(uint32_t)(&next_states)->size - 1 < (&next_states)->size\x00final_step_indices.size > 0\x00(uint32_t)(&final_step_indices)->size - 1 < (&final_step_indices)->size\x00ts_query__analyze_patterns\x00(uint32_t)(&self->step_offsets)->size - 1 < (&self->step_offsets)->size\x00(uint32_t)(&self->steps)->size - 1 < (&self->steps)->size\x00ts_query__parse_pattern\x00(uint32_t)(&self->patterns)->size - 1 < (&self->patterns)->size\x00ts_query_new\x00upstream/tree-sitter/lib/src/stack.c\x00self->ref_count > 0\x00self->ref_count != 0\x00stack_node_retain\x00stack_node_release\x00(uint32_t)version < (&self->heads)->size\x00(uint32_t)(&self->iterators)->size - 1 < (&self->iterators)->size\x00stack__iter\x00ts_stack_state\x00ts_stack_position\x00ts_stack_last_external_token\x00ts_stack_set_last_external_token\x00ts_stack_error_cost\x00ts_stack_node_count_since_error\x00ts_stack_push\x00pop.size == 1\x00ts_stack_pop_error\x00ts_stack_get_summary\x00ts_stack_dynamic_precedence\x00ts_stack_has_advanced_since_error\x00ts_stack_remove_version\x00v2 < v1\x00(uint32_t)v1 < self->heads.size\x00ts_stack_renumber_version\x00version < self->heads.size\x00(uint32_t)(&self->heads)->size - 1 < (&self->heads)->size\x00ts_stack_copy_version\x00ts_stack_halt\x00ts_stack_pause\x00ts_stack_is_active\x00ts_stack_is_halted\x00ts_stack_is_paused\x00head->status == StackStatusPaused\x00ts_stack_resume\x00digraph stack {\n\x00rankdir=\"RL\";\n\x00edge [arrowhead=none]\n\x00node_head_%u [shape=none, label=\"\"]\n\x00node_head_%u -> node_%p [\x00color=red \x00label=%u, fontcolor=blue, weight=10000, labeltooltip=\"node_count: %u\nerror_cost: %u\x00\nsummary_size: %u\x00\nexternal_scanner_state:\x00 %2X\x00\"]\n\x00node_%p [\x00label=\"?\"\x00shape=point margin=0 label=\"\"\x00label=\"%d\"\x00 tooltip=\"position: %u,%u\nnode_count:%u\nerror_cost: %u\ndynamic_precedence: %d\"];\n\x00node_%p -> node_%p [\x00style=dashed \x00fontcolor=gray \x00color=red\x00label=\"\x00'\x00\\\x00%c\x00\"\x00labeltooltip=\"error_cost: %u\ndynamic_precedence: %u\"\x00];\n\x00}\n\x00ts_stack_print_dot_graph\x00upstream/tree-sitter/lib/src/subtree.c\x00symbol < 255\x00ts_subtree_set_symbol\x00!self.data.is_inline\x00ts_subtree_summarize_children\x00self.ptr->ref_count > 0\x00self.ptr->ref_count != 0\x00ts_subtree_retain\x00child.ptr->ref_count > 0\x00ts_subtree_release\x00INVALID\x00'\\0'\x00'\\n'\x00'\\t'\x00'\\r'\x00'%c'\x00%d\x00\\\"\x00\\n\x00__ROOT__\x00(NULL)\x00 \x00%s: \x00(UNEXPECTED \x00(MISSING \x00%s\x00\"%s\"\x00(%s\x00(\"%s\")\x00)\x00tree_%p [label=\"\x00, shape=plaintext\x00, fontcolor=gray\x00, tooltip=\"range: %u - %u\nstate: %d\nerror-cost: %u\nhas-changes: %u\ndepends-on-column: %u\nrepeat-depth: %u\nlookahead-bytes: %u\x00\ncharacter: '%c'\x00tree_%p -> tree_%p [tooltip=%u]\n\x00digraph tree {\n\x00upstream/tree-sitter/lib/src/tree_cursor.c\x00ts_tree_cursor_iterate_children\x00ts_tree_cursor_current_node\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
